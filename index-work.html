
<!DOCTYPE html>
<html lang="en" dir="ltr" typeof="bibo:Document w3p:WD" prefix="bibo: http://purl.org/ontology/bibo/ w3p: http://www.w3.org/2001/02pd/rec54#">
<head><meta property="dc:language" content="en" lang="">
    <title>
      Web Audio API (日本語訳)
    </title>
    <meta charset="utf-8">

<!--
    <script src=
    "https://www.w3.org/scripts/MathJax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
-->
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/2.5-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

    <script>
    function findBadLink () {
      var old = document.querySelectorAll(".badLink");
      for (var i = 0 ; i < old.length; i++) {
        nodes[i].style.backgroundColor = "";
        nodes[i].classList.remove("badLink");
      }
      var nodes = document.querySelectorAll('a');

      for (var i = 0; i < nodes.length; i++) {
          if (nodes[i].href) {
              var id =  nodes[i].href.split("/");
              id = id[id.length - 1];
              if (id.length != 0) {
                  if (id[0] == "#") {
                      if (document.querySelectorAll(id).length == 0) {
                        nodes[i].style.backgroundColor = "red";
                        nodes[i].classList.add("badLink");
                        console.log(nodes[i].textContent);
                    }
                 }
              }
          } else {
            nodes[i].style.backgroundColor = "red";
            nodes[i].classList.add("badLink");
          }
      }
    }

    function findMissingLink() {
      var codetags = document.querySelectorAll("code");

      for (var i = 0; i < codetags.length; i++) {
        if (!(codetags[i].parentNode instanceof HTMLAnchorElement) ||
            codetags[i].parentNode.href == "") {
          codetags[i].style.backgroundColor = 'hotpink';
          codetags[i].style.color  = 'yellow';

          console.log(codetags[i].innerHTML);
        }
      }
    }

    // This allow wrapping mathjax formulas in <pre> so the LaTeX code is not
    // auto wrapped and keeps a nice formatting.
    MathJax.Hub.Config({
      tex2jax: {
         skipTags: ["script","noscript","style","textarea","code"]
      }
    });
    function OpenOriginal(x) {
      var url="http://www.w3.org/TR/2015/WD-webaudio-20151208/#"+x;
      window.open(url, "waapioriginal", "width=1000, height=600, toolbar=1,location=1,resizable=1,scrollbars=1,status=1");
    }

    </script>
  <style>
body {
    line-height:125%;
}
.annotate {
    color:red;
}
.orig {
    color:#888;
    background:#ccc;
    display:none;
}
  /*****************************************************************
 * ReSpec 3 CSS
 * Robin Berjon - http://berjon.com/
 *****************************************************************/

/* --- INLINES --- */
em.rfc2119 {
    text-transform:     lowercase;
    font-variant:       small-caps;
    font-style:         normal;
    color:              #900;
}

h1 acronym, h2 acronym, h3 acronym, h4 acronym, h5 acronym, h6 acronym, a acronym,
h1 abbr, h2 abbr, h3 abbr, h4 abbr, h5 abbr, h6 abbr, a abbr {
    border: none;
}

dfn {
    font-weight:    bold;
}

a.internalDFN {
    color:  inherit;
    border-bottom:  1px solid #99c;
    text-decoration:    none;
}

a.externalDFN {
    color:  inherit;
    border-bottom:  1px dotted #ccc;
    text-decoration:    none;
}

a.bibref {
    text-decoration:    none;
}

cite .bibref {
    font-style: normal;
}

code {
    color:  #C83500;
}

/* --- TOC --- */
.toc a, .tof a {
    text-decoration:    none;
}

a .secno, a .figno {
    color:  #000;
}

ul.tof, ol.tof {
    list-style: none outside none;
}

.caption {
    margin-top: 0.5em;
    font-style:   italic;
}

/* --- TABLE --- */
table.simple {
    border-spacing: 0;
    border-collapse:    collapse;
    border-bottom:  3px solid #005a9c;
}

.simple th {
    background: #005a9c;
    color:  #fff;
    padding:    3px 5px;
    text-align: left;
}

.simple th[scope="row"] {
    background: inherit;
    color:  inherit;
    border-top: 1px solid #ddd;
}

.simple td {
    padding:    3px 10px;
    border-top: 1px solid #ddd;
}

.simple tr:nth-child(even) {
    background: #f0f6ff;
}

/* --- DL --- */
.section dd > p:first-child {
    margin-top: 0;
}

.section dd > p:last-child {
    margin-bottom: 0;
}

.section dd {
    margin-bottom:  1em;
}

.section dl.attrs dd, .section dl.eldef dd {
    margin-bottom:  0;
}

@media print {
    .removeOnSave {
        display: none;
    }
}
</style><style>/* --- EXAMPLES --- */
div.example-title {
    min-width: 7.5em;
    color: #b9ab2d;
}
div.example-title span {
    text-transform: uppercase;
}
aside.example, div.example, div.illegal-example {
    padding: 0.5em;
    margin: 1em 0;
    position: relative;
    clear: both;
}
div.illegal-example { color: red }
div.illegal-example p { color: black }
aside.example, div.example {
    padding: .5em;
    border-left-width: .5em;
    border-left-style: solid;
    border-color: #e0cb52;
    background: #fcfaee;
}

aside.example div.example {
    border-left-width: .1em;
    border-color: #999;
    background: #fff;
}
aside.example div.example div.example-title {
    color: #999;
}
</style><style>/* --- ISSUES/NOTES --- */
div.issue-title, div.note-title , div.ednote-title, div.warning-title {
    padding-right:  1em;
    min-width: 7.5em;
    color: #b9ab2d;
}
div.issue-title { color: #e05252; }
div.note-title, div.ednote-title { color: #2b2; }
div.warning-title { color: #f22; }
div.issue-title span, div.note-title span, div.ednote-title span, div.warning-title span {
    text-transform: uppercase;
}
div.note, div.issue, div.ednote, div.warning {
    margin-top: 1em;
    margin-bottom: 1em;
}
.note > p:first-child, .ednote > p:first-child, .issue > p:first-child, .warning > p:first-child { margin-top: 0 }
.issue, .note, .ednote, .warning {
    padding: .5em;
    border-left-width: .5em;
    border-left-style: solid;
}
div.issue, div.note , div.ednote,  div.warning {
    padding: 1em 1.2em 0.5em;
    margin: 1em 0;
    position: relative;
    clear: both;
}
span.note, span.ednote, span.issue, span.warning { padding: .1em .5em .15em; }

.issue {
    border-color: #e05252;
    background: #fbe9e9;
}
.note, .ednote {
    border-color: #52e052;
    background: #e9fbe9;
}

.warning {
    border-color: #f11;
    border-right-width: .2em;
    border-top-width: .2em;
    border-bottom-width: .2em;
    border-style: solid;
    background: #fbe9e9;
}

.warning-title:before{
    content: "⚠"; /*U+26A0 WARNING SIGN*/
    font-size: 3em;
    float: left;
    height: 100%;
    padding-right: .3em;
    vertical-align: top;
    margin-top: -0.5em;
}

li.task-list-item {
    list-style: none;
}

input.task-list-item-checkbox {
    margin: 0 0.35em 0.25em -1.6em;
    vertical-align: middle;
}
</style><style>/* HIGHLIGHTS */
code.prettyprint {
    color:  inherit;
}

/* this from google-code-prettify */
.pln{color:#000}@media screen{.str{color:#080}.kwd{color:#008}.com{color:#800}.typ{color:#606}.lit{color:#066}.pun,.opn,.clo{color:#660}.tag{color:#008}.atn{color:#606}.atv{color:#080}.dec,.var{color:#606}.fun{color:red}}@media print,projection{.str{color:#060}.kwd{color:#006;font-weight:bold}.com{color:#600;font-style:italic}.typ{color:#404;font-weight:bold}.lit{color:#044}.pun,.opn,.clo{color:#440}.tag{color:#006;font-weight:bold}.atn{color:#404}.atv{color:#060}}ol.linenums{margin-top:0;margin-bottom:0}li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8{list-style-type:none}li.L1,li.L3,li.L5,li.L7,li.L9{background:#eee}
</style><style>/* --- WEB IDL --- */
pre.idl {
    border-top: 1px solid #90b8de;
    border-bottom: 1px solid #90b8de;
    padding:    1em;
    line-height:    120%;
}

pre.idl::before {
    content:    "WebIDL";
    display:    block;
    width:      150px;
    background: #90b8de;
    color:  #fff;
    font-family:    sans-serif;
    padding:    3px;
    font-weight:    bold;
    margin: -1em 0 1em -1em;
}

.idlType {
    color:  #ff4500;
    font-weight:    bold;
    text-decoration:    none;
}

/*.idlModule*/
/*.idlModuleID*/
/*.idlInterface*/
.idlInterfaceID, .idlDictionaryID, .idlCallbackID, .idlEnumID {
    font-weight:    bold;
    color:  #005a9c;
}
a.idlEnumItem {
    color:  #000;
    border-bottom:  1px dotted #ccc;
    text-decoration: none;
}

.idlSuperclass {
    font-style: italic;
    color:  #005a9c;
}

/*.idlAttribute*/
.idlAttrType, .idlFieldType, .idlMemberType {
    color:  #005a9c;
}
.idlAttrName, .idlFieldName, .idlMemberName {
    color:  #ff4500;
}
.idlAttrName a, .idlFieldName a, .idlMemberName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlMethod*/
.idlMethType, .idlCallbackType {
    color:  #005a9c;
}
.idlMethName {
    color:  #ff4500;
}
.idlMethName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlCtor*/
.idlCtorName {
    color:  #ff4500;
}
.idlCtorName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlParam*/
.idlParamType {
    color:  #005a9c;
}
.idlParamName, .idlDefaultValue {
    font-style: italic;
}

.extAttr {
    color:  #666;
}

/*.idlSectionComment*/
.idlSectionComment {
    color: gray;
}

/*.idlIterable*/
.idlIterableKeyType, .idlIterableValueType {
    color:  #005a9c;
}

/*.idlMaplike*/
.idlMaplikeKeyType, .idlMaplikeValueType {
    color:  #005a9c;
}

/*.idlConst*/
.idlConstType {
    color:  #005a9c;
}
.idlConstName {
    color:  #ff4500;
}
.idlConstName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlException*/
.idlExceptionID {
    font-weight:    bold;
    color:  #c00;
}

.idlTypedefID, .idlTypedefType {
    color:  #005a9c;
}

.idlRaises, .idlRaises a.idlType, .idlRaises a.idlType code, .excName a, .excName a code {
    color:  #c00;
    font-weight:    normal;
}

.excName a {
    font-family:    monospace;
}

.idlRaises a.idlType, .excName a.idlType {
    border-bottom:  1px dotted #c00;
}

.excGetSetTrue, .excGetSetFalse, .prmNullTrue, .prmNullFalse, .prmOptTrue, .prmOptFalse {
    width:  45px;
    text-align: center;
}
.excGetSetTrue, .prmNullTrue, .prmOptTrue { color:  #0c0; }
.excGetSetFalse, .prmNullFalse, .prmOptFalse { color:  #c00; }

.idlImplements a {
    font-weight:    bold;
}

dl.attributes, dl.methods, dl.constants, dl.constructors, dl.fields, dl.dictionary-members {
    margin-left:    2em;
}

.attributes dt, .methods dt, .constants dt, .constructors dt, .fields dt, .dictionary-members dt {
    font-weight:    normal;
}

.attributes dt code, .methods dt code, .constants dt code, .constructors dt code, .fields dt code, .dictionary-members dt code {
    font-weight:    bold;
    color:  #000;
    font-family:    monospace;
}

.attributes dt code, .fields dt code, .dictionary-members dt code {
    background:  #ffffd2;
}

.attributes dt .idlAttrType code, .fields dt .idlFieldType code, .dictionary-members dt .idlMemberType code {
    color:  #005a9c;
    background:  transparent;
    font-family:    inherit;
    font-weight:    normal;
    font-style: italic;
}

.methods dt code {
    background:  #d9e6f8;
}

.constants dt code {
    background:  #ddffd2;
}

.constructors dt code {
    background:  #cfc;
}

.attributes dd, .methods dd, .constants dd, .constructors dd, .fields dd, .dictionary-members dd {
    margin-bottom:  1em;
}

table.parameters, table.exceptions {
    border-spacing: 0;
    border-collapse:    collapse;
    margin: 0.5em 0;
    width:  100%;
}
table.parameters { border-bottom:  1px solid #90b8de; }
table.exceptions { border-bottom:  1px solid #deb890; }

.parameters th, .exceptions th {
    color:  #fff;
    padding:    3px 5px;
    text-align: left;
    font-weight:    normal;
    text-shadow:    #666 1px 1px 0;
}
.parameters th { background: #90b8de; }
.exceptions th { background: #deb890; }

.parameters td, .exceptions td {
    padding:    3px 10px;
    border-top: 1px solid #ddd;
    vertical-align: top;
}

.parameters tr:first-child td, .exceptions tr:first-child td {
    border-top: none;
}

.parameters td.prmName, .exceptions td.excName, .exceptions td.excCodeName {
    width:  100px;
}

.parameters td.prmType {
    width:  120px;
}

table.exceptions table {
    border-spacing: 0;
    border-collapse:    collapse;
    width:  100%;
}
</style><link href="https://www.w3.org/StyleSheets/TR/W3C-WD" rel="stylesheet"><!--[if lt IE 9]><script src='https://www.w3.org/2008/site/js/html5shiv.js'></script><![endif]--><script type="application/json" id="initialUserConfig">{
  "specStatus": "WD",
  "shortName": "webaudio",
  "edDraftURI": "https://webaudio.github.io/web-audio-api/",
  "editors": [
    {
      "name": "Paul Adenot",
      "company": "Mozilla",
      "companyURL": "https://www.mozilla.org/",
      "mailto": "padenot@mozilla.com",
      "w3cid": "62410"
    },
    {
      "name": "Chris Wilson",
      "company": "Google, Inc.",
      "companyURL": "https://www.google.com/",
      "mailto": "cwilso@google.com",
      "w3cid": "3742"
    }
  ],
  "previousMaturity": "WD",
  "previousPublishDate": "2013-10-10",
  "previousURI": "http://www.w3.org/TR/2012/WD-webaudio-20121213/",
  "wg": "Audio Working Group",
  "wgURI": "http://www.w3.org/2011/audio/",
  "wgPublicList": "public-audio",
  "wgPatentURI": "http://www.w3.org/2004/01/pp-impl/46884/status",
  "tocIntroductory": true,
  "copyrightStart": 2013,
  "otherLinks": [
    {
      "key": "Previous editor",
      "data": [
        {
          "value": "Chris Rogers (Until August 2013)"
        }
      ]
    },
    {
      "key": "Repository",
      "href": "https://github.com/WebAudio/web-audio-api"
    },
    {
      "key": "Bug tracker",
      "href": "https://github.com/WebAudio/web-audio-api/issues?state=open"
    }
  ]
}</script></head>
  <body id="respecDocument" role="document" class="h-entry"><div id="respecHeader" role="contentinfo" class="head">
    <h1>Web Audio API (日本語訳)</h1>
    <h1>---まだ翻訳作業中です---</h1>
    <div style="background-color: #ddf; border: 1px solid #668; padding:10px 20px">
      <p>この文書は、W3Cの文書 "「Web Audio API」 W3C Working Draft 08 December 2015" の日本語訳です。
      </p>
      <p>Web Audio APIの正式な文書は英語版のみであり、日本語訳には翻訳に起因する誤りが含まれている場合があります。<br/>
        正式な文書はW3Cのサイト : <a href="http://www.w3.org/TR/webaudio/">http://www.w3.org/TR/webaudio/</a>にあります。
      </p>
      <p>なお、翻訳元の文書もまだドラフト(Working Draft)です。現状ではまだ説明が不足している部分があったり、今後も頻繁に更新される可能性がある事に注意してください。
      </p>
      <p>
        日本語訳GitHub : <b><a href="https://github.com/g200kg/web-audio-api-ja">https://github.com/g200kg/web-audio-api-ja</a></b><br/>
        日本語訳公開URL : <b><a href="http://g200kg.github.io/web-audio-api-ja/">http://g200kg.github.io/web-audio-api-ja/</a></b>
      </p>
      <p>2016年1月16日</p>
      <hr/>
      <p>Tatsuya Shinyagaito @ g200kg<br/>
        誤りその他があればGitHubページ、下のサイト経由などで連絡をお願いいたします。<br/>
        <b><a href="http://www.g200kg.com/">http://www.g200kg.com/</a></b><br/>
      </p>

    </div>

  <p>


            <a class="logo" href="http://www.w3.org/"><img src="https://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width="72"></a>




  </p>
  <h1 class="title p-name" id="title" property="dcterms:title">Web Audio <abbr title="Application Programming Interface">API</abbr></h1>

  <h2 id="w3c-working-draft-08-december-2015"><abbr title="World Wide Web Consortium">W3C</abbr> Working Draft <time property="dcterms:issued" class="dt-published" datetime="2015-12-08">08 December 2015</time></h2>
  <dl>

      <dt>このバージョン:</dt>
      <dd><a class="u-url" href="http://www.w3.org/TR/2015/WD-webaudio-20151208/">http://www.w3.org/TR/2015/WD-webaudio-20151208/</a></dd>
      <dt>最新の公開バージョン:</dt>
      <dd><a href="http://www.w3.org/TR/webaudio/">http://www.w3.org/TR/webaudio/</a></dd>


      <dt>最新のエディターズドラフト:</dt>
      <dd><a href="https://webaudio.github.io/web-audio-api/">https://webaudio.github.io/web-audio-api/</a></dd>






      <dt>以前のバージョン:</dt>
      <dd><a rel="dcterms:replaces" href="http://www.w3.org/TR/2013/WD-webaudio-20131010/">http://www.w3.org/TR/2013/WD-webaudio-20131010/</a></dd>


    <dt>編集者:</dt>
    <dd class="p-author h-card vcard" property="bibo:editor" resource="_:editor0" data-editor-id="62410"><span property="rdf:first" typeof="foaf:Person"><span property="foaf:name" class="p-name fn">Paul Adenot</span>, <a property="foaf:workplaceHomepage" class="p-org org h-org h-card" href="https://www.mozilla.org/">Mozilla</a>, <span class="ed_mailto"><a class="u-email email" property="foaf:mbox" href="mailto:padenot@mozilla.com">padenot@mozilla.com</a></span></span>
<span property="rdf:rest" resource="_:editor1"></span>
</dd>
<dd class="p-author h-card vcard" resource="_:editor1" data-editor-id="3742"><span property="rdf:first" typeof="foaf:Person"><span property="foaf:name" class="p-name fn">Chris Wilson</span>, <a property="foaf:workplaceHomepage" class="p-org org h-org h-card" href="https://www.google.com/">Google, Inc.</a>, <span class="ed_mailto"><a class="u-email email" property="foaf:mbox" href="mailto:cwilso@google.com">cwilso@google.com</a></span></span>
<span property="rdf:rest" resource="rdf:nil"></span>
</dd>





          <dt>以前の編集者:</dt>



                  <dd>

                      Chris Rogers (Until August 2013)

                  </dd>






          <dt>リポジトリ:</dt>



                <dd>
                  <a href="https://github.com/WebAudio/web-audio-api">https://github.com/WebAudio/web-audio-api</a>
                </dd>






          <dt>バグトラッカー:</dt>



                <dd>
                  <a href="https://github.com/WebAudio/web-audio-api/issues?state=open">https://github.com/WebAudio/web-audio-api/issues?state=open</a>
                </dd>






  </dl>





      <p class="copyright">
        <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> ©
        2013-2015

        <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup>
        (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>,
        <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>,
        <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>).

        <abbr title="World Wide Web Consortium">W3C</abbr> <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
        <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and


            <a rel="license" href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a>


        rules apply.
      </p>

</div>
<hr title="Separator for header">
    <section property="dc:abstract" class="introductory" id="abstract"><!--OddPage--><h2 resource="#h-abstract" id="h-abstract"><span property="xhv:role" resource="xhv:heading">要約</span> <button onclick="OpenOriginal('abstract')">原文</button></h2>
      <!--<p>
        This specification describes a high-level JavaScript <abbr title="Application Programming Interface">API</abbr> for processing and
        synthesizing audio in web applications. The primary paradigm is of an
        audio routing graph, where a number of <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>
        objects are connected together to define the overall audio rendering.
        The actual processing will primarily take place in the underlying
        implementation (typically optimized Assembly / C / C++ code), but
        <a href="#AudioWorker">direct JavaScript processing and
        synthesis</a> is also supported.
      </p>-->
      <p>
        この仕様はWebアプリケーションにおけるオーディオの処理および合成に関する高レベルの
        JavaScript <abbr title="Application Programming Interface">API</abbr> について記述します。
        その基本的な枠組みとなっているのはオーディオのルーティンググラフであり、
        多数の<a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>オブジェクトが互いに接続される事で最終的なオーディオ出力が定義されます。
        実際の処理は基本的に下層にある実装 (典型的には最適化されたアセンブリ言語/C/C++コード)で行われますが、
        <a href="#AudioWorker">JavaScriptによる直接的な処理と合成</a>もサポートされています。
      </p>
      <!--<p>
        The <a href="#introduction">introductory</a> section covers the
        motivation behind this specification.
      </p>-->
      <p><a href="#introduction">序文</a>セクションではこの仕様の背後にある動機についても取り上げます。
      </p>
      <!--<p>
        This <abbr title="Application Programming Interface">API</abbr> is designed to be used in conjunction with other APIs and
        elements on the web platform, notably: XMLHttpRequest [<cite><a href="#bib-XHR" class="bibref">XHR</a></cite>] (using
        the <code>responseType</code> and <code>response</code> attributes).
        For games and interactive applications, it is anticipated to be used
        with the <code>canvas</code> 2D [<cite><a href="#bib-2dcontext" class="bibref">2dcontext</a></cite>] and WebGL [<cite><a href="#bib-WEBGL" class="bibref">WEBGL</a></cite>] 3D
        graphics APIs.
      </p>-->
        この<abbr title="Application Programming Interface">API</abbr>は他のAPIやWebプラットフォームの要素、
        特に(<code>responseType</code> と <code>response</code> 属性を使った) XMLHttpRequest[<cite><a href="#bib-XHR" class="bibref">XHR</a></cite>]
         と共に使われるように設計されています。
         ゲームやインタラクティブなアプリケーションでは、<code>canvas</code> 2D [<cite><a href="#bib-2dcontext" class="bibref">2dcontext</a></cite>]
         および WebGL [<cite><a href="#bib-WEBGL" class="bibref">WEBGL</a></cite>]3D グラフィックスAPIと共に使われる事が予想されます。
      <p>
      </p>
    </section><section id="sotd" class="introductory"><!--OddPage--><h2 resource="#h-sotd" id="h-sotd"><span property="xhv:role" resource="xhv:heading">この文書の位置付け</span></h2>



        <!--<p>
          <em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current <abbr title="World Wide Web Consortium">W3C</abbr> publications and the latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/"><abbr title="World Wide Web Consortium">W3C</abbr> technical reports index</a> at http://www.w3.org/TR/.</em>
        </p>-->
        <p>
          <em>このセクションは、この文書の公開時における状況を記述したものです。 他の文書がこの文書に取って代わるかもしれません。 現在の<abbr title="World Wide Web Consortium">W3C</abbr>の刊行物およびこの技術レポートの最新改訂版のリストは、<a href="http://www.w3.org/TR/"><abbr title="World Wide Web Consortium">W3C</abbr>技術レポートhttp://www.w3.org/TR/のリスト</a>から見つけることができます。</em>
        </p>




          <!--<p>
            This document was published by the <a href="http://www.w3.org/2011/audio/">Audio Working Group</a> as a Working Draft.

              This document is intended to become a <abbr title="World Wide Web Consortium">W3C</abbr> Recommendation.


              If you wish to make comments regarding this document, please send them to
              <a href="mailto:public-audio@w3.org">public-audio@w3.org</a>
              (<a href="mailto:public-audio-request@w3.org?subject=subscribe">subscribe</a>,
              <a href="http://lists.w3.org/Archives/Public/public-audio/">archives</a>).






              All comments are welcome.


          </p>-->
          <p>
            この文書は<a href="http://www.w3.org/2011/audio/">Audio Working Group</a>によってワーキングドラフトとして発行されました。
            この文書は<abbr title="World Wide Web Consortium">W3C</abbr>リコメンデーションとなる事を意図しています。
            もしこの文書に対するコメントがあれば、
            <a href="mailto:public-audio@w3.org">public-audio@w3.org</a>(<a href="mailto:public-audio-request@w3.org?subject=subscribe">subscribe</a>,
            <a href="http://lists.w3.org/Archives/Public/public-audio/">archives</a>)に送ってください。
            全てのコメントを歓迎します。
          </p>


            <!--<p>
              Publication as a Working Draft does not imply endorsement by the <abbr title="World Wide Web Consortium">W3C</abbr>
              Membership. This is a draft document and may be updated, replaced or obsoleted by other
              documents at any time. It is inappropriate to cite this document as other than work in
              progress.
            </p>-->
            <p>
              ワーキングドラフトとしての公開は<abbr title="World Wide Web Consortium">W3C</abbr>メンバーによる承認を意味するものではありません。
              これは草案文書であり、いつでも他の文書によって改訂、置き換えあるいは廃止される可能性があります。
              この文書を作業中のもの以外として引用する事は不適切です。
            </p>
          <!--<p>

              This document was produced by

              a group
               operating under the
              <a id="sotd_patent" property="w3p:patentRules" href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 <abbr title="World Wide Web Consortium">W3C</abbr> Patent
              Policy</a>.




                <abbr title="World Wide Web Consortium">W3C</abbr> maintains a <a href="http://www.w3.org/2004/01/pp-impl/46884/status" rel="disclosure">public list of any patent
                disclosures</a>

              made in connection with the deliverables of

              the group; that page also includes

              instructions for disclosing a patent. An individual who has actual knowledge of a patent
              which the individual believes contains
              <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential
              Claim(s)</a> must disclose the information in accordance with
              <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
              6 of the <abbr title="World Wide Web Consortium">W3C</abbr> Patent Policy</a>.


          </p>-->
          <p>
            この文書は<a id="sotd_patent" property="w3p:patentRules" href="http://www.w3.org/Consortium/Patent-Policy-20040205/">2004年2月5日 <abbr title="World Wide Web Consortium">W3C</abbr> Patent Policy</a>の基に運用されるグループによって作成されました。
            <abbr title="World Wide Web Consortium">W3C</abbr>はグループの成果物から作成された<a href="http://www.w3.org/2004/01/pp-impl/46884/status" rel="disclosure">特許開示リスト</a>を管理しています。
            また、このページは特許開示の方法についても提示しています。 特許について実際の知識を持ち、それが<a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">基本的な請求事項</a>を含むと考える者は、 <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure"><abbr title="World Wide Web Consortium">W3C</abbr> Patent Policy 6節</a>に従って情報を開示しなくてはなりません。
          </p>

            <!--<p>This document is governed by the <a id="w3c_process_revision" href="http://www.w3.org/2015/Process-20150901/">1 September 2015 <abbr title="World Wide Web Consortium">W3C</abbr> Process Document</a>.
            </p>-->
            <p>この文書は<a id="w3c_process_revision" href="http://www.w3.org/2015/Process-20150901/">2015年9月1日 <abbr title="World Wide Web Consortium">W3C</abbr> Process Document</a> によって管理されます。
            </p>






</section><section id="toc"><h2 resource="#h-toc" id="h-toc" class="introductory"><span property="xhv:role" resource="xhv:heading">目次</span></h2><ul role="directory" class="toc"><li class="tocline"><a class="tocxref" href="#abstract">概要</a></li><li class="tocline"><a class="tocxref" href="#sotd">この文書の位置付け</a></li><li class="tocline"><a class="tocxref" href="#introduction">
        序文
      </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#Features"><span class="secno">0.1 </span>
          機能
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#ModularRouting"><span class="secno">0.1.1 </span>
            モジュラールーティング
          </a></li></ul></li><li class="tocline"><a class="tocxref" href="#APIOverview"><span class="secno">0.2 </span>
          <abbr title="Application Programming Interface">API</abbr> の概要
        </a></li></ul></li><li class="tocline"><a class="tocxref" href="#conformance"><span class="secno">1. </span>準拠</a></li><li class="tocline"><a class="tocxref" href="#API"><span class="secno">2. </span>
        オーディオ <abbr title="Application Programming Interface">API</abbr>
      </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#BaseAudioContext"><span class="secno">2.1 </span>
          BaseAudioContext インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes"><span class="secno">2.1.1 </span>属性</a></li><li class="tocline"><a class="tocxref" href="#methods"><span class="secno">2.1.2 </span>メソッド</a></li><li class="tocline"><a class="tocxref" href="#callback-decodesuccesscallback-parameters"><span class="secno">2.1.3 </span>コールバック <span class="formerLink"><code>DecodeSuccessCallback</code></span> パラメータ</a></li><li class="tocline"><a class="tocxref" href="#callback-decodeerrorcallback-parameters"><span class="secno">2.1.4 </span>コールバック <span class="formerLink"><code>DecodeErrorCallback</code></span> パラメータ</a></li><li class="tocline"><a class="tocxref" href="#dictionary-audiocontextoptions-members"><span class="secno">2.1.5 </span>ディクショナリ <span class="formerLink"><code>AudioContextOptions</code></span> メンバー</a></li><li class="tocline"><a class="tocxref" href="#lifetime-AudioContext"><span class="secno">2.1.6 </span>
            ライフタイム
          </a></li><li class="tocline"><a class="tocxref" href="#lack-of-introspection-or-serialization-primitives"><span class="secno">2.1.7 </span>
            内部検査やシリアライゼーションの基本機能の欠如
          </a></li></ul></li><li class="tocline"><a class="tocxref" href="#AudioContext"><span class="secno">2.2 </span>
          AudioContext インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#methods-1"><span class="secno">2.2.1 </span>メソッド</a></li></ul></li><li class="tocline"><a class="tocxref" href="#OfflineAudioContext"><span class="secno">2.3 </span>
          OfflineAudioContext インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-1"><span class="secno">2.3.1 </span>属性</a></li><li class="tocline"><a class="tocxref" href="#methods-2"><span class="secno">2.3.2 </span>メソッド</a></li><li class="tocline"><a class="tocxref" href="#OfflineAudioCompletionEvent"><span class="secno">2.3.3 </span>
            OfflineAudioCompletionEvent インターフェース
          </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-2"><span class="secno">2.3.3.1 </span>属性</a></li></ul></li></ul></li><li class="tocline"><a class="tocxref" href="#the-audionode-interface"><span class="secno">2.4 </span>
          <span data-dfn-type="dfn">AudioNode</span> インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-3"><span class="secno">2.4.1 </span>属性</a></li><li class="tocline"><a class="tocxref" href="#methods-3"><span class="secno">2.4.2 </span>メソッド</a></li><li class="tocline"><a class="tocxref" href="#lifetime-AudioNode"><span class="secno">2.4.3 </span>
            ライフタイム
          </a></li></ul></li><li class="tocline"><a class="tocxref" href="#AudioDestinationNode"><span class="secno">2.5 </span>
          AudioDestinationNode インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-4"><span class="secno">2.5.1 </span>属性</a></li></ul></li><li class="tocline"><a class="tocxref" href="#AudioParam"><span class="secno">2.6 </span>
          AudioParam インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-5"><span class="secno">2.6.1 </span>属性</a></li><li class="tocline"><a class="tocxref" href="#methods-4"><span class="secno">2.6.2 </span>メソッド</a></li><li class="tocline"><a class="tocxref" href="#computation-of-value"><span class="secno">2.6.3 </span>
            値の計算
          </a></li><li class="tocline"><a class="tocxref" href="#example1-AudioParam"><span class="secno">2.6.4 </span>
            AudioParam オートメーションの例
          </a></li></ul></li><li class="tocline"><a class="tocxref" href="#GainNode"><span class="secno">2.7 </span>
          GainNode インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-6"><span class="secno">2.7.1 </span>属性</a></li></ul></li><li class="tocline"><a class="tocxref" href="#DelayNode"><span class="secno">2.8 </span>
          DelayNode インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-7"><span class="secno">2.8.1 </span>属性</a></li></ul></li><li class="tocline"><a class="tocxref" href="#AudioBuffer"><span class="secno">2.9 </span>
          AudioBuffer インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-8"><span class="secno">2.9.1 </span>属性</a></li><li class="tocline"><a class="tocxref" href="#methods-5"><span class="secno">2.9.2 </span>メソッド</a></li></ul></li><li class="tocline"><a class="tocxref" href="#AudioBufferSourceNode"><span class="secno">2.10 </span>
          AudioBufferSourceNode インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-9"><span class="secno">2.10.1 </span>属性</a></li><li class="tocline"><a class="tocxref" href="#methods-6"><span class="secno">2.10.2 </span>メソッド</a></li><li class="tocline"><a class="tocxref" href="#looping-AudioBufferSourceNode"><span class="secno">2.10.3 </span>
            ルーピング
          </a></li></ul></li><li class="tocline"><a class="tocxref" href="#MediaElementAudioSourceNode"><span class="secno">2.11 </span>
          MediaElementAudioSourceNode インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#security-with-mediaelementaudiosourcenode-and-cross-origin-resources"><span class="secno">2.11.1 </span>
            MediaElementAudioSourceNode のセキュリティと クロスオリジン・リソース
          </a></li></ul></li><li class="tocline"><a class="tocxref" href="#AudioWorker"><span class="secno">2.12 </span>
          <span data-dfn-type="dfn">AudioWorker</span> インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-10"><span class="secno">2.12.1 </span>属性</a></li><li class="tocline"><a class="tocxref" href="#methods-7"><span class="secno">2.12.2 </span>メソッド</a></li><li class="tocline"><a class="tocxref" href="#AudioWorkerNode"><span class="secno">2.12.3 </span>
            <span data-dfn-type="dfn">AudioWorkerNode</span> インターフェース
          </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-11"><span class="secno">2.12.3.1 </span>属性</a></li><li class="tocline"><a class="tocxref" href="#methods-8"><span class="secno">2.12.3.2 </span>メソッド</a></li></ul></li><li class="tocline"><a class="tocxref" href="#AudioWorkerParamDescriptor"><span class="secno">2.12.4 </span>
            <span data-dfn-type="dfn">AudioWorkerParamDescriptor</span> インターフェース
          </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-12"><span class="secno">2.12.4.1 </span>属性</a></li></ul></li><li class="tocline"><a class="tocxref" href="#the-audioworkerglobalscope-interface"><span class="secno">2.12.5 </span>
            AudioWorkerGlobalScope インターフェース
          </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-13"><span class="secno">2.12.5.1 </span>属性</a></li><li class="tocline"><a class="tocxref" href="#methods-9"><span class="secno">2.12.5.2 </span>メソッド</a></li></ul></li><li class="tocline"><a class="tocxref" href="#the-audioworkernodeprocessor-interface"><span class="secno">2.12.6 </span>
            AudioWorkerNodeProcessor インターフェース
          </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-14"><span class="secno">2.12.6.1 </span>属性</a></li><li class="tocline"><a class="tocxref" href="#methods-10"><span class="secno">2.12.6.2 </span>メソッド</a></li></ul></li><li class="tocline"><a class="tocxref" href="#audio-worker-examples"><span class="secno">2.12.7 </span>
            Audio Worker の例
          </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#a-bitcrusher-node"><span class="secno">2.12.7.1 </span>
              ビットクラッシャー・ノード
            </a></li><li class="tocline"><a class="tocxref" href="#todo-fix-up-this-example.-a-volume-meter-and-clip-detector"><span class="secno">2.12.7.2 </span>
              TODO: この例を修正する事。 A Volume Meter and Clip Detector
            </a></li><li class="tocline"><a class="tocxref" href="#reimplementing-channelmerger"><span class="secno">2.12.7.3 </span>
              ChannelMergerの再実装
            </a></li></ul></li></ul></li><li class="tocline"><a class="tocxref" href="#the-scriptprocessornode-interface---deprecated"><span class="secno">2.13 </span>
          ScriptProcessorNode インターフェース - DEPRECATED
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-15"><span class="secno">2.13.1 </span>属性</a></li></ul></li><li class="tocline"><a class="tocxref" href="#the-audioworkernodecreationevent-interface"><span class="secno">2.14 </span>
          AudioWorkerNodeCreationEvent インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-16"><span class="secno">2.14.1 </span>属性</a></li></ul></li><li class="tocline"><a class="tocxref" href="#the-audioprocessevent-interface"><span class="secno">2.15 </span>
          AudioProcessEvent インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-17"><span class="secno">2.15.1 </span>属性</a></li></ul></li><li class="tocline"><a class="tocxref" href="#the-audioprocessingevent-interface---deprecated"><span class="secno">2.16 </span>
          AudioProcessingEvent インターフェース - DEPRECATED
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-18"><span class="secno">2.16.1 </span>属性</a></li></ul></li><li class="tocline"><a class="tocxref" href="#the-pannernode-interface"><span class="secno">2.17 </span>
          PannerNode インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-19"><span class="secno">2.17.1 </span>属性</a></li><li class="tocline"><a class="tocxref" href="#methods-11"><span class="secno">2.17.2 </span>メソッド</a></li><li class="tocline"><a class="tocxref" href="#panner-channel-limitations"><span class="secno">2.17.3 </span>
            チャンネル制限
          </a></li></ul></li><li class="tocline"><a class="tocxref" href="#AudioListener"><span class="secno">2.18 </span>
          AudioListener インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#methods-12"><span class="secno">2.18.1 </span>メソッド</a></li></ul></li><li class="tocline"><a class="tocxref" href="#the-spatialpannernode-interface"><span class="secno">2.19 </span>
          SpatialPannerNode インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-20"><span class="secno">2.19.1 </span>属性</a></li></ul></li><li class="tocline"><a class="tocxref" href="#SpatialListener"><span class="secno">2.20 </span>
          SpatialListener インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-21"><span class="secno">2.20.1 </span>属性</a></li></ul></li><li class="tocline"><a class="tocxref" href="#the-stereopannernode-interface"><span class="secno">2.21 </span>
          StereoPannerNode インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-22"><span class="secno">2.21.1 </span>属性</a></li><li class="tocline"><a class="tocxref" href="#channel-limitations"><span class="secno">2.21.2 </span>
            チャンネル制限
          </a></li></ul></li><li class="tocline"><a class="tocxref" href="#ConvolverNode"><span class="secno">2.22 </span>
          ConvolverNode インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-23"><span class="secno">2.22.1 </span>属性</a></li><li class="tocline"><a class="tocxref" href="#Convolution-channel-configurations"><span class="secno">2.22.2 </span>
            入力、インパルスレスポンス、出力のチャンネル構成
          </a></li></ul></li><li class="tocline"><a class="tocxref" href="#the-analysernode-interface"><span class="secno">2.23 </span>
          AnalyserNode インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-24"><span class="secno">2.23.1 </span>属性</a></li><li class="tocline"><a class="tocxref" href="#methods-13"><span class="secno">2.23.2 </span>メソッド</a></li><li class="tocline"><a class="tocxref" href="#fft-windowing-and-smoothing-over-time"><span class="secno">2.23.3 </span>
            FFT ウィンドウイングと時間的スムージング
          </a></li></ul></li><li class="tocline"><a class="tocxref" href="#the-channelsplitternode-interface"><span class="secno">2.24 </span>
          ChannelSplitterNode インターフェース
        </a></li><li class="tocline"><a class="tocxref" href="#the-channelmergernode-interface"><span class="secno">2.25 </span>
          ChannelMergerNode インターフェース
        </a></li><li class="tocline"><a class="tocxref" href="#the-dynamicscompressornode-interface"><span class="secno">2.26 </span>
          DynamicsCompressorNode インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-25"><span class="secno">2.26.1 </span>属性</a></li></ul></li><li class="tocline"><a class="tocxref" href="#the-biquadfilternode-interface"><span class="secno">2.27 </span>
          BiquadFilterNode インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-26"><span class="secno">2.27.1 </span>属性</a></li><li class="tocline"><a class="tocxref" href="#methods-14"><span class="secno">2.27.2 </span>メソッド</a></li><li class="tocline"><a class="tocxref" href="#filters-characteristics"><span class="secno">2.27.3 </span>
            フィルター特性
          </a></li></ul></li><li class="tocline"><a class="tocxref" href="#the-iirfilternode-interface"><span class="secno">2.28 </span>
          IIRFilterNode インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#methods-15"><span class="secno">2.28.1 </span>Methods</a></li><li class="tocline"><a class="tocxref" href="#filter-definition"><span class="secno">2.28.2 </span>
            フィルター定義
          </a></li></ul></li><li class="tocline"><a class="tocxref" href="#WaveShaperNode"><span class="secno">2.29 </span>
          WaveShaperNode インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-27"><span class="secno">2.29.1 </span>属性</a></li></ul></li><li class="tocline"><a class="tocxref" href="#the-oscillatornode-interface"><span class="secno">2.30 </span>
          OscillatorNode インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-28"><span class="secno">2.30.1 </span>属性</a></li><li class="tocline"><a class="tocxref" href="#methods-16"><span class="secno">2.30.2 </span>メソッド</a></li><li class="tocline"><a class="tocxref" href="#basic-waveform-phase"><span class="secno">2.30.3 </span>
            基本波形の位相
          </a></li></ul></li><li class="tocline"><a class="tocxref" href="#the-periodicwave-interface"><span class="secno">2.31 </span>
          PeriodicWave インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#periodicwaveconstraints"><span class="secno">2.31.1 </span>
            PeriodicWaveConstraints
          </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#dictionary-periodicwaveconstraints-members"><span class="secno">2.31.1.1 </span>ディクショナリ <span class="formerLink"><code>PeriodicWaveConstraints</code></span> メンバー</a></li></ul></li><li class="tocline"><a class="tocxref" href="#waveform-generation"><span class="secno">2.31.2 </span>
            波形の生成
          </a></li><li class="tocline"><a class="tocxref" href="#waveform-normalization"><span class="secno">2.31.3 </span>
            波形の正規化
          </a></li><li class="tocline"><a class="tocxref" href="#oscillator-coefficients"><span class="secno">2.31.4 </span>
            オシレーター係数
          </a></li></ul></li><li class="tocline"><a class="tocxref" href="#MediaStreamAudioSourceNode"><span class="secno">2.32 </span>
          MediaStreamAudioSourceNode インターフェース
        </a></li><li class="tocline"><a class="tocxref" href="#the-mediastreamaudiodestinationnode-interface"><span class="secno">2.33 </span>
          MediaStreamAudioDestinationNode インターフェース
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#attributes-29"><span class="secno">2.33.1 </span>属性</a></li></ul></li></ul></li><li class="tocline"><a class="tocxref" href="#mixer-gain-structure"><span class="secno">3. </span>
        ミキサーのゲイン構造
      </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#SummingJunction"><span class="secno">3.1 </span>
          入力のサミング
        </a></li><li class="tocline"><a class="tocxref" href="#gain-control"><span class="secno">3.2 </span>
          ゲイン・コントロール
        </a></li><li class="tocline"><a class="tocxref" href="#Example-mixer-with-send-busses"><span class="secno">3.3 </span>
          例: センドバス付きミキサー
        </a></li></ul></li><li class="tocline"><a class="tocxref" href="#DynamicLifetime"><span class="secno">4. </span>
        ダイナミック・ライフタイム
      </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#background-1"><span class="secno">4.1 </span>
          背景
        </a></li><li class="tocline"><a class="tocxref" href="#example"><span class="secno">4.2 </span>
          例
        </a></li></ul></li><li class="tocline"><a class="tocxref" href="#channel-up-mixing-and-down-mixing"><span class="secno">5. </span>
        チャンネルのアップミキシングとダウンミキシング
      </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#ChannelLayouts"><span class="secno">5.1 </span>
          スピーカー・チャンネル・レイアウト
        </a></li><li class="tocline"><a class="tocxref" href="#ChannelOrdering"><span class="secno">5.2 </span>
          チャンネルの順序
        </a></li><li class="tocline"><a class="tocxref" href="#UpMix-sub"><span class="secno">5.3 </span>
          アップミキシング・スピーカーレイアウト
        </a></li><li class="tocline"><a class="tocxref" href="#down-mix"><span class="secno">5.4 </span>
          ダウンミキシング・スピーカーレイアウト
        </a></li><li class="tocline"><a class="tocxref" href="#ChannelRules-section"><span class="secno">5.5 </span>
          チャンネルルールの例
        </a></li></ul></li><li class="tocline"><a class="tocxref" href="#audio-sample-values"><span class="secno">6. </span>
        オーディオ信号の値
      </a></li><li class="tocline"><a class="tocxref" href="#Spatialization"><span class="secno">7. </span>
        空間配置 / バンニング
      </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#Spatialization-background"><span class="secno">7.1 </span>
          背景
        </a></li><li class="tocline"><a class="tocxref" href="#azimuth-elevation"><span class="secno">7.2 </span>
          アジマスとエレベーション
        </a></li><li class="tocline"><a class="tocxref" href="#Spatialization-panning-algorithm"><span class="secno">7.3 </span>
          バンニング・アルゴリズム
        </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#Spatialzation-equal-power-panning"><span class="secno">7.3.1 </span>
            Equal-power パンニング
          </a></li><li class="tocline"><a class="tocxref" href="#hrtf-panning-stereo-only"><span class="secno">7.3.2 </span>
            HRTF パンニング (ステレオのみ)
          </a></li></ul></li><li class="tocline"><a class="tocxref" href="#Spatialization-distance-effects"><span class="secno">7.4 </span>
          距離効果
        </a></li><li class="tocline"><a class="tocxref" href="#Spatialization-sound-cones"><span class="secno">7.5 </span>
          サウンド・コーン
        </a></li><li class="tocline"><a class="tocxref" href="#Spatialization-doppler-shift"><span class="secno">7.6 </span>
          ドップラー効果
        </a></li></ul></li><li class="tocline"><a class="tocxref" href="#Performance"><span class="secno">8. </span>
        パフォーマンスに関する考察
      </a><ul class="toc"><li class="tocline"><a class="tocxref" href="#latency"><span class="secno">8.1 </span>
          レイテンシー
        </a></li><li class="tocline"><a class="tocxref" href="#audio-buffer-copying"><span class="secno">8.2 </span>
          オーディオバッファのコピー
        </a></li><li class="tocline"><a class="tocxref" href="#audioparam-transitions"><span class="secno">8.3 </span>
          AudioParam の遷移
        </a></li><li class="tocline"><a class="tocxref" href="#audio-glitching"><span class="secno">8.4 </span>
          オーディオ・グリッジ
        </a></li><li class="tocline"><a class="tocxref" href="#JavaScriptPerformance"><span class="secno">8.5 </span>
          リアルタイム処理と合成に関するJavascriptの課題:
        </a></li></ul></li><li class="tocline"><a class="tocxref" href="#SecurityConsiderations"><span class="secno">9. </span>
          セキュリティに関する考察
      </a></li><li class="tocline"><a class="tocxref" href="#PrivacyConsiderations"><span class="secno">10. </span>
        プライバシーに関する考察
      </a></li><li class="tocline"><a class="tocxref" href="#requirements"><span class="secno">11. </span>
        要求と使用例
      </a></li><li class="tocline"><a class="tocxref" href="#acknowledgements"><span class="secno">12. </span>
        承認
      </a></li><li class="tocline"><a class="tocxref" href="#ChangeLog"><span class="secno">13. </span>
        Web Audio <abbr title="Application Programming Interface">API</abbr> チェンジログ
      </a></li><li class="tocline"><a class="tocxref" href="#references"><span class="secno">A. </span>リファレンス</a><ul class="toc"><li class="tocline"><a class="tocxref" href="#normative-references"><span class="secno">A.1 </span>基準リファレンス</a></li><li class="tocline"><a class="tocxref" href="#informative-references"><span class="secno">A.2 </span>参考リファレンス</a></li></ul></li></ul></section>

    <section property="bibo:hasPart" resource="#introduction" typeof="bibo:Chapter" id="introduction" class="introductory">
      <!--OddPage--><h2 resource="#h-introduction" id="h-introduction"><span property="xhv:role" resource="xhv:heading">
        序文 <button onclick="OpenOriginal('introduction')">原文</button>
      </span></h2>
      <section property="bibo:hasPart" resource="" typeof="bibo:Chapter">
        <!--<p>
          Audio on the web has been fairly primitive up to this point and until
          very recently has had to be delivered through plugins such as Flash
          and QuickTime. The introduction of the <code>audio</code> element in
          HTML5 is very important, allowing for basic streaming audio playback.
          But, it is not powerful enough to handle more complex audio
          applications. For sophisticated web-based games or interactive
          applications, another solution is required. It is a goal of this
          specification to include the capabilities found in modern game audio
          engines as well as some of the mixing, processing, and filtering
          tasks that are found in modern desktop audio production applications.
        </p>-->
        <p>
          これまでのWeb上のオーディオはかなり未発達なもので、ごく最近まで Flash や QuickTime のようなプラグインを通して配信しなくてはなりませんでした。 HTML5 での <code>audio</code> 要素の導入は、基本的なストリーミング・オーディオ再生を可能にする重要なものです。 しかし、より複雑なオーディオアプリケーションを扱うには、それだけではまだ充分に強力ではありません。 洗練されたWebベースのゲームやインタラクティブ・アプリケーションのためには別の解決策が必要とされます。 この仕様では、近年のデスクトップ・オーディオ制作アプリケーションに見られるミキシング、プロセシング、フィルタリング処理に加え、近年のゲームオーディオエンジンに見られるような機能も持たせる事を目標とします。
        </p>
        <!--<p>
          The APIs have been designed with a wide variety of use cases
          [<cite><a href="#bib-webaudio-usecases" class="bibref">webaudio-usecases</a></cite>] in mind. Ideally, it should be able to support
          <i>any</i> use case which could reasonably be implemented with an
          optimized C++ engine controlled via JavaScript and run in a browser.
          That said, modern desktop audio software can have very advanced
          capabilities, some of which would be difficult or impossible to build
          with this system. Apple's Logic Audio is one such application which
          has support for external MIDI controllers, arbitrary plugin audio
          effects and synthesizers, highly optimized direct-to-disk audio file
          reading/writing, tightly integrated time-stretching, and so on.
          Nevertheless, the proposed system will be quite capable of supporting
          a large range of reasonably complex games and interactive
          applications, including musical ones. And it can be a very good
          complement to the more advanced graphics features offered by WebGL.
          The <abbr title="Application Programming Interface">API</abbr> has been designed so that more advanced capabilities can be
          added at a later time.
        </p>-->
        <p>
          この API はさまざまな使用例 [<cite><a href="#bib-webaudio-usecases" class="bibref">webaudio-usecases</a></cite>] を考慮して設計されています。 理想的には<i>全ての</i>使用例が、 JavaScript から制御される最適化された C++ エンジンを使って無理なく実装でき、ブラウザで動作するようにサポートされなくてはなりません。 とは言っても、近年のデスクトップ・オーディオソフトウェアは極めて高度な機能を持ち、それらの一部はこのシステムを使ったとしても構築する事が困難か不可能と考えられます。 Apple 社の Logic Audio がそのようなアプリケーションの1つであり、外部 MIDI コントローラー、任意のプラグイン・オーディオエフェクトやシンセサイザー、高度に最適化されたオーディオファイルのディスクへの読み込み/書き出し、密に統合されたタイムストレッチなどなどをサポートしています。 それでもなお、ここで提案するシステムは、音楽に関するものを含めて、かなり複雑なゲームやインタラクティブ・アプリケーションの広い範囲を充分にサポートする事が可能です。 またそれは、 WebGL によってもたらされる、より高度なグラフィックスの機能をよく引き立たせる事が可能です。 この<abbr title="Application Programming Interface">API</abbr>はより高度な機能を後から追加できるように設計されています。
        </p>
      </section>
      <section property="bibo:hasPart" resource="#Features" typeof="bibo:Chapter">
        <h3 resource="#Features" id="Features"><span property="xhv:role" resource="xhv:heading"><span class="secno">0.1 </span>
          機能 <button onclick="OpenOriginal('Features')">原文</button>
        </span></h3>
        <!--<p>
          The <abbr title="Application Programming Interface">API</abbr> supports these primary features:
        </p>-->
        <p>この <abbr title="Application Programming Interface">API</abbr> は、これらの基本機能をサポートします:
        </p>
        <ul>
          <!--<li>
            <a href="#ModularRouting">Modular routing</a> for simple or complex
            mixing/effect architectures, including <a href="#mixer-gain-structure">multiple sends and submixes</a>.
          </li>-->
          <li>
            単純な、または<a href="#mixer-gain-structure">複数のセンド、サブミックス</a>を含む複雑なミキシング/エフェクト・アーキテクチャーのための  <a href="#ModularRouting">モジュラールーティング</a>
          </li>
          <!--<li>High dynamic range, using 32bits floats for internal processing.
          </li>-->
          <li>内部処理に32ピット浮動小数を使用した高いダイナミックレンジ
          </li>
          <!--<li>
            <a href="#AudioParam">Sample-accurate scheduled sound playback</a>
            with low <a href="#latency">latency</a> for musical applications
            requiring a very high degree of rhythmic precision such as drum
            machines and sequencers. This also includes the possibility of
            <a href="#DynamicLifetime">dynamic creation</a> of effects.
          </li>-->
          <li>
            非常に高度なリズムの精度を必要とするドラムマシンやシーケンサーなどのアプリケーションのための、低<a href="#latency">レイテンシー</a>な<a href="#AudioParam">サンプル単位の時間精度での音の再生</a>。これには、エフェクトを<a href="#DynamicLifetime">動的に生成</a>できるようにする事も含まれます
          </li>
          <!--<li>Automation of audio parameters for envelopes, fade-ins /
          fade-outs, granular effects, filter sweeps, LFOs etc.
        </li>-->
          <li>エンベロープ、フェードイン/フェードアウト、グラニュラーエフェクト、フィルタスイープ、 LFO などのためのオーディオパラメータのオートメーション
          </li>
          <!--<li>Flexible handling of channels in an audio stream, allowing them
          to be split and merged.
        </li>-->
          <li>分割や結合など、オーディオストリームのチャンネルに対する柔軟な扱い
          </li>
          <!--<li>Processing of audio sources from an <code>audio</code> or <code>
            video</code> <a href="#MediaElementAudioSourceNode">media
            element</a>.
          </li>-->
          <li><code>audio</code> または <code>video</code> <a href="#MediaElementAudioSourceNode">メディア要素</a>からのオーディオに対する処理
          </li>
          <!--<li>Processing live audio input using a <a href="#MediaStreamAudioSourceNode">MediaStream</a> from getUserMedia().
          </li>-->
          <li>
            getUserMedia()からの<a href="#MediaStreamAudioSourceNode">MediaStream</a>を使用したライブオーディオに対する処理
          </li>
          <!--<li>Integration with WebRTC
            <ul>
              <li>Processing audio received from a remote peer using a
              <a class="idlType" href="#idl-def-MediaStreamAudioSourceNode"><code>MediaStreamAudioSourceNode</code></a> and [<cite><a href="#bib-webrtc" class="bibref">webrtc</a></cite>].
              </li>
              <li>Sending a generated or processed audio stream to a remote
              peer using a <a class="idlType" href="#idl-def-MediaStreamAudioDestinationNode"><code>MediaStreamAudioDestinationNode</code></a>
              and [<cite><a href="#bib-webrtc" class="bibref">webrtc</a></cite>].
              </li>
            </ul>
          </li>-->
          <li>WebRTC との統合
            <ul>
              <li><a class="idlType" href="#idl-def-MediaStreamAudioSourceNode"><code>MediaStreamAudioSourceNode</code></a>と[<cite><a href="#bib-webrtc" class="bibref">webrtc</a></cite>]を使ってリモート・ピアから受け取ったオーディオの処理
              </li>
              <li>生成または加工されたオーディオストリームの<a class="idlType" href="#idl-def-MediaStreamAudioDestinationNode"><code>MediaStreamAudioDestinationNode</code></a>
              と [<cite><a href="#bib-webrtc" class="bibref">webrtc</a></cite>]を使ったリモート・ピアへの送信
              </li>
            </ul>
          </li>
          <!--<li>Audio stream synthesis and processing <a href="#AudioWorker">directly in JavaScript</a>.
          </li>-->
          <li><a href="#AudioWorker">JavaScriptでの直接的な</a>オーディオストリームの合成および加工
          </li>
          <!--<li>
            <a href="#Spatialization">Spatialized audio</a> supporting a wide
            range of 3D games and immersive environments:
            <ul>
              <li>Panning models: equalpower, HRTF, pass-through
              </li>
              <li>Distance Attenuation
              </li>
              <li>Sound Cones
              </li>
              <li>Obstruction / Occlusion
              </li>
              <li>Doppler Shift
              </li>
              <li>Source / Listener based
              </li>
            </ul>
          </li>-->
          <li>3D ゲームや没入環境を幅広くサポートする<a href="#Spatialization">空間音響</a>:
            <ul>
              <li>パンニングモデル: 等価パワー, HRTF, パススルー
              </li>
              <li>距離減衰
              </li>
              <li>サウンドコーン
              </li>
              <li>障害物 / 遮蔽物
              </li>
              <li>ドップラー効果
              </li>
              <li>ソース / リスナー
              </li>
            </ul>
          </li>
          <!--<li>A <a href="convolution.html">convolution engine</a> for a wide range
          of linear effects, especially very high-quality room effects. Here
          are some examples of possible effects:
            <ul>
              <li>Small / large room
              </li>
              <li>Cathedral
              </li>
              <li>Concert hall
              </li>
              <li>Cave
              </li>
              <li>Tunnel
              </li>
              <li>Hallway
              </li>
              <li>Forest
              </li>
              <li>Amphitheater
              </li>
              <li>Sound of a distant room through a doorway
              </li>
              <li>Extreme filters
              </li>
              <li>Strange backwards effects
              </li>
              <li>Extreme comb filter effects
              </li>
            </ul>
          </li>-->
          <li>広範囲の線形エフェクト、特に非常に高い品質のルーム・エフェクトに使用できる<a href="convolution.html">コンボリューションエンジン</a>。 これによって可能なエフェクトの例を以下に示します:
            <ul>
              <li>小さい / 大きい部屋
              </li>
              <li>大聖堂
              </li>
              <li>コンサートホール
              </li>
              <li>洞窟
              </li>
              <li>トンネル
              </li>
              <li>廊下
              </li>
              <li>森
              </li>
              <li>野外劇場
              </li>
              <li>出入り口を経由した遠くの部屋
              </li>
              <li>極端なフィルタ
              </li>
              <li>風変りな巻き戻し効果
              </li>
              <li>極端なコムフィルタ効果
              </li>
            </ul>
          </li>
          <!--<li>Dynamics compression for overall control and sweetening of the
          mix
        </li>-->
          <li>ミックス全体の制御やスウィートニング<span class="annotate">(訳注:ビデオに効果音などをつけるMA作業)</span>  のためのダイナミック・コンプレッション
          </li>
          <!--<li>Efficient <a href="#the-analysernode-interface">real-time
          time-domain and frequency analysis / music visualizer support</a>
        </li>-->
          <li>効率的な<a href="#the-analysernode-interface">リアルタイムの時間領域および周波数領域解析 / ミュージックビジュアライザーのサポート</a>
          </li>
          <!--<li>Efficient biquad filters for lowpass, highpass, and other common
          filters.
        </li>-->
          <li>効率的な双2次フィルタによる、ローパス、ハイパス、その他一般的なフィルタ
          </li>
          <!--<li>A Waveshaping effect for distortion and other non-linear effects
          </li>-->
          <li>ディストーションやその他の非線形エフェクトのためのウェーブシェイピング・エフェクト
          </li>
          <!--<li>Oscillators
          </li>-->
          <li>オシレータ</li>
        </ul>
        <section property="bibo:hasPart" resource="#ModularRouting" typeof="bibo:Chapter">
          <h4 resource="#ModularRouting" id="ModularRouting"><span property="xhv:role" resource="xhv:heading"><span class="secno">0.1.1 </span>
            モジュラールーティング <button onclick="OpenOriginal('ModularRouting')">原文</button>
          </span></h4>
          <!--<p>
            Modular routing allows arbitrary connections between different
            <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> objects. Each node can have
            <dfn id="dfn-inputs" data-dfn-type="dfn">inputs</dfn> and/or <dfn id="dfn-outputs" data-dfn-type="dfn">outputs</dfn>. A <dfn id="dfn-source-node" data-dfn-type="dfn">source
            node</dfn> has no inputs and a single output. A <dfn id="dfn-destination-node" data-dfn-type="dfn">destination
            node</dfn> has one input and no outputs, the most common example
            being <a href="#AudioDestinationNode"><code>AudioDestinationNode</code></a> the
            final destination to the audio hardware. Other nodes such as
            filters can be placed between the source and destination nodes. The
            developer doesn't have to worry about low-level stream format
            details when two objects are connected together; <a href="#channel-up-mixing-and-down-mixing">the right thing just
            happens</a>. For example, if a mono audio stream is connected to a
            stereo input it should just mix to left and right channels <a href="#channel-up-mixing-and-down-mixing">appropriately</a>.
          </p>-->
          <p>モジュラールーティングによって異なる <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> オブジェクト同士を任意に接続できます。 それぞれのノードは<dfn id="dfn-inputs" data-dfn-type="dfn">入力</dfn>および<dfn id="dfn-outputs" data-dfn-type="dfn">出力</dfn>を持っています。
          <dfn id="dfn-source-node" data-dfn-type="dfn">ソースノード</dfn>は入力は持たず、1つの出力を持ちます。<dfn id="dfn-destination-node" data-dfn-type="dfn"> デスティネーションノード</dfn>は1つの入力を持ち、出力は持っていません。この最も一般的な例が最終的なオーディオハードウェアに繋がるAudioDestinationNodeです。 フィルタなどの他のノードはソースとデスティネーションの間に配置することができます。 2つのオブジェクトが互いに接続している場合、低レベルのストリーム形式の詳細について開発者が煩わされる事なく、<a href="#channel-up-mixing-and-down-mixing">適正な処理が行われます</a>。 例えばもしモノラルの音声ストリームがステレオの入力に接続されていても、左右のチャンネルに<a href="#channel-up-mixing-and-down-mixing">適正</a>にミックスされます。
          </p>
          <!--<p>
            In the simplest case, a single source can be routed directly to the
            output. All routing occurs within an <a href="#AudioContext"><code>AudioContext</code></a> containing a single
            <a href="#AudioDestinationNode"><code>AudioDestinationNode</code></a>:
          </p>-->
          <p>最も単純な例は、1つの音声ソースを出力に直接接続したものです。 すべての接続は単一の<a href="#AudioDestinationNode"><code>AudioDestinationNode</code></a>を持つ<a href="#AudioContext"><code>AudioContext</code></a>内部で行われます:
          </p>
          <figure id="fig-a-simple-example-of-modular-routing.x">
            <img alt="modular routing" src="images/modular-routing1.png">
            <figcaption>図 <span class="figno">1</span> <span class="fig-title">
              モジュラールーティングの単純な例
            </span></figcaption>
          </figure>
          <!--<p>
            Illustrating this simple routing, here's a simple example playing a
            single sound:
          </p>-->
          <p>この単純なルーティングを図示します。この例では単一の音を再生しています:
          </p>
          <div class="example"><div class="example-title"><span>例 1</span></div><pre style="" class="highlight example prettyprint prettyprinted"><span class="kwd">var</span><span class="pln"> context </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AudioContext</span><span class="pun">();</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> playSound</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> source </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createBufferSource</span><span class="pun">();</span><span class="pln">
    source</span><span class="pun">.</span><span class="pln">buffer </span><span class="pun">=</span><span class="pln"> dogBarkingBuffer</span><span class="pun">;</span><span class="pln">
    source</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">context</span><span class="pun">.</span><span class="pln">destination</span><span class="pun">);</span><span class="pln">
    source</span><span class="pun">.</span><span class="pln">start</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></pre></div>
          <!--<p>
            Here's a more complex example with three sources and a convolution
            reverb send with a dynamics compressor at the final output stage:
          </p>-->
          <p>これはもっと複雑な例で、3つのソースとコンボリューションリバーブが最終出力段にあるダイナミックコンプレッサーを介して送られます:
          </p>
          <figure id="fig-a-more-complex-example-of-modular-routing.x">
            <img alt="modular routing2" src="images/modular-routing2.png">
            <figcaption>図 <span class="figno">2</span> <span class="fig-title">
              モジュラールーティングのより複雑な例
            </span></figcaption>
          </figure>
          <div class="example"><div class="example-title"><span>例 2</span></div><pre style="" class="highlight example prettyprint prettyprinted"><span class="kwd">var</span><span class="pln"> context </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> compressor </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> reverb </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">var</span><span class="pln"> source1 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> source2 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> source3 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">var</span><span class="pln"> lowpassFilter </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> waveShaper </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> panner </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">var</span><span class="pln"> dry1 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> dry2 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> dry3 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">var</span><span class="pln"> wet1 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> wet2 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> wet3 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">var</span><span class="pln"> masterDry </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> masterWet </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> setupRoutingGraph </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    context </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AudioContext</span><span class="pun">();</span><span class="pln">

    </span><span class="com">// Create the effects nodes.</span><span class="pln">
    lowpassFilter </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createBiquadFilter</span><span class="pun">();</span><span class="pln">
    waveShaper </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createWaveShaper</span><span class="pun">();</span><span class="pln">
    panner </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createPanner</span><span class="pun">();</span><span class="pln">
    compressor </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createDynamicsCompressor</span><span class="pun">();</span><span class="pln">
    reverb </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createConvolver</span><span class="pun">();</span><span class="pln">

    </span><span class="com">// Create master wet and dry.</span><span class="pln">
    masterDry </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">
    masterWet </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">

    </span><span class="com">// Connect final compressor to final destination.</span><span class="pln">
    compressor</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">context</span><span class="pun">.</span><span class="pln">destination</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// Connect master dry and wet to compressor.</span><span class="pln">
    masterDry</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">compressor</span><span class="pun">);</span><span class="pln">
    masterWet</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">compressor</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// Connect reverb to master wet.</span><span class="pln">
    reverb</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">masterWet</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// Create a few sources.</span><span class="pln">
    source1 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createBufferSource</span><span class="pun">();</span><span class="pln">
    source2 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createBufferSource</span><span class="pun">();</span><span class="pln">
    source3 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createOscillator</span><span class="pun">();</span><span class="pln">

    source1</span><span class="pun">.</span><span class="pln">buffer </span><span class="pun">=</span><span class="pln"> manTalkingBuffer</span><span class="pun">;</span><span class="pln">
    source2</span><span class="pun">.</span><span class="pln">buffer </span><span class="pun">=</span><span class="pln"> footstepsBuffer</span><span class="pun">;</span><span class="pln">
    source3</span><span class="pun">.</span><span class="pln">frequency</span><span class="pun">.</span><span class="pln">value </span><span class="pun">=</span><span class="pln"> </span><span class="lit">440</span><span class="pun">;</span><span class="pln">

    </span><span class="com">// Connect source1</span><span class="pln">
    dry1 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">
    wet1 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">
    source1</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">lowpassFilter</span><span class="pun">);</span><span class="pln">
    lowpassFilter</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">dry1</span><span class="pun">);</span><span class="pln">
    lowpassFilter</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">wet1</span><span class="pun">);</span><span class="pln">
    dry1</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">masterDry</span><span class="pun">);</span><span class="pln">
    wet1</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">reverb</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// Connect source2</span><span class="pln">
    dry2 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">
    wet2 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">
    source2</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">waveShaper</span><span class="pun">);</span><span class="pln">
    waveShaper</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">dry2</span><span class="pun">);</span><span class="pln">
    waveShaper</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">wet2</span><span class="pun">);</span><span class="pln">
    dry2</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">masterDry</span><span class="pun">);</span><span class="pln">
    wet2</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">reverb</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// Connect source3</span><span class="pln">
    dry3 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">
    wet3 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">
    source3</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">panner</span><span class="pun">);</span><span class="pln">
    panner</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">dry3</span><span class="pun">);</span><span class="pln">
    panner</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">wet3</span><span class="pun">);</span><span class="pln">
    dry3</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">masterDry</span><span class="pun">);</span><span class="pln">
    wet3</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">reverb</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// Start the sources now.</span><span class="pln">
    source1</span><span class="pun">.</span><span class="pln">start</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
    source2</span><span class="pun">.</span><span class="pln">start</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
    source3</span><span class="pun">.</span><span class="pln">start</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></pre></div>
          <!--<p>
            Modular routing also permits the output of
            <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s to be routed to an
            <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> parameter that controls the behavior
            of a different <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>. In this scenario, the
            output of a node can act as a modulation signal rather than an
            input signal.
          </p>-->
          <p>
            モジュラールーティングはまた <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の出力を
            別の <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の動きを制御する <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> パラメータに接続する事もできます。この場合は、ノードからの出力は
            入力信号ではなくモジュレーション信号として働きます。
          </p>
          <figure id="fig-modular-routing-illustrating-one-oscillator-modulating-the-frequency-of-another.x">
            <img alt="modular routing3" src="images/modular-routing3.png">
            <figcaption>図 <span class="figno">3</span> <span class="fig-title">
              モジュラールーティングによってオシレータの出力で別のオシレータの周波数を変調する
            </span></figcaption>
          </figure>
          <div class="example"><div class="example-title"><span>例 3</span></div><pre style="" class="highlight example prettyprint prettyprinted"><span class="kwd">function</span><span class="pln"> setupRoutingGraph</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> context </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AudioContext</span><span class="pun">();</span><span class="pln">

  </span><span class="com">// Create the low frequency oscillator that supplies the modulation signal</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> lfo </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createOscillator</span><span class="pun">();</span><span class="pln">
  lfo</span><span class="pun">.</span><span class="pln">frequency</span><span class="pun">.</span><span class="pln">value </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1.0</span><span class="pun">;</span><span class="pln">

  </span><span class="com">// Create the high frequency oscillator to be modulated</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> hfo </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createOscillator</span><span class="pun">();</span><span class="pln">
  hfo</span><span class="pun">.</span><span class="pln">frequency</span><span class="pun">.</span><span class="pln">value </span><span class="pun">=</span><span class="pln"> </span><span class="lit">440.0</span><span class="pun">;</span><span class="pln">

  </span><span class="com">// Create a gain node whose gain determines the amplitude of the modulation signal</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> modulationGain </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">
  modulationGain</span><span class="pun">.</span><span class="pln">gain</span><span class="pun">.</span><span class="pln">value </span><span class="pun">=</span><span class="pln"> </span><span class="lit">50</span><span class="pun">;</span><span class="pln">

  </span><span class="com">// Configure the graph and start the oscillators</span><span class="pln">
  lfo</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">modulationGain</span><span class="pun">);</span><span class="pln">
  modulationGain</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">hfo</span><span class="pun">.</span><span class="pln">detune</span><span class="pun">);</span><span class="pln">
  hfo</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">context</span><span class="pun">.</span><span class="pln">destination</span><span class="pun">);</span><span class="pln">
  hfo</span><span class="pun">.</span><span class="pln">start</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
  lfo</span><span class="pun">.</span><span class="pln">start</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></pre></div>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#APIOverview" typeof="bibo:Chapter">
        <h3 resource="#APIOverview" id="APIOverview"><span property="xhv:role" resource="xhv:heading"><span class="secno">0.2 </span>
          <abbr title="Application Programming Interface">API</abbr> の概要 <button onclick="OpenOriginal('APIOverview')">原文</button>
        </span></h3>
        <!--<p>
          The interfaces defined are:
        </p>-->
        <p>
          定義されているインターフェースは次の通りです:
        </p>
        <ul>
          <!--<li>An <a class="dfnref" href="#AudioContext">AudioContext</a>
          interface, which contains an audio signal graph representing
          connections betweens <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s.
        </li>-->
          <li><a class="dfnref" href="#AudioContext">AudioContext</a>インターフェースは、<a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>間の接続を表すオーディオ信号グラフを保持します。
          </li>
          <!--<li>An <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> interface, which represents
          audio sources, audio outputs, and intermediate processing modules.
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s can be dynamically connected together
          in a <a href="#ModularRouting">modular fashion</a>.
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s exist in the context of an
          <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>
        </li>-->
          <li><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>インターフェースは、オーディオのソース、オーディオの出力、その間にある処理モジュールを表します。<a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>は<a href="#ModularRouting">modular fashion</a>で動的に互いに接続されます。 <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>は<a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>のコンテキスト内に存在します。
          </li>
          <!--<li>An <a class="idlType" href="#idl-def-AudioDestinationNode"><code>AudioDestinationNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> subclass representing the final
          destination for all rendered audio.
        </li>-->
          <li><a class="idlType" href="#idl-def-AudioDestinationNode"><code>AudioDestinationNode</code></a> インターフェースは、 <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> のサブクラスでオーディオの最終的な出力地点を表します。
          </li>
          <!--<li>An <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a> interface, for working with
          memory-resident audio assets. These can represent one-shot sounds, or
          longer audio clips.
        </li>-->
          <li><a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>インターフェースは、 メモリ内に保持されるオーディオのリソースで使用されます。これらはワンショットの音、またはもっと長いオーディオクリップを表します。
          </li>
          <!--<li>An <a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> which generates audio from an
          AudioBuffer.
        </li>-->
          <li><a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a> インターフェースは、 AudioBuffer からの音を発生する <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。
          </li>
          <!--<li>A <a class="idlType" href="#idl-def-MediaElementAudioSourceNode"><code>MediaElementAudioSourceNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> which is the audio source from an
          <code>audio</code>, <code>video</code>, or other media element.
        </li>-->
          <li><a class="idlType" href="#idl-def-MediaElementAudioSourceNode"><code>MediaElementAudioSourceNode</code></a> インターフェースは、 audio、video その他のメディア要素を音源とする <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。
          </li>
          <!--<li>A <a class="idlType" href="#idl-def-MediaStreamAudioSourceNode"><code>MediaStreamAudioSourceNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> which is the audio source from a
          MediaStream such as live audio input, or from a remote peer.
        </li>-->
          <li><a class="idlType" href="#idl-def-MediaStreamAudioSourceNode"><code>MediaStreamAudioSourceNode</code></a> インターフェースは、 ライブオーディオ入力やリモート・ピアから受け取ったような MediaStream を音源とする <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。
          </li>
          <!--<li>A <a class="idlType" href="#idl-def-MediaStreamAudioDestinationNode"><code>MediaStreamAudioDestinationNode</code></a> interface,
          an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> which is the audio destination to a
          MediaStream sent to a remote peer.
        </li>-->
          <li><li>A <a class="idlType" href="#idl-def-MediaStreamAudioDestinationNode"><code>MediaStreamAudioDestinationNode</code></a> インターフェースは、 リモート・ピアに送信する MediaStream へ出力する <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。
          </li>
          <!--<li>An <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a> interface representing a
          factory for creating custom nodes that can process audio directly in
          JavaScript.
        </li>-->
          <li><a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a>インターフェースは、JavaScriptでオーディオを直接処理するカスタムノードを作成するファクトリを表します。
          </li>
          <!--<li class="orig">An <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> representing a node processed in an
          AudioWorker.
        </li>-->
          <li><a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> インターフェースは、 AudioWorker で処理される <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> を表します。
          </li>
          <!--<li class="orig">An <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> interface, the
          context in which AudioWorker processing scripts run.
        </li>-->
          <li><a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> インターフェースは、 AudioWorker の処理スクリプトが実行されるコンテキストです。
          </li>
          <!--<li class="orig">An <a class="idlType" href="#idl-def-AudioWorkerNodeProcessor"><code>AudioWorkerNodeProcessor</code></a> interface,
          representing a single node instance inside an audio worker.
        </li>-->
          <li><a class="idlType" href="#idl-def-AudioWorkerNodeProcessor"><code>AudioWorkerNodeProcessor</code></a> インターフェースは、 AudioWorker 内の1つのノードのインスタンスを表します。
          </li>
          <!--<li class="orig">An <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> interface, for controlling an
          individual aspect of an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>'s functioning,
          such as volume.
        </li>-->
          <li><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> インターフェースは、 <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の個別の機能、例えば音量などを制御します。
          </li>
          <!--<li class="orig">An <a class="idlType" href="#idl-def-GainNode"><code>GainNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> for explicit gain control. Because
          inputs to <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s support multiple connections
          (as a unity-gain summing junction), mixers can be <a href="#mixer-gain-structure">easily built</a> with GainNodes.
        </li>-->
          <li><a class="idlType" href="#idl-def-GainNode"><code>GainNode</code></a> インターフェースは、明示的なゲイン制御を行う <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。 <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> への入力は (ユニティ・ゲイン<span class="annonate">(訳注:ゲインが1である事)</span>の加算による) 複数の接続をサポートしているため、 GainNode を使う事でミキサーが<a href="#mixer-gain-structure">簡単に構成</a>できます。
          </li>
          <!--<li class="orig">A <a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> for common low-order filters such as:
            <ul>
              <li>Low Pass
              </li>
              <li>High Pass
              </li>
              <li>Band Pass
              </li>
              <li>Low Shelf
              </li>
              <li>High Shelf
              </li>
              <li>Peaking
              </li>
              <li>Notch
              </li>
              <li>Allpass
              </li>
            </ul>
          </li>-->
          <li><a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a> インターフェースは、 次のような一般的な低次のフィルタの <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です:
            <ul>
              <li>ローパス
              </li>
              <li>ハイパス
              </li>
              <li>バンドパス
              </li>
              <li>ローシェルフ
              </li>
              <li>ハイシェルフ
              </li>
              <li>ピーキング
              </li>
              <li>ノッチ
              </li>
              <li>オールパス
              </li>
            </ul>
          </li>
          <!--<li class="orig">A <a class="idlType" href="#idl-def-IIRFilterNode"><code>IIRFilterNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> for a general IIR filter.
        </li>-->
          <li><a class="idlType" href="#idl-def-IIRFilterNode"><code>IIRFilterNode</code></a> インターフェースは、一般的な IIR フィルターの <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。
          </li>
          <!--<li class="orig">A <a class="idlType" href="#idl-def-DelayNode"><code>DelayNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> which applies a dynamically adjustable
          variable delay.
        </li>-->
          <li><a class="idlType" href="#idl-def-DelayNode"><code>DelayNode</code></a> インターフェースは、動的に調整可能な遅延を加える <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。
          </li>
          <!--<li class="orig">A <a class="idlType" href="#idl-def-SpatialPannerNode"><code>SpatialPannerNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> for positioning audio in 3D space.
        </li>-->
          <li><a class="idlType" href="#idl-def-SpatialPannerNode"><code>SpatialPannerNode</code></a> インターフェースは、3次元空間内で定位を行う <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。
          </li>
          <!--<li class="orig">A <a class="idlType" href="#idl-def-SpatialListener"><code>SpatialListener</code></a> interface, which works with
          a <a class="idlType" href="#idl-def-SpatialPannerNode"><code>SpatialPannerNode</code></a> for spatialization.
        </li>-->
          <li><a class="idlType" href="#idl-def-SpatialListener"><code>SpatialListener</code></a> インターフェースは、 <a class="idlType" href="#idl-def-SpatialPannerNode"><code>SpatialPannerNode</code></a> と共に空間定位のために使用されます。
          </li>
          <!--<li class="orig">A <a class="idlType" href="#idl-def-StereoPannerNode"><code>StereoPannerNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> for equal-power positioning of audio
          input in a stereo stream.
        </li>-->
          <li><a class="idlType" href="#idl-def-StereoPannerNode"><code>StereoPannerNode</code></a> インターフェースは、ステレオストリームで equal-power 方式の定位を行う <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。
          </li>
          <!--<li class="orig">A <a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> for applying a <a href="convolution.html">
            real-time linear effect</a> (such as the sound of a concert hall).
          </li>-->
          <li><a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a> インターフェースは、 (例えばコンサートホールでの残響効果のような)<a href="convolution.html">リアルタイム線形エフェクト</a>を加える <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。
          </li>
          <!--<li class="orig">A <a class="idlType" href="#idl-def-AnalyserNode"><code>AnalyserNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> for use with music visualizers, or
          other visualization applications.
        </li>-->
          <li><a class="idlType" href="#idl-def-AnalyserNode"><code>AnalyserNode</code></a> インターフェースは、ミュージックビジュアライザーやその他の視覚化アプリケーションで使用される <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。
          </li>
          <!--<li class="orig">A <a class="idlType" href="#idl-def-ChannelSplitterNode"><code>ChannelSplitterNode</code></a> interface, an <a data-link-type="dfn" class="internalDFN" href="#dfn-audionode"><code>
            AudioNode</code></a> for accessing the individual channels of an
            audio stream in the routing graph.
          </li>-->
          <li><a class="idlType" href="#idl-def-ChannelSplitterNode"><code>ChannelSplitterNode</code></a> インターフェースは、 ルーティンググラフ内のオーディオストリームの個別のチャンネルにアクセスするために使用される <a data-link-type="dfn" class="internalDFN" href="#dfn-audionode"><code>
            AudioNode</code></a> です。
          </li>
          <!--<li class="orig">A <a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> for combining channels from multiple
          audio streams into a single audio stream.
        </li>-->
          <li><a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a> インターフェースは、 複数のオーディオストリームから1つのオーディオストリームにチャンネルの結合を行う <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。
          </li>
          <!--<li class="orig">A <a class="idlType" href="#idl-def-DynamicsCompressorNode"><code>DynamicsCompressorNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> for dynamics compression.
        </li>-->
          <li><a class="idlType" href="#idl-def-DynamicsCompressorNode"><code>DynamicsCompressorNode</code></a> インターフェースは、 ダイナミクス・コンプレッションのための <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。
          </li>
          <!--<li class="orig">A <a class="idlType" href="#idl-def-WaveShaperNode"><code>WaveShaperNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> which applies a non-linear waveshaping
          effect for distortion and other more subtle warming effects.
        </li>-->
          <li><a class="idlType" href="#idl-def-WaveShaperNode"><code>WaveShaperNode</code></a> インターフェースは、 例えばディストーションや微妙なウォーミング効果<span class="annotate">(訳注:いわゆるサチュレーション効果の事)</span>など、非線形のウェーブシェイピング・エフェクトを加えるための <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。
          </li>
          <!--<li class="orig">A <a class="idlType" href="#idl-def-OscillatorNode"><code>OscillatorNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> for generating a periodic waveform.
        </li>-->
          <li><a class="idlType" href="#idl-def-OscillatorNode"><code>OscillatorNode</code></a> インターフェースは、周期的な波形を発生する <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。
          </li>
        </ul>
        <!--<p class="orig">
          There are also several features that have been deprecated from the
          Web Audio <abbr title="Application Programming Interface">API</abbr> but not yet removed, pending implementation experience
          of their replacements:
        </p>-->
        <p>また非推奨ですがまだ削除されておらず、置き換えの実装が予定されているいくつかの Web Audio <abbr title="Application Programming Interface">API</abbr> があります。
        </p>
        <ul>
          <!--<li class="orig">A <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a> interface, an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> for spatializing / positioning audio in
          3D space. This has been replaced by
          <a class="idlType" href="#idl-def-SpatialPannerNode"><code>SpatialPannerNode</code></a>, and
          <a class="idlType" href="#idl-def-StereoPannerNode"><code>StereoPannerNode</code></a> for simpler scenarios.
        </li>-->
          <li> <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a> インターフェースは、3D 空間での空間音響/空間定位のための <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。これは <a class="idlType" href="#idl-def-SpatialPannerNode"><code>SpatialPannerNode</code></a> および 簡単なシナリオのためには<a class="idlType" href="#idl-def-StereoPannerNode"><code>StereoPannerNode</code></a> で置き換えられます。
          </li>
          <!--<li class="orig">An <a class="idlType" href="#idl-def-AudioListener"><code>AudioListener</code></a> interface, which works with
          a <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a> for spatialization.
        </li>-->
          <li><a class="idlType" href="#idl-def-AudioListener"><code>AudioListener</code></a> インターフェースは、 <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a> と共に空間音響のために使用されます。
          </li>
          <!--<li class="orig">A <a class="idlType" href="#idl-def-ScriptProcessorNode"><code>ScriptProcessorNode</code></a> interface, an <a data-link-type="dfn" class="internalDFN" href="#dfn-audionode"><code>
            AudioNode</code></a> for generating or processing audio directly in
            JavaScript.
          </li>-->
          <li><a class="idlType" href="#idl-def-ScriptProcessorNode"><code>ScriptProcessorNode</code></a>インターフェースは、JavaScriptでオーディオを直接生成または処理するための<a data-link-type="dfn" class="internalDFN" href="#dfn-audionode"><code>
            AudioNode</code></a>です。
          </li>
          <!--<li class="orig">An <a class="idlType" href="#idl-def-AudioProcessingEvent"><code>AudioProcessingEvent</code></a> interface, which is
          an event type used with <a class="idlType" href="#idl-def-ScriptProcessorNode"><code>ScriptProcessorNode</code></a>
          objects.
        </li>-->
          <li><a class="idlType" href="#idl-def-AudioProcessingEvent"><code>AudioProcessingEvent</code></a> インターフェースは、 <a class="idlType" href="#idl-def-ScriptProcessorNode"><code>ScriptProcessorNode</code></a> オブジェクトと共に用いられるイベントタイプです。
          </li>
        </ul>
      </section>
    </section>
    <section property="bibo:hasPart" resource="#conformance" typeof="bibo:Chapter" id="conformance"><!--OddPage--><h2 resource="#h-conformance" id="h-conformance"><span property="xhv:role" resource="xhv:heading"><span class="secno">1. </span>準拠</span> <button onclick="OpenOriginal('h-conformance')">原文</button></h2>
<!--<p class="orig">
  As well as sections marked as non-normative, all authoring guidelines, diagrams, examples,
  and notes in this specification are non-normative. Everything else in this specification is
  normative.
</p>-->
<p>この仕様内で参考情報と書かれているセクション、オーサリングガイドライン、図、例、注は非基準要件です。この仕様内のそれ以外の全ては基準要件となります。
</p>
<!--<p class="orig" id="respecRFC2119">The key words <em class="rfc2119" title="MUST">MUST</em>, <em class="rfc2119" title="REQUIRED">REQUIRED</em>, and <em class="rfc2119" title="SHALL">SHALL</em> are
  to be interpreted as described in [<cite><a href="#bib-RFC2119" class="bibref">RFC2119</a></cite>].
</p>-->
<p>キーワード<em class="rfc2119" title="MUST">MUST</em>、 <em class="rfc2119" title="REQUIRED">REQUIRED</em>、<em class="rfc2119" title="SHALL">SHALL</em> は [<cite><a href="#bib-RFC2119" class="bibref">RFC2119</a></cite>] に記述されているように解釈されます。
</p>
      <!--<p class="orig">
        The following conformance classes are defined by this specification:
      </p>-->
      <p>次の準拠クラスがこの仕様によって定義されています:
      </p>
      <dl>
        <!--<dt class="orig">
          <dfn data-dfn-type="dfn" id="dfn-conforming-implementation">conforming
          implementation</dfn>
        </dt>-->
        <dt>
          <dfn data-dfn-type="dfn" id="dfn-conforming-implementation">準拠した実装</dfn>
        </dt>
        <dd>
          <!--<p class="orig">
            A user agent is considered to be a <a class="dfnref" href="#dfn-conforming-implementation">conforming implementation</a> if
            it satisfies all of the <em title="MUST" class="rfc2119">MUST</em>-, <em title="REQUIRED" class="rfc2119">REQUIRED</em>- and <em title="SHALL" class="rfc2119">SHALL</em>-level criteria
            in this specification that apply to implementations.
          </p>-->
          <p>この仕様の全ての<em title="MUST" class="rfc2119">MUST</em>-、 <em title="REQUIRED" class="rfc2119">REQUIRED</em>-、 <em title="SHALL" class="rfc2119">SHALL</em> レベルの基準を満足する実装がされているユーザーエージェントが、<a class="dfnref" href="#dfn-conforming-implementation">準拠した実装</a>と判断されます。
          </p>
        </dd>
      </dl>
      <!--<p class="orig">
        User agents that use ECMAScript to implement the APIs defined in this
        specification must implement them in a manner consistent with the
        ECMAScript Bindings defined in the Web IDL specification [<cite><a href="#bib-WEBIDL" class="bibref">WEBIDL</a></cite>] as
        this specification uses that specification and terminology.
      </p>-->
      <p>この仕様で定められたAPIの実装にECMAScriptを使用するユーザーエージェントは、Web IDL仕様 [<cite><a href="#bib-WEBIDL" class="bibref">WEBIDL</a></cite>]で定義されるECMAScriptバインディングの仕様と用語がこの仕様での使用と矛盾しない方法で実装しなくてはなりません。
      </p>
    </section>
    <section property="bibo:hasPart" resource="#audioapi" typeof="bibo:Chapter" id="audioapi">
      <!--OddPage--><h2 resource="#API" id="API"><span property="xhv:role" resource="xhv:heading"><span class="secno">2. </span>
        オーディオ <abbr title="Application Programming Interface">API</abbr>
      </span></h2>
      <section property="bibo:hasPart" resource="#BaseAudioContext" typeof="bibo:Chapter">
        <h3 resource="#BaseAudioContext" id="BaseAudioContext"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.1 </span>
          BaseAudioContext インターフェース <button onclick="OpenOriginal('BaseAudioContext')">原文</button>
        </span></h3>
        <!--<p class="orig">
          This interface represents a set of <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>
          objects and their connections. It allows for arbitrary routing of
          signals to an <a class="idlType" href="#idl-def-AudioDestinationNode"><code>AudioDestinationNode</code></a>. Nodes are
          created from the context and are then <a href="#ModularRouting">connected</a> together.
        </p>-->
        <p>
          このインターフェースは<a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>オブジェクトのセットを表します。それは信号を<a class="idlType" href="#idl-def-AudioDestinationNode"><code>AudioDestinationNode</code></a>に任意のルーティングする事を可能にします。
          ノードはコンテキストから作成され、お互いに<a href="#ModularRouting">接続</a>されます。
        </p>
        <!--<p class="orig">
          <a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a> is not instantiated directly,
          but is instead extended by the concrete interfaces
          <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> (for real-time rendering) and
          <a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a> (for offline rendering).
        </p>-->
        <p><a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a>は直接的にはインスタンス化されず、代わりに<a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>(リアルタイムレンダリングの場合)と<a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a>(オフラインレンダリングの場合)が拡張された具体的なインターフェースとなっています。
        </p>
        <pre class="idl"><span class="idlEnum" id="idl-def-AudioContextState">enum <span class="idlEnumID">AudioContextState</span> {
    "<a href="#idl-def-AudioContextState.suspended" class="idlEnumItem">suspended</a>",
    "<a href="#idl-def-AudioContextState.running" class="idlEnumItem">running</a>",
    "<a href="#idl-def-AudioContextState.closed" class="idlEnumItem">closed</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">列挙値の説明</th></tr><tr><td><code id="idl-def-AudioContextState.suspended">suspended</code></td><td>
          このコンテキストは現在中断(コンテキストの時間は進まず、オーディオハードウェアはパワーダウン/解放)しています。
          </td></tr><tr><td><code id="idl-def-AudioContextState.running">running</code></td><td>
            オーディオは処理状態にあります。
          </td></tr><tr><td><code id="idl-def-AudioContextState.closed">closed</code></td><td>
            このコンテキストは解放され、もうオーディオ処理に使用できません。全てのシステムオーディオリソースは解放されました。
            新しいノードを作成しようとすると InvalidStateError が発生します。(AudioBufferは
            <a href="#widl-BaseAudioContext-createBuffer-AudioBuffer-unsigned-long-numberOfChannels-unsigned-long-length-float-sampleRate">
            createBuffer</a> or <a href="#widl-BaseAudioContext-decodeAudioData-Promise-AudioBuffer--ArrayBuffer-audioData-DecodeSuccessCallback-successCallback-DecodeErrorCallback-errorCallback">
            decodeAudioData</a>を通してまだ作成できるかも知れません)
          </td></tr></tbody></table>
        <pre class="idl"><span class="idlEnum" id="idl-def-AudioContextPlaybackCategory">enum <span class="idlEnumID">AudioContextPlaybackCategory</span> {
    "<a href="#idl-def-AudioContextPlaybackCategory.balanced" class="idlEnumItem">balanced</a>",
    "<a href="#idl-def-AudioContextPlaybackCategory.interactive" class="idlEnumItem">interactive</a>",
    "<a href="#idl-def-AudioContextPlaybackCategory.playback" class="idlEnumItem">playback</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">列挙値の説明</th></tr><tr><td><code id="idl-def-AudioContextPlaybackCategory.balanced">balanced</code></td><td>
            オーディオ出力のレイテンシーと安定性/消費電力のバランスを取ります。
          </td></tr><tr><td><code id="idl-def-AudioContextPlaybackCategory.interactive">interactive</code></td><td>
            オーディオ出力のレイテンシーをグリッジが発生しない最小値にする。これがデフォルトになります。
          </td></tr><tr><td><code id="idl-def-AudioContextPlaybackCategory.playback">playback</code></td><td>
            オーディオ出力のレイテンシーよりも再生の途切れを起こさない事を優先します。消費電力は最も低くなります。
          </td></tr></tbody></table>
        <pre class="idl"><span class="idlInterface" id="idl-def-BaseAudioContext"><span class="idlDictionary" id="idl-def-AudioContextOptions">dictionary <span class="idlDictionaryID">AudioContextOptions</span> {
<span class="idlMember">             <span class="idlMemberType"><a class="idlType" href="#idl-def-AudioContextPlaybackCategory"><code>AudioContextPlaybackCategory</code></a></span> <span class="idlMemberName"><a href="#widl-AudioContextOptions-playbackCategory">playbackCategory</a></span> = <span class="idlMemberValue">"interactive"</span>;</span>
};</span><br><br><span class="idlCallback" id="idl-def-DecodeErrorCallback">callback <span class="idlCallbackID">DecodeErrorCallback</span> = <span class="idlCallbackType">void</span> (<span class="idlParam"><span class="idlParamType">DOMException</span> <span class="idlParamName">error</span></span>);</span><br><br><span class="idlCallback" id="idl-def-DecodeSuccessCallback">callback <span class="idlCallbackID">DecodeSuccessCallback</span> = <span class="idlCallbackType">void</span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a></span> <span class="idlParamName">decodedData</span></span>);</span><br><br>[<span class="extAttr">Constructor(optional AudioContextOptions contextOptions)</span>]
interface <span class="idlInterfaceID">BaseAudioContext</span> : <span class="idlSuperclass">EventTarget</span> {
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioDestinationNode"><code>AudioDestinationNode</code></a></span> <span class="idlAttrName"><a href="#widl-BaseAudioContext-destination">destination</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">float</span>                <span class="idlAttrName"><a href="#widl-BaseAudioContext-sampleRate">sampleRate</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">double</span>               <span class="idlAttrName"><a href="#widl-BaseAudioContext-currentTime">currentTime</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioListener"><code>AudioListener</code></a></span>        <span class="idlAttrName"><a href="#widl-BaseAudioContext-listener">listener</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioContextState"><code>AudioContextState</code></a></span>    <span class="idlAttrName"><a href="#widl-BaseAudioContext-state">state</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType">Promise&lt;void&gt;</span>          <span class="idlMethName"><a href="#widl-BaseAudioContext-suspend-Promise-void">suspend</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType">Promise&lt;void&gt;</span>          <span class="idlMethName"><a href="#widl-BaseAudioContext-resume-Promise-void">resume</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType">Promise&lt;void&gt;</span>          <span class="idlMethName"><a href="#widl-BaseAudioContext-close-Promise-void">close</a></span> ();</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">EventHandler</span>         <span class="idlAttrName"><a href="#widl-BaseAudioContext-onstatechange">onstatechange</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a></span>            <span class="idlMethName"><a href="#widl-BaseAudioContext-createBuffer-AudioBuffer-unsigned-long-numberOfChannels-unsigned-long-length-float-sampleRate">createBuffer</a></span> (<span class="idlParam"><span class="idlParamType">unsigned long</span> <span class="idlParamName">numberOfChannels</span></span>, <span class="idlParam"><span class="idlParamType">unsigned long</span> <span class="idlParamName">length</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">sampleRate</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">Promise&lt;<a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>&gt;</span>   <span class="idlMethName"><a href="#widl-BaseAudioContext-decodeAudioData-Promise-AudioBuffer--ArrayBuffer-audioData-DecodeSuccessCallback-successCallback-DecodeErrorCallback-errorCallback">decodeAudioData</a></span> (<span class="idlParam"><span class="idlParamType">ArrayBuffer</span> <span class="idlParamName">audioData</span></span>, <span class="idlParam">optional <span class="idlParamType"><a class="idlType" href="#idl-def-DecodeSuccessCallback"><code>DecodeSuccessCallback</code></a></span> <span class="idlParamName">successCallback</span></span>, <span class="idlParam">optional <span class="idlParamType"><a class="idlType" href="#idl-def-DecodeErrorCallback"><code>DecodeErrorCallback</code></a></span> <span class="idlParamName">errorCallback</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a></span>  <span class="idlMethName"><a href="#widl-BaseAudioContext-createBufferSource-AudioBufferSourceNode">createBufferSource</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType">Promise&lt;<a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a>&gt;</span>   <span class="idlMethName"><a href="#widl-BaseAudioContext-createAudioWorker-Promise-AudioWorker--DOMString-scriptURL">createAudioWorker</a></span> (<span class="idlParam"><span class="idlParamType">DOMString</span> <span class="idlParamName">scriptURL</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-ScriptProcessorNode"><code>ScriptProcessorNode</code></a></span>    <span class="idlMethName"><a href="#widl-BaseAudioContext-createScriptProcessor-ScriptProcessorNode-unsigned-long-bufferSize-unsigned-long-numberOfInputChannels-unsigned-long-numberOfOutputChannels">createScriptProcessor</a></span> (<span class="idlParam">optional <span class="idlParamType">unsigned long</span> <span class="idlParamName">bufferSize</span> = <span class="idlDefaultValue">0
              </span></span>, <span class="idlParam">optional <span class="idlParamType">unsigned long</span> <span class="idlParamName">numberOfInputChannels</span> = <span class="idlDefaultValue">2
              </span></span>, <span class="idlParam">optional <span class="idlParamType">unsigned long</span> <span class="idlParamName">numberOfOutputChannels</span> = <span class="idlDefaultValue">2
              </span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-AnalyserNode"><code>AnalyserNode</code></a></span>           <span class="idlMethName"><a href="#widl-BaseAudioContext-createAnalyser-AnalyserNode">createAnalyser</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-GainNode"><code>GainNode</code></a></span>               <span class="idlMethName"><a href="#widl-BaseAudioContext-createGain-GainNode">createGain</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-DelayNode"><code>DelayNode</code></a></span>              <span class="idlMethName"><a href="#widl-BaseAudioContext-createDelay-DelayNode-double-maxDelayTime">createDelay</a></span> (<span class="idlParam">optional <span class="idlParamType">double</span> <span class="idlParamName">maxDelayTime</span> = <span class="idlDefaultValue">1.0
              </span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a></span>       <span class="idlMethName"><a href="#widl-BaseAudioContext-createBiquadFilter-BiquadFilterNode">createBiquadFilter</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-IIRFilterNode"><code>IIRFilterNode</code></a></span>          <span class="idlMethName"><a href="#widl-BaseAudioContext-createIIRFilter-IIRFilterNode-sequence-double--feedforward-sequence-double--feedback">createIIRFilter</a></span> (<span class="idlParam"><span class="idlParamType">sequence&lt;double&gt;</span> <span class="idlParamName">feedforward</span></span>, <span class="idlParam"><span class="idlParamType">sequence&lt;double&gt;</span> <span class="idlParamName">feedback</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-WaveShaperNode"><code>WaveShaperNode</code></a></span>         <span class="idlMethName"><a href="#widl-BaseAudioContext-createWaveShaper-WaveShaperNode">createWaveShaper</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a></span>             <span class="idlMethName"><a href="#widl-BaseAudioContext-createPanner-PannerNode">createPanner</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-SpatialPannerNode"><code>SpatialPannerNode</code></a></span>      <span class="idlMethName"><a href="#widl-BaseAudioContext-createSpatialPanner-SpatialPannerNode">createSpatialPanner</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-StereoPannerNode"><code>StereoPannerNode</code></a></span>       <span class="idlMethName"><a href="#widl-BaseAudioContext-createStereoPanner-StereoPannerNode">createStereoPanner</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a></span>          <span class="idlMethName"><a href="#widl-BaseAudioContext-createConvolver-ConvolverNode">createConvolver</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-ChannelSplitterNode"><code>ChannelSplitterNode</code></a></span>    <span class="idlMethName"><a href="#widl-BaseAudioContext-createChannelSplitter-ChannelSplitterNode-unsigned-long-numberOfOutputs">createChannelSplitter</a></span> (<span class="idlParam">optional <span class="idlParamType">unsigned long</span> <span class="idlParamName">numberOfOutputs</span> = <span class="idlDefaultValue">6
              </span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a></span>      <span class="idlMethName"><a href="#widl-BaseAudioContext-createChannelMerger-ChannelMergerNode-unsigned-long-numberOfInputs">createChannelMerger</a></span> (<span class="idlParam">optional <span class="idlParamType">unsigned long</span> <span class="idlParamName">numberOfInputs</span> = <span class="idlDefaultValue">6
              </span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-DynamicsCompressorNode"><code>DynamicsCompressorNode</code></a></span> <span class="idlMethName"><a href="#widl-BaseAudioContext-createDynamicsCompressor-DynamicsCompressorNode">createDynamicsCompressor</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-OscillatorNode"><code>OscillatorNode</code></a></span>         <span class="idlMethName"><a href="#widl-BaseAudioContext-createOscillator-OscillatorNode">createOscillator</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-PeriodicWave"><code>PeriodicWave</code></a></span>           <span class="idlMethName"><a href="#widl-BaseAudioContext-createPeriodicWave-PeriodicWave-Float32Array-real-Float32Array-imag-PeriodicWaveConstraints-constraints">createPeriodicWave</a></span> (<span class="idlParam"><span class="idlParamType">Float32Array</span> <span class="idlParamName">real</span></span>, <span class="idlParam"><span class="idlParamType">Float32Array</span> <span class="idlParamName">imag</span></span>, <span class="idlParam">optional <span class="idlParamType"><a class="idlType" href="#idl-def-PeriodicWaveConstraints"><code>PeriodicWaveConstraints</code></a></span> <span class="idlParamName">constraints</span></span>);</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes" typeof="bibo:Chapter" id="attributes"><h4 resource="#h-attributes" id="h-attributes"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.1.1 </span>属性 <button onclick="OpenOriginal('h-attributes')">原文</button></span></h4>
  <dl class="attributes"><dt id="widl-BaseAudioContext-currentTime"><code>currentTime</code> <span class="idlAttrType">double</span>型, readonly      </dt><dd>
<!--          <p>
              This is the time in seconds of the sample frame immediately
              following the last sample-frame in the block of audio most
              recently processed by the context's rendering graph. If the
              context's rendering graph has not yet processed a block of audio,
              then <a href="#widl-BaseAudioContext-currentTime"><code>currentTime</code></a>
              has a value of zero.
            </p>-->
            <p>コンテキストのレンダリンググラフで最後に処理されたオーディオブロックの最後のサンプルフレームの次のサンプルの秒で表した時刻です。もしコンテキストのレンダリンググラフがまだオーディオブロックを処理していない場合 <a href="#widl-BaseAudioContext-currentTime"><code>currentTime</code></a> は0になります。
            </p>
<!--          <p>
              In the time coordinate system of <a href="#widl-BaseAudioContext-currentTime"><code>currentTime</code></a>,
              the value of zero corresponds to the first sample-frame in the
              first block processed by the graph. Elapsed time in this system
              corresponds to elapsed time in the audio stream generated by the
              <a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a>, which may not be
              synchronized with other clocks in the system. (For an
              <a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a>, since the stream is not
              being actively played by any device, there is not even an
              approximation to real time.)
            </p>-->
            <p><a href="#widl-BaseAudioContext-currentTime"><code>currentTime</code></a>の時間軸で0はグラフで処理される最初のブロックの最初のサンプルフレームに対応します。このシステムの経過時間は<a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a>が生成するオーディオストリームの経過時間に対応し、それはシステム内の他の時計には同期しないかも知れません。(<a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a>では、ストリームはどのデバイスも能動的に再生しないため、実時間とはまったく違う進み方になります)
            </p>
<!--            <p>
              All scheduled times in the Web Audio <abbr title="Application Programming Interface">API</abbr> are relative to the
              value of <code>currentTime</code>.
            </p>-->
            <p>
              Web Audio <abbr title="Application Programming Interface">API</abbr> の全てのスケジュールされた時刻は <code>currentTime</code> に対する相対値になります。
            </p>
<!--            <p>
              When the <a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a> is in the <a href="#idl-def-AudioContextState.running"><code>running</code></a>
              state, the value of this attribute is monotonically increasing
              and is updated by the rendering thread in uniform increments,
              corresponding to the audio block size of 128 samples. Thus, for a
              running context, <code>currentTime</code> increases steadily as
              the system processes audio blocks, and always represents the time
              of the start of the next audio block to be processed. It is also
              the earliest possible time when any change scheduled in the
              current state might take effect.
            </p>-->
            <p><a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a> が <a href="#idl-def-AudioContextState.running"><code>running</code></a> 状態にある時、この属性は単調増加し、レンダリングスレッドにより128サンプルのブロックサイズに対応する均一な増分で更新されます。そのため動作中のコンテキストでは、 <code>currentTime</code> はシステムがオーディオブロックを処理するに従って徐々に増加し、常に次に処理されるオーディオブロックの先頭の時刻を表します。それはまた現在の状態に対する変更が効力を持つ最も早い時刻でもあります。
            </p>
          </dd><dt id="widl-BaseAudioContext-destination"><code>destination</code> <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioDestinationNode"><code>AudioDestinationNode</code></a></span>型, readonly      </dt><dd>
<!--            <p>
              An <a href="#AudioDestinationNode"><code>AudioDestinationNode</code></a>
              with a single input representing the final destination for all
              audio. Usually this will represent the actual audio hardware. All
              <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s actively rendering audio will
              directly or indirectly connect to <a href="#widl-BaseAudioContext-destination"><code>destination</code></a>.
            </p>-->
            <p><a href="#AudioDestinationNode"><code>AudioDestinationNode</code></a> は単一の入力を持ち、全てのオーディオの最終的な出口を表しています。 通常これは実際のオーディオハードウェアを表します。 動作中のすべての <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> は直接または間接的にこの destination に接続されます。
            </p>
          </dd><dt id="widl-BaseAudioContext-listener"><code>listener</code> <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioListener"><code>AudioListener</code></a></span>型, readonly      </dt><dd>
<!--            <p>
              An <a href="#AudioListener"><code>AudioListener</code></a> which
              is used for 3D <a href="#Spatialization">spatialization</a>.
            </p>-->
            <p><a href="#AudioListener"><code>AudioListener</code></a>は3D <a href="#Spatialization">空間音響</a>で使用されます。
            </p>
          </dd><dt id="widl-BaseAudioContext-onstatechange"><code>onstatechange</code> <span class="idlAttrType">EventHandler　型</span></dt><dd>
<!--            <p>
            A property used to set the <code>EventHandler</code> for an event
            that is dispatched to <a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a> when the
            state of the AudioContext has changed (i.e. when the corresponding
            promise would have resolved). An event of type
            <code>Event</code> will be dispatched to the event handler,
            which can query the AudioContext's state directly. A newly-created
            AudioContext will always begin in the "suspended" state, and a
            state change event will be fired whenever the state changes to a
            different state.
          </p>-->
            <p><a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a> にAudioContext の状態が変化した時(例えば、対応する Promise がリゾルブされた時など)にディスパッチされるイベントの <code>EventHandler</code> を設定するために使用されるプロパティです。新たに作成された AudioContextは 常に "suspended" 状態から開始し、状態の変化イベントは異なる状態への遷移の度に発行されます。
            </p>
          </dd><dt id="widl-BaseAudioContext-sampleRate"><code>sampleRate</code> <span class="idlAttrType">float</span>型, readonly      </dt><dd>
<!--            <p>
              The sample rate (in sample-frames per second) at which the
              <a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a> handles audio. It is assumed
              that all <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s in the context run at
              this rate. In making this assumption, sample-rate converters or
              "varispeed" processors are not supported in real-time processing.
            </p>-->
            <p>
              <a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a> が扱うオーディオのサンプルレート(1秒あたりのサンプルフレーム数)です。 コンテキスト内のすべての <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> はこのレートで動作する事を想定しています。 これを想定するため、サンプレートコンバータや"可変速"処理はリアルタイム処理内ではサポートされません。
            </p>
          </dd><dt id="widl-BaseAudioContext-state"><code>state</code> <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioContextState"><code>AudioContextState</code></a></span>型, readonly     </dt><dd>
<!--            <p>
              Describes the current state of this BaseAudioContext. The context
              state <em title="MUST" class="rfc2119">MUST</em> begin in "suspended", and transitions to "running" when
              system resources are acquired and audio has begun processing. For
              OfflineAudioContexts, the state will remain in "suspended" until
              <code>startRendering()</code> is called, at which point it will
              transition to "running", and then to "closed" once audio processing
              has completed and oncomplete has been fired.
            </p>-->
            <p>BaseAudioContext の現在の状態を表します。コンテキストの状態は、"suspended" から開始し、システムのリソースを確保してオーディオの処理を開始した時に "running" に遷移します (<em title="MUST" class="rfc2119">MUST</em>)。OfflineAudioContext の場合は、 <code>startRendering()</code> が呼び出されるまで state は "suspended" のままで、呼び出されたのちに "running" に遷移し、オーディオ処理が完了すると "close" に遷移して oncomplete <span class="annotate">(訳注:イベント)</span> が発行されます。
            </p>
<!--            <p>
              When the state is "suspended", a call to <code>resume()</code>
              will cause a transition to "running", or a call to
              <code>close()</code> will cause a transition to "closed".
            </p>-->
            <p>state が "suspended" の時、 <code>resume()</code> を呼び出すと "running" に遷移し、また <code>close()</code> を呼び出すと "closed" に遷移します。
            </p>
<!--            <p>
              When the state is "running", a call to <code>suspend()</code>
              will cause a transition to "suspended", or a call to
              <code>close()</code> will cause a transition to "closed".
            </p>-->
            <p>state が "running" の時、 <code>suspend()</code> を呼び出すと "suspended" に遷移し、また <code>close()</code> を呼び出すと "closed" に遷移します。
            </p>
<!--            <p>
              When the state is "closed", no further state transitions are
              possible.
            </p>-->
            <p>state が "closed" の時、これ以上の状態の遷移はできません。
            </p>
          </dd></dl></section><section property="bibo:hasPart" resource="#methods" typeof="bibo:Chapter" id="methods"><h4 resource="#h-methods" id="h-methods"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.1.2 </span>メソッド</span></h4><dl class="methods"><dt id="widl-BaseAudioContext-close-Promise-void"><code>close</code></dt><dd>
<!--            <p>
            Closes the audio context, releasing any system audio resources used
            by the <a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a>. This will not
            automatically release all BaseAudioContext-created objects, unless
            other references have been released as well; however, it will
            forcibly release any system audio resources that might prevent
            additional AudioContexts from being created and used, suspend the
            progression of the <a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a>'s <a href="#widl-BaseAudioContext-currentTime">currentTime</a>, and stop
            processing audio data. The promise resolves when all
            AudioContext-creation-blocking resources have been released. If
            this is called on <a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a>, then return a promise
            rejected with a <code>DOMException</code> whose name is
            <code>InvalidStateError</code>.
          </p>-->
<!--          <div><em>No parameters.</em></div><div><em>Return type: </em><code>Promise&lt;void&gt;</code></div>-->
          <p>
            オーディオコンテキストをクローズし、<a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a> で使用されていたシステムの全てのリソースを解放します。
            この呼び出しでは他からの参照が同様に開放されない限り BaseAudioContext が作成したオブジェクトは全て自動的には解放されません。しかし、これ以降にオーディオコンテキストが作成され、使用され、<a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a> の <a href="#widl-BaseAudioContext-currentTime">currentTime</a> の進行を suspend し、処理を終了する事を妨げる可能性のあるシステムのオーディオリソースは強制的に開放されます。
            Promise は、全てのオーディオコンテキストの作成をブロックするリソースが解放された時にリゾルブされます。もしこれが <a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a> に対して呼び出された場合、<code>InvalidStateError</code> の名前の <code>DOMException</code> で Promise はリジェクトされます。
          </p>
          <div><em>パラメータなし</em></div><div><em>戻り値: </em><code>Promise&lt;void&gt;</code></div>
          </dd><dt id="widl-BaseAudioContext-createAnalyser-AnalyserNode"><code>createAnalyser</code></dt><dd>
          <p class="orig">
          Create an <a class="idlType" href="#idl-def-AnalyserNode"><code>AnalyserNode</code></a>.
          <div class="orig"><em>No parameters.</em></div><div class="orig"><em>Return type: </em><code><a class="idlType" href="#idl-def-AnalyserNode"><code>AnalyserNode</code></a></code></div>
          </p>
          <p> <a class="idlType" href="#idl-def-AnalyserNode"><code>AnalyserNode</code></a> を作成します。
          <div><em>パラメータなし</em></div><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-AnalyserNode"><code>AnalyserNode</code></a></code></div>
          </p>
          </dd>
          <dt id="widl-BaseAudioContext-createAudioWorker-Promise-AudioWorker--DOMString-scriptURL"><code>createAudioWorker</code></dt>
<!--          <dd>
            Creates an <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a> object and loads the
            associated script into an
            <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a>, then resolves the
            returned Promise.
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">scriptURL</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                This parameter represents the URL of the script to be loaded as
                an <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a> node factory. See <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a>
                section for more detail.
              </td></tr></tbody></table><div><em>Return type: </em><code>Promise&lt;<a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a>&gt;</code></div>
            </dd>-->
                <dd>
                  <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a> オブジェクトを作成し、対応するスクリプトを <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> にロードして返却した Promise をリゾルブします。
                <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">scriptURL</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                      このパラメータは<a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a>ノードファクトリとしてロードするスクリプトのURLを表します。
                      詳細は <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a> セクションを参照してください。
                    </td></tr></tbody></table><div><em>戻り値: </em><code>Promise&lt;<a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a>&gt;</code></div></dd><dt id="widl-BaseAudioContext-createBiquadFilter-BiquadFilterNode"><code>createBiquadFilter</code></dt>
<!--          <dd>
            Creates a <a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a> representing a
            second order filter which can be configured as one of several
            common filter types.
          <div><em>No parameters.</em></div><div><em>Return type: </em><code><a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a></code></div>
        </dd>-->
          <dd>
            幾つかのタイプのフィルタに設定可能な2次フィルタを表す <a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a> を作成します。
            <div><em>パラメータなし</em></div><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a></code></div>
          </dd>
          <dt id="widl-BaseAudioContext-createBuffer-AudioBuffer-unsigned-long-numberOfChannels-unsigned-long-length-float-sampleRate"><code>createBuffer</code></dt>
<!--          <dd>
            Creates an AudioBuffer of the given size. The audio data in the
            buffer will be zero-initialized (silent). A NotSupportedError
            exception <em title="MUST" class="rfc2119">MUST</em> be thrown if any of the arguments is negative, zero,
            or outside its nominal range.
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">numberOfChannels</td><td class="prmType"><code>unsigned long</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                Determines how many channels the buffer will have. An
                implementation must support at least 32 channels.
              </td></tr><tr><td class="prmName">length</td><td class="prmType"><code>unsigned long</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                Determines the size of the buffer in sample-frames.
              </td></tr><tr><td class="prmName">sampleRate</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                Describes the sample-rate of the linear PCM audio data in the
                buffer in sample-frames per second. An implementation must
                support sample rates in at least the range 8192 to 96000.
              </td></tr></tbody></table><div><em>Return type: </em><code><a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a></code></div>
            </dd>-->
            <dd>
              与えられたサイズの AudioBuffer を作成します。バッファ内のデータは0(無音)で初期化されます。 もし、引数のどれかが負、0または範囲外の場合、NotSupportedError 例外を発生します(<em title="MUST" class="rfc2119">MUST</em>)。
            <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">numberOfChannels</td><td class="prmType"><code>unsigned long</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                  バッファが持つチャンネル数を指定します。 実装は少なくとも32チャンネルをサポートしなくてはなりません。
                </td></tr><tr><td class="prmName">length</td><td class="prmType"><code>unsigned long</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                  バッファのサイズをサンプルフレーム数で指定します。
                </td></tr><tr><td class="prmName">sampleRate</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                  バッファ内のリニアPCMオーディオデータのサンプルレートを秒あたりのサンプルフレーム数で表します。 実装は少なくとも8192から96000の範囲をサポートしなくてはなりません。
                </td></tr></tbody></table><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a></code></div>
              </dd>

              <dt id="widl-BaseAudioContext-createBufferSource-AudioBufferSourceNode"><code>createBufferSource</code></dt>
              <dd class="orig">
                Creates an <a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a>.
                <div><em>No parameters.</em></div><div><em>Return type: </em><code><a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a></code></div>
              </dd>
              <dd>
                <a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a>を作成します。
                <div><em>パラメータなし</em></div><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a></code></div>
              </dd>

        <dt id="widl-BaseAudioContext-createChannelMerger-ChannelMergerNode-unsigned-long-numberOfInputs"><code>createChannelMerger</code></dt>
<!--        <dd>
          Creates a <a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a> representing a
          channel merger. An IndexSizeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown for
          invalid parameter values.

        <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">numberOfInputs</td><td class="prmType"><code>unsigned long = 6
            </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
              The <dfn id="dfn-numberofinputs" data-dfn-type="dfn">numberOfInputs</dfn> parameter determines the number
              of inputs. Values of up to 32 must be supported. If not
              specified, then 6 will be used.
            </td></tr></tbody></table><div><em>Return type: </em><code><a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a></code></div>
          </dd>-->
          <dd>
            チャンネル結合器を表す <a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a> を作成します。 パラメータの値が無効の場合、IndexSizeError 例外を発生します(<em title="MUST" class="rfc2119">MUST</em>)。
          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">numberOfInputs</td><td class="prmType"><code>unsigned long = 6
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                <dfn id="dfn-numberofinputs" data-dfn-type="dfn">numberOfInputs</dfn> は入力の数を指定します。値は32までサポートされなくてはなりません。 もし指定されない場合は6となります。
              </td></tr></tbody></table><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a></code></div>
            </dd>
            <dt id="widl-BaseAudioContext-createChannelSplitter-ChannelSplitterNode-unsigned-long-numberOfOutputs"><code>createChannelSplitter</code></dt>
<!--            <dd>
            Creates an <a class="idlType" href="#idl-def-ChannelSplitterNode"><code>ChannelSplitterNode</code></a> representing a
            channel splitter. An IndexSizeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown for
            invalid parameter values.
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">numberOfOutputs</td><td class="prmType"><code>unsigned long = 6
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                The number of outputs. Values of up to 32 must be supported. If
                not specified, then 6 will be used.
              </td></tr></tbody></table><div><em>Return type: </em><code><a class="idlType" href="#idl-def-ChannelSplitterNode"><code>ChannelSplitterNode</code></a></code></div>
            </dd>-->
            <dd>
              チャンネル分割器を表す <a class="idlType" href="#idl-def-ChannelSplitterNode"><code>ChannelSplitterNode</code></a> を作成します。 パラメータの値が無効の場合、IndexSizeError 例外を発生します(<em title="MUST" class="rfc2119">MUST</em>)。
          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">numberOfOutputs</td><td class="prmType"><code>unsigned long = 6
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                出力の数を指定します。32までサポートされなくてはなりません。 もし指定されない場合は6となります。
              </td></tr></tbody></table><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-ChannelSplitterNode"><code>ChannelSplitterNode</code></a></code></div>
            </dd class="orig">
            <dt id="widl-BaseAudioContext-createConvolver-ConvolverNode"><code>createConvolver</code></dt>
            <dd class="orig">
            Creates a <a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a>.
          <div><em>No parameters.</em></div><div><em>Return type: </em><code><a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a></code></div>
            </dd>
            <dd>
              <a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a>を作成します。
          <div><em>パラメータなし</em></div><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a></code></div>
            </dd>
          <dt id="widl-BaseAudioContext-createDelay-DelayNode-double-maxDelayTime"><code>createDelay</code></dt>
<!--          <dd>
            Creates a <a class="idlType" href="#idl-def-DelayNode"><code>DelayNode</code></a> representing a variable
            delay line. The initial default delay time will be 0 seconds.

          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">maxDelayTime</td><td class="prmType"><code>double = 1.0
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                The <dfn id="dfn-maxdelaytime" data-dfn-type="dfn">maxDelayTime</dfn> parameter is optional and specifies
                the maximum delay time in seconds allowed for the delay line.
                If specified, this value <em title="MUST" class="rfc2119">MUST</em> be greater than zero and less
                than three minutes or a NotSupportedError exception <em title="MUST" class="rfc2119">MUST</em> be
                thrown.
              </td></tr></tbody></table><div><em>Return type: </em><code><a class="idlType" href="#idl-def-DelayNode"><code>DelayNode</code></a></code></div>
            </dd>-->
            <dd>
              遅延時間が可変な遅延機能を表す <a class="idlType" href="#idl-def-DelayNode"><code>DelayNode</code></a>を作成します。 初期化時のデフォルト遅延時間は0秒です。
            <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">maxDelayTime</td><td class="prmType"><code>double = 1.0
                </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                  <dfn id="dfn-maxdelaytime" data-dfn-type="dfn">maxDelayTime</dfn> パラメータはオプションであり、その遅延機能の遅延時間の最大値を秒で指定します。
                  もし指定する場合は、その値は0よりも大きく3分よりも小さくなければなりません(<em title="MUST" class="rfc2119">MUST</em>)。そうでない場合 NotSupportedError 例外を発生します(<em title="MUST" class="rfc2119">MUST</em>)。
                </td></tr></tbody></table><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-DelayNode"><code>DelayNode</code></a></code></div>
              </dd>
            <dt id="widl-BaseAudioContext-createDynamicsCompressor-DynamicsCompressorNode"><code>createDynamicsCompressor</code>
            </dt>
<!--            <dd>
            Creates a <a class="idlType" href="#idl-def-DynamicsCompressorNode"><code>DynamicsCompressorNode</code></a>
          <div><em>No parameters.</em></div><div><em>Return type: </em><code><a class="idlType" href="#idl-def-DynamicsCompressorNode"><code>DynamicsCompressorNode</code></a></code></div>
        </dd>-->
          <dd>
            <a class="idlType" href="#idl-def-DynamicsCompressorNode"><code>DynamicsCompressorNode</code></a> を作成します。
        <div><em>パラメータなし</em></div><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-DynamicsCompressorNode"><code>DynamicsCompressorNode</code></a></code></div>
        </dd>
          <dt id="widl-BaseAudioContext-createGain-GainNode"><code>createGain</code></dt>
<!--          <dd>
            Create an <a class="idlType" href="#idl-def-GainNode"><code>GainNode</code></a>.
          <div><em>No parameters.</em></div><div><em>Return type: </em><code><a class="idlType" href="#idl-def-GainNode"><code>GainNode</code></a></code></div>
        </dd>-->
        <dd>
          <a class="idlType" href="#idl-def-GainNode"><code>GainNode</code></a> を作成します。
        <div><em>パラメータなし</em></div><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-GainNode"><code>GainNode</code></a></code></div>
      </dd>
        <dt id="widl-BaseAudioContext-createIIRFilter-IIRFilterNode-sequence-double--feedforward-sequence-double--feedback"><code>createIIRFilter</code></dt>
<!--        <dd>
            Creates an <a class="idlType" href="#idl-def-IIRFilterNode"><code>IIRFilterNode</code></a> representing a general
            IIR Filter.

          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">feedforward</td><td class="prmType"><code>sequence&lt;double&gt;</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                An array of the feedforward (numerator) coefficients for the
                transfer function of the IIR filter. The maximum length of this
                array is 20. If all of the values are zero, an
                InvalidStateError <em title="MUST" class="rfc2119">MUST</em> be thrown. A NotSupportedError <em title="MUST" class="rfc2119">MUST</em> be
                thrown if the array length is 0 or greater than 20.
              </td></tr><tr><td class="prmName">feedback</td><td class="prmType"><code>sequence&lt;double&gt;</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                An array of the feedback (denominator) coefficients for the
                tranfer function of the IIR filter. The maximum length of this
                array is 20. If the first element of the array is 0, an
                InvalidStateError <em title="MUST" class="rfc2119">MUST</em> be thrown. A NotSupportedError <em title="MUST" class="rfc2119">MUST</em> be
                thrown if the array length is 0 or greater than 20.
              </td></tr></tbody></table><div><em>Return type: </em><code><a class="idlType" href="#idl-def-IIRFilterNode"><code>IIRFilterNode</code></a></code></div>
            </dd>-->
            <dd>
              一般的なIIRフィルターを表す<a class="idlType" href="#idl-def-IIRFilterNode"><code>IIRFilterNode</code></a> を作成します。
              <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">feedforward</td><td class="prmType"><code>sequence&lt;double&gt;</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                  IIR フィルターの伝達関数のフィードフォワード(分子)の係数の配列です。
                  この配列の最大の長さは20です。もし全ての値が0の場合、InvalidStateError 例外を発生します<em title="MUST" class="rfc2119">MUST</em>。配列の長さが0または20より大きい場合は NotSupportedError 例外を発生します<em title="MUST" class="rfc2119">MUST</em>。
                  </td></tr><tr><td class="prmName">feedback</td><td class="prmType"><code>sequence&lt;double&gt;</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                    IIR フィルターの伝達関数のフィードバック(分母)の係数の配列です。
                    この配列の最大の長さは20です。もし配列の最初の要素が0の場合、InvalidStateError 例外を発生します<em title="MUST" class="rfc2119">MUST</em>。もし配列の長さが0または20より大きい場合は NotSupportedError 例外を発生します<em title="MUST" class="rfc2119">MUST</em>。
                  </td></tr></tbody></table><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-IIRFilterNode"><code>IIRFilterNode</code></a></code></div>
                </dd>

            <dt id="widl-BaseAudioContext-createOscillator-OscillatorNode"><code>createOscillator</code></dt>
<!--            <dd>
            Creates an <a class="idlType" href="#idl-def-OscillatorNode"><code>OscillatorNode</code></a>
          <div><em>No parameters.</em></div><div><em>Return type: </em><code><a class="idlType" href="#idl-def-OscillatorNode"><code>OscillatorNode</code></a></code></div>
        </dd>-->
          <dd>
            <a class="idlType" href="#idl-def-OscillatorNode"><code>OscillatorNode</code></a> を作成します。
        <div><em>パラメータなし</em></div><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-OscillatorNode"><code>OscillatorNode</code></a></code></div>
        </dd>
          <dt id="widl-BaseAudioContext-createPanner-PannerNode"><code>createPanner</code></dt>
<!--          <dd>
            This method is DEPRECATED, as it is intended to be replaced by
            createSpatialPanner or createStereoPanner, depending on the
            scenario. Creates a <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a>.
          <div><em>No parameters.</em></div><div><em>Return type: </em><code><a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a></code></div>
        </dd>-->
        <dd>
          このメソッドは廃止予定で、場合に応じて createSpatialPanner または createStereoPanner で置き換えられます。
          <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a>を作成します。
        <div><em>パラメータなし</em></div><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a></code></div>
      </dd>
        <dt id="widl-BaseAudioContext-createPeriodicWave-PeriodicWave-Float32Array-real-Float32Array-imag-PeriodicWaveConstraints-constraints"><code>createPeriodicWave</code></dt>
<!--        <dd>
            Creates a <a class="idlType" href="#idl-def-PeriodicWave"><code>PeriodicWave</code></a> representing a waveform
            containing arbitrary harmonic content. The <code>real</code> and
            <code>imag</code> parameters must be of type
            <code>Float32Array</code> (described in [<cite><a href="#bib-TYPED-ARRAYS" class="bibref">TYPED-ARRAYS</a></cite>]) of equal
            lengths greater than zero or an IndexSizeError exception <em title="MUST" class="rfc2119">MUST</em> be
            thrown. All implementations must support arrays up to at least
            8192. These parameters specify the Fourier coefficients of a
            <a href="https://en.wikipedia.org/wiki/Fourier_series">Fourier
            series</a> representing the partials of a periodic waveform. The
            created <a class="idlType" href="#idl-def-PeriodicWave"><code>PeriodicWave</code></a> will be used with an
            <a class="idlType" href="#idl-def-OscillatorNode"><code>OscillatorNode</code></a> and, by default, will represent
            a <em>normalized</em> time-domain waveform having maximum absolute
            peak value of 1. Another way of saying this is that the generated
            waveform of an <a class="idlType" href="#idl-def-OscillatorNode"><code>OscillatorNode</code></a> will have maximum
            peak value at 0dBFS. Conveniently, this corresponds to the
            full-range of the signal values used by the Web Audio <abbr title="Application Programming Interface">API</abbr>. Because
            the PeriodicWave is normalized by default on creation, the
            <code>real</code> and <code>imag</code> parameters represent
            <em>relative</em> values. If normalization is disabled via the
            <code>disableNormalization</code> parameter, this normalization is
            disabled, and the time-domain waveform has the amplitudes as given
            by the Fourier coefficients.
            <p>
              As <a class="idlType" href="#idl-def-PeriodicWave"><code>PeriodicWave</code></a> objects maintain their own copies of these
              arrays, any modification of the arrays uses as the
              <code>real</code> and <code>imag</code> parameters after the call
              to
              <code>createPeriodicWave()</code> will have no effect on the
              <a class="idlType" href="#idl-def-PeriodicWave"><code>PeriodicWave</code></a> object.
            </p>

          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">real</td><td class="prmType"><code>Float32Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The <dfn data-dfn-type="dfn" id="dfn-real">real</dfn> parameter represents an array
                of <code>cosine</code> terms (traditionally the A terms). In
                audio terminology, the first element (index 0) is the DC-offset
                of the periodic waveform. The second element (index 1)
                represents the fundamental frequency. The third element
                represents the first overtone, and so on. The first element is
                ignored and implementations must set it to zero internally.
              </td></tr><tr><td class="prmName">imag</td><td class="prmType"><code>Float32Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The <dfn data-dfn-type="dfn" id="dfn-imag">imag</dfn> parameter represents an array
                of <code>sine</code> terms (traditionally the B terms). The
                first element (index 0) should be set to zero (and will be
                ignored) since this term does not exist in the Fourier series.
                The second element (index 1) represents the fundamental
                frequency. The third element represents the first overtone, and
                so on.
              </td></tr><tr><td class="prmName">constraints</td><td class="prmType"><code><a class="idlType" href="#idl-def-PeriodicWaveConstraints"><code>PeriodicWaveConstraints</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                If not given, the waveform is normalized. Otherwise, the
                waveform is normalized according the value given by
                <code>constraints</code>.
              </td></tr></tbody></table><div><em>Return type: </em><code><a class="idlType" href="#idl-def-PeriodicWave"><code>PeriodicWave</code></a></code></div>
            </dd>-->
            <dd>
              任意の倍音構成を表す <a class="idlType" href="#idl-def-PeriodicWave"><code>PeriodicWave</code></a> を作成します。 <code>real</code> および <code>imag</code> パラメータは  <code>Float32Array</code> ([<cite><a href="#bib-TYPED-ARRAYS" class="bibref">TYPED-ARRAYS</a></cite>] で説明される)型で0より大きい同じ長さでなくてはなりません。
               そうでない場合、IndexSizeError 例外を発生します(<em title="MUST" class="rfc2119">MUST</em>)。
               全ての実装は少なくとも8192までの配列の長さをサポートしなくてはなりません。
                これらのパラメータは任意の周期波形を表す<a href="https://en.wikipedia.org/wiki/Fourier_series">フーリエ級数</a>の係数の一部分を表します。 作成された<a class="idlType" href="#idl-def-PeriodicWave"><code>PeriodicWave</code></a> は <a class="idlType" href="#idl-def-OscillatorNode"><code>OscillatorNode</code></a> と共に使用され、 デフォルトでは絶対値の最大が1となる<em>正規化</em>された時間領域の波形を表現します。 別の言い方をするとこれは <a class="idlType" href="#idl-def-OscillatorNode"><code>OscillatorNode</code></a> が発生する波形の最大ピークが0dBFSであるという事です。
                 これは都合よく Web Audio <abbr title="Application Programming Interface">API</abbr> で使用される最大振幅の信号に対応します。 PeriodicWave はデフォルトでは作成時に正規化されるため、<code>real</code> および  <code>imag</code> パラメータは<em>相対値</em>を表します。
                もし <code>disableNormalization</code> パラメータによってディセーブルされていた場合、正規化は行われず、時間領域の波形はフーリエ係数で与えられた振幅を持ちます。
                <p>
                  <a class="idlType" href="#idl-def-PeriodicWave"><code>PeriodicWave</code></a> オブジェクトはこれらの配列をコピーして管理するため、<code>real</code> および <code>imag</code> パラメータとして使用した配列を <code>createPeriodicWave()</code> 呼び出し後に変更しても <a class="idlType" href="#idl-def-PeriodicWave"><code>PeriodicWave</code></a> オブジェクトには反映されません。
                </p>

              <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">real</td><td class="prmType"><code>Float32Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                <dfn data-dfn-type="dfn" id="dfn-real">real</dfn> パラメータは<code>コサイン</code>項(慣習的な言い方でA項)の配列を表します。 オーディオの用語では最初の要素(インデックス0)は周期波形の DC オフセットとなります。 2番目の要素(インデックス1)は基本周波数を表します。3番目の要素は最初の倍音を表し、それ以降も同様に続いてゆきます。
                最初の要素は無視され、実装は内部的に0に設定しなくてはなりません。
                  </td></tr><tr><td class="prmName">imag</td><td class="prmType"><code>Float32Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                    <dfn data-dfn-type="dfn" id="dfn-imag">imag</dfn>パラメータは<code>サイン</code>項(慣習的な言い方でB項)の配列を表します。 最初の要素(インデックス0)はフーリエ級数には存在しないため、0でなくてはなりません(これは無視されます)。 2番目の要素(インデックス1)は基本周波数を表します。3番目の要素は最初の倍音を表し、それ以降も同様に続いてゆきます。
                  </td></tr><tr><td class="prmName">constraints</td><td class="prmType"><code><a class="idlType" href="#idl-def-PeriodicWaveConstraints"><code>PeriodicWaveConstraints</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                    もし与えられていない場合は、波形は正規化されます。そうでない場合、波形は <code>constraints</code> に与えられた値に従って正規化されます。
                  </td></tr></tbody></table><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-PeriodicWave"><code>PeriodicWave</code></a></code></div>
                </dd>

            <dt id="widl-BaseAudioContext-createScriptProcessor-ScriptProcessorNode-unsigned-long-bufferSize-unsigned-long-numberOfInputChannels-unsigned-long-numberOfOutputChannels"><code>createScriptProcessor</code></dt>
<!--            <dd>
            This method is DEPRECATED, as it is intended to be replaced by
            createAudioWorker. Creates a
            <a class="idlType" href="#idl-def-ScriptProcessorNode"><code>ScriptProcessorNode</code></a> for direct audio processing
            using JavaScript. An IndexSizeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown if
            <a data-link-type="dfn" class="internalDFN" href="#dfn-buffersize"><code>bufferSize</code></a> or
            <a data-link-type="dfn" class="internalDFN" href="#dfn-numberofinputchannels"><code>numberOfInputChannels</code></a> or
            <a data-link-type="dfn" class="internalDFN" href="#dfn-numberofoutputchannels"><code>numberOfOutputChannels</code></a> are outside the valid
            range.
            It is invalid for both
            <a data-link-type="dfn" class="internalDFN" href="#dfn-numberofinputchannels"><code>numberOfInputChannels</code></a> and
            <a data-link-type="dfn" class="internalDFN" href="#dfn-numberofoutputchannels"><code>numberOfOutputChannels</code></a> to be zero. In this case
            an IndexSizeError <em title="MUST" class="rfc2119">MUST</em> be thrown.
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">bufferSize</td><td class="prmType"><code>unsigned long = 0
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                The <a data-link-type="dfn" class="internalDFN" href="#dfn-buffersize"><code>bufferSize</code></a> parameter determines the
                buffer size in units of sample-frames. If it's not passed in,
                or if the value is 0, then the implementation will choose the
                best buffer size for the given environment, which will be
                constant power of 2 throughout the lifetime of the node.
                Otherwise if the author explicitly specifies the bufferSize, it
                must be one of the following values: 256, 512, 1024, 2048,
                4096, 8192, 16384. This value controls how frequently the
                <code>audioprocess</code> event is dispatched and how many
                sample-frames need to be processed each call. Lower values for
                <a data-link-type="dfn" class="internalDFN" href="#dfn-buffersize"><code>bufferSize</code></a> will result in a lower (better)
                <a href="#latency">latency</a>. Higher values will be necessary
                to avoid audio breakup and <a href="#audio-glitching">glitches</a>. It is recommended for authors
                to not specify this buffer size and allow the implementation to
                pick a good buffer size to balance between <a href="#latency">latency</a> and audio quality. If the value of this
                parameter is not one of the allowed power-of-2 values listed
                above, an IndexSizeError <em title="MUST" class="rfc2119">MUST</em> be thrown.
              </td></tr><tr><td class="prmName">numberOfInputChannels</td><td class="prmType"><code>unsigned long = 2
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                This parameter determines the number of channels for this
                node's input. Values of up to 32 must be supported.
              </td></tr><tr><td class="prmName">numberOfOutputChannels</td><td class="prmType"><code>unsigned long = 2
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                This parameter determines the number of channels for this
                node's output. Values of up to 32 must be supported.
              </td></tr></tbody></table><div><em>Return type: </em><code><a class="idlType" href="#idl-def-ScriptProcessorNode"><code>ScriptProcessorNode</code></a></code></div>
            </dd>-->
            <dd>
              このメソッドは廃止予定で、createAudioWorker で置き換えられます。
              JavaScript を使ったオーディオデータ直接処理のための <a class="idlType" href="#idl-def-ScriptProcessorNode"><code>ScriptProcessorNode</code></a> を作成します。 もし、<a data-link-type="dfn" class="internalDFN" href="#dfn-buffersize"><code>bufferSize</code></a> または <a data-link-type="dfn" class="internalDFN" href="#dfn-numberofinputchannels"><code>numberOfInputChannels</code></a> または <a data-link-type="dfn" class="internalDFN" href="#dfn-numberofoutputchannels"><code>numberOfOutputChannels</code></a> が範囲外の場合、IndexSizeError 例外を発生します(<em title="MUST" class="rfc2119">MUST</em>)。

              <a data-link-type="dfn" class="internalDFN" href="#dfn-numberofinputchannels"><code>numberOfInputChannels</code></a> と <a data-link-type="dfn" class="internalDFN" href="#dfn-numberofoutputchannels"><code>numberOfOutputChannels</code></a> の両方が0となるのは不正となります。この場合、IndexSizeError 例外を発生します(<em title="MUST" class="rfc2119">MUST</em>)。
          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">bufferSize</td><td class="prmType"><code>unsigned long = 0
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                <a data-link-type="dfn" class="internalDFN" href="#dfn-buffersize"><code>bufferSize</code></a>パラメータはサンプルフレーム数でバッファのサイズを指定します。 もしそれが渡されない場合、または値が0である場合、実装はノードのライフタイムを通して一定な、動作環境に最適な2の累乗のバッファサイズを選択します。 それ以外の場合は明示的にバッファサイズを指定します。それは次の値のどれかでなければなりません: 256、512、1024、2048、4096、8192、16384。 この値は <code>audioprocess</code> イベントが発生する頻度とそれぞれの呼び出しでどれだけのサンプルフレームを処理する必要があるかを制御します。 <a data-link-type="dfn" class="internalDFN" href="#dfn-buffersize"><code>bufferSize</code></a> が小さい値ならば <a href="#latency">レイテンシー</a> は低く(良く)なります。 オーディオが途切れ、<a href="#audio-glitching">グリッジ</a>が発生する事を避けるには大きな値が必要となります。 <a href="#latency">レイテンシー</a>とオーディオ品質の間のバランスを取るためには、プログラマはこのバッファサイズを指定せず、実装に最適なバッファサイズを選択させる事が推奨されます。
                もしこのパラメータの値が上に示した許された2の累乗の値でない場合、IndexSizeError 例外を発生します(<em title="MUST" class="rfc2119">MUST</em>)。
              </td></tr><tr><td class="prmName">numberOfInputChannels</td><td class="prmType"><code>unsigned long = 2
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                このパラメータはこのノードの入力チャンネル数を指定します。32チャンネルまでの値がサポートされなくてはなりません。
              </td></tr><tr><td class="prmName">numberOfOutputChannels</td><td class="prmType"><code>unsigned long = 2
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                このパラメータはこのノードの出力チャンネル数を指定します。 32チャンネルまでの値がサポートされなくてはなりません。
              </td></tr></tbody></table><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-ScriptProcessorNode"><code>ScriptProcessorNode</code></a></code></div>
            </dd>

            <dt id="widl-BaseAudioContext-createSpatialPanner-SpatialPannerNode"><code>createSpatialPanner</code></dt>
<!--            <dd>
            Creates a <a class="idlType" href="#idl-def-SpatialPannerNode"><code>SpatialPannerNode</code></a>.
          <div><em>No parameters.</em></div><div><em>Return type: </em><code><a class="idlType" href="#idl-def-SpatialPannerNode"><code>SpatialPannerNode</code></a></code></div>
        </dd>-->
            <dd>
              <a class="idlType" href="#idl-def-SpatialPannerNode"><code>SpatialPannerNode</code></a>を作成します。
              <div><em>パラメータなし</em></div><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-SpatialPannerNode"><code>SpatialPannerNode</code></a></code></div>
            </dd>
            <dt id="widl-BaseAudioContext-createStereoPanner-StereoPannerNode"><code>createStereoPanner</code></dt>
<!--            <dd>
              Creates a <a class="idlType" href="#idl-def-StereoPannerNode"><code>StereoPannerNode</code></a>.
              <div><em>No parameters.</em></div><div><em>Return type: </em><code><a class="idlType" href="#idl-def-StereoPannerNode"><code>StereoPannerNode</code></a></code></div>
            </dd>-->
            <dd>
              <a class="idlType" href="#idl-def-StereoPannerNode"><code>StereoPannerNode</code></a>を作成します。
              <div><em>パラメータなし</em></div><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-StereoPannerNode"><code>StereoPannerNode</code></a></code></div>
            </dd>
            <dt id="widl-BaseAudioContext-createWaveShaper-WaveShaperNode"><code>createWaveShaper</code></dt>
<!--            <dd>
              Creates a <a class="idlType" href="#idl-def-WaveShaperNode"><code>WaveShaperNode</code></a> representing a
              non-linear distortion.
              <div><em>No parameters.</em></div><div><em>Return type: </em><code><a class="idlType" href="#idl-def-WaveShaperNode"><code>WaveShaperNode</code></a></code></div>
            </dd>-->
            <dd>
              非線形な歪み効果を表す<a class="idlType" href="#idl-def-WaveShaperNode"><code>WaveShaperNode</code></a>を作成します。
              <div><em>パラメータなし</em></div><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-WaveShaperNode"><code>WaveShaperNode</code></a></code></div>
            </dd>
            <dt id="widl-BaseAudioContext-decodeAudioData-Promise-AudioBuffer--ArrayBuffer-audioData-DecodeSuccessCallback-successCallback-DecodeErrorCallback-errorCallback"><code>decodeAudioData</code></dt>
<!--            <dd>
            Asynchronously decodes the audio file data contained in the
            ArrayBuffer. The ArrayBuffer can, for example, be loaded from an
            XMLHttpRequest's <code>response</code> attribute after setting the
            <code>responseType</code> to "arraybuffer". Audio file data can be
            in any of the formats supported by the <code>audio</code> or
            <code>video</code> elements. The buffer passed to <a href="#widl-BaseAudioContext-decodeAudioData-Promise-AudioBuffer--ArrayBuffer-audioData-DecodeSuccessCallback-successCallback-DecodeErrorCallback-errorCallback">
            decodeAudioData</a> has its content-type determined by sniffing, as
            described in [<cite><a href="#bib-mimesniff" class="bibref">mimesniff</a></cite>].

            <p>
              Although the primary method of interfacing with this function is
              via its promise return value, the callback parameters are
              provided for legacy reasons. The system shall ensure that the
              <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> is not garbage collected before the promise
              is resolved or rejected and any callback function is called and
              completes.
            </p>
            <p>
              The following steps must be performed:
            </p>
            <ol>
              <li>Let <var>promise</var> be a new promise.
              </li>
              <li>If audioData is null or not a valid ArrayBuffer:
                <ol>
                  <li>Let <var>error</var> be a <code>DOMException</code> whose
                  name is <code>NotSupportedError</code>.
                  </li>
                  <li>Reject <var>promise</var> with <var>error</var>.
                  </li>
                  <li>If <a data-link-type="dfn" class="internalDFN" href="#dfn-errorcallback">errorCallback</a> is not missing, invoke
                  <a data-link-type="dfn" class="internalDFN" href="#dfn-errorcallback">errorCallback</a> with <var>error</var>.
                  </li>
                  <li>Terminate this algorithm.
                  </li>
                </ol>
              </li>
              <li>Neuter the audioData ArrayBuffer in such a way that
              JavaScript code may not access or modify the data anymore.
              </li>
              <li>Queue a decoding operation to be performed on another thread.
              </li>
              <li>Return <var>promise</var>.
              </li>
              <li>In the decoding thread:
                <ol>
                  <li>Attempt to decode the encoded audioData into
                  linear PCM.
                  </li>
                  <li>If a decoding error is encountered due to the audio
                  format not being recognized or supported, or because of
                  corrupted/unexpected/inconsistent data, then, on the main
                  thread's event loop:
                    <ol>
                      <li>Let <var>error</var> be a <code>DOMException</code>
                      whose name is <code>"EncodingError"</code>.
                      </li>
                      <li>Reject <var>promise</var> with <var>error</var>.
                      </li>
                      <li>If <dfn id="dfn-errorcallback" data-dfn-type="dfn">errorCallback</dfn> is not missing, invoke
                      <a data-link-type="dfn" class="internalDFN" href="#dfn-errorcallback">errorCallback</a> with <var>error</var>.
                      </li>
                    </ol>
                  </li>
                  <li>Otherwise:
                    <ol>
                      <li>Take the result, representing the decoded linear PCM
                      audio data, and resample it to the sample-rate of the
                        <code>AudioContext</code> if it is different from
                        the sample-rate of audioData.
                      </li>
                      <li>On the main thread's event loop:
                        <ol>
                          <li>Let <var>buffer</var> be an
                          <code>AudioBuffer</code> containing the final result
                          (after possibly sample-rate converting).
                          </li>
                          <li>Resolve <var>promise</var> with
                          <var>buffer</var>.
                          </li>
                          <li>If <dfn id="dfn-successcallback" data-dfn-type="dfn">successCallback</dfn> is not missing,
                          invoke <a data-link-type="dfn" class="internalDFN" href="#dfn-successcallback">successCallback</a> with <var>buffer</var>.
                          </li>
                        </ol>
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">audioData</td><td class="prmType"><code>ArrayBuffer</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                An ArrayBuffer containing compressed audio data
              </td></tr><tr><td class="prmName">successCallback</td><td class="prmType"><code><a class="idlType" href="#idl-def-DecodeSuccessCallback"><code>DecodeSuccessCallback</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                A callback function which will be invoked when the decoding is
                finished. The single argument to this callback is an
                AudioBuffer representing the decoded PCM audio data.
              </td></tr><tr><td class="prmName">errorCallback</td><td class="prmType"><code><a class="idlType" href="#idl-def-DecodeErrorCallback"><code>DecodeErrorCallback</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                A callback function which will be invoked if there is an error
                decoding the audio file.
              </td></tr></tbody></table><div><em>Return type: </em><code>Promise&lt;<a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>&gt;</code></div>
            </dd>-->

            <dd>
              ArrayBuffer 内にあるオーディオファイルのデータを非同期にデコードします。 ArrayBuffer は、例えば XMLHttpRequest で <code>responseType</code> に "arraybuffer" を指定した場合の <code>response</code> 属性としてロードされます。
              オーディオファイルデータは <code>audio</code> または <code>video</code> 要素でサポートされるどのフォーマットでも構いません。
              <a href="#widl-BaseAudioContext-decodeAudioData-Promise-AudioBuffer--ArrayBuffer-audioData-DecodeSuccessCallback-successCallback-DecodeErrorCallback-errorCallback">
              decodeAudioData</a> に渡されるバッファは [<cite><a href="#bib-mimesniff" class="bibref">mimesniff</a></cite>] で説明される手順で判定されるコンテントタイプを持ちます。
            <p>
              この関数の基本的なインターフェースの手段は戻り値の Promise ではありますが、歴史的な理由からコールバックのパラメータも提供されています。システムは Promise がリゾルブまたはリジェクト、またコールバック関数が呼ばれて完了する前に <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> がガベージコレクションされない事を保証しなくてはなりません。
            </p>
            <p>
              次のステップが実行されなくてはなりません:
            </p>
            <ol>
              <li><var>promise</var> を新しい Promise とします。
              </li>
              <li>もし、audioData が null または正常な arrayBuffer でない場合:
                <ol>
                  <li><var>error</var> を <code>NotSupportedError</code> という名前の <code>DOMException</code> とします。
                  </li>
                  <li><var>promise</var> を <var>error</var> でリジェクトします。
                  </li>
                  <li>もし、<a data-link-type="dfn" class="internalDFN" href="#dfn-errorcallback">errorCallback</a> があれば、<var>error</var> を持って <a data-link-type="dfn" class="internalDFN" href="#dfn-errorcallback">errorCallback</a> を呼び出します。
                  </li>
                  <li>このアルゴリズムを終了します。
                  </li>
                </ol>
              </li>
              <li>これ以降 JavaScript からアクセスや変更ができないように audioData の ArrayBuffer を中立化します。
              </li>
              <li>デコード処理が別のスレッドで実行されるようにキューに登録します。
              </li>
              <li><var>promise</var> を返却します。
              </li>
              <li>デコードスレッドで:
                <ol>
                  <li>エンコードされている audioData をリニア PCM にデコードを試みます。
                  </li>
                  <li>もしオーディオフォーマットが認識できない、サポートされていない、あるいはデータが破壊/不正/一貫していないという理由でデコードエラーが発生した場合、メインスレッドのイベントループで:
                    <ol>
                      <li><var>error</var> を <code>"EncodingError"</code> という名前の <code>DOMException</code> とします。
                      </li>
                      <li><var>promise</var> を <var>error</var> を持ってリジェクトします。
                      </li>
                      <li>もし <dfn id="dfn-errorcallback" data-dfn-type="dfn">errorCallback</dfn> があれば、<var>error</var> を持って <a data-link-type="dfn" class="internalDFN" href="#dfn-errorcallback">errorCallback</a> を呼び出します。
                      </li>
                    </ol>
                  </li>
                  <li>それ以外の場合:
                    <ol>
                      <li>リニア PCM で表現され、もし audioData のサンプルレートが <code>AudioContext</code> のサンプルレートと異なっていた場合はリサンプルされたオーディオデータをデコード結果として受け取ります。
                      </li>
                      <li>メインスレッドのイベントループで:
                        <ol>
                          <li><var>buffer</var> を最終的な結果(必要ならサンプルレート変換を行った後)を保持した <code>AudioBuffer</code> とします。
                          </li>
                          <li><var>promise</var> を <var>buffer</var> を持ってリゾルブします。
                          </li>
                          <li>もし <dfn id="dfn-successcallback" data-dfn-type="dfn">successCallback</dfn> があれば、<var>buffer</var> を持って <a data-link-type="dfn" class="internalDFN" href="#dfn-successcallback">successCallback</a> を呼び出します。
                          </li>
                        </ol>
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">audioData</td><td class="prmType"><code>ArrayBuffer</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
              圧縮されたオーディオデータを含む ArrayBuffer です
              </td></tr><tr><td class="prmName">successCallback</td><td class="prmType"><code><a class="idlType" href="#idl-def-DecodeSuccessCallback"><code>DecodeSuccessCallback</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                デコードが完了した時に呼び出されるコールバック関数です。コールバック関数の引数は1つでデコードされた PCM オーディオデータをあらわす AudioBuffer になります。
              </td></tr><tr><td class="prmName">errorCallback</td><td class="prmType"><code><a class="idlType" href="#idl-def-DecodeErrorCallback"><code>DecodeErrorCallback</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                オーディオファイルをデコード中にエラーが起こった場合に呼び出されるコールバック関数です。
              </td></tr></tbody></table><div><em>戻り値: </em><code>Promise&lt;<a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>&gt;</code></div>
            </dd>
            <dt id="widl-BaseAudioContext-resume-Promise-void"><code>resume</code></dt>
<!--            <dd>
            <p>
              Resumes the progression of the
              <a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a>'s <a href="#widl-BaseAudioContext-currentTime">currentTime</a> in an audio
              context that has been suspended, which may involve re-priming the
              frame buffer contents. The promise resolves when the system has
              re-acquired (if necessary) access to audio hardware and has begun
              streaming to the destination, or immediately (with no other
              effect) if the context is already running. The promise is
              rejected if the context has been closed. If the context is not
              currently suspended, the promise will resolve.
            </p>
            <p>
              Note that until the first block of audio has been rendered
              following a call to this method, <a href="#widl-BaseAudioContext-currentTime">currentTime</a> remains
              unchanged.
            </p>
          <div><em>No parameters.</em></div><div><em>Return type: </em><code>Promise&lt;void&gt;</code></div>
        </dd>-->
        <dd>
        <p>
          サスペンド状態にある <a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a> の <a href="#widl-BaseAudioContext-currentTime">currentTime</a> の進行を再開し、フレームバッファの内容を再度送り出します。
          Promise はシステムが(必要なら)オーディオハードウェアへのアクセスを再度得て、ディスティネーションへのストリーミングを開始した時、あるいは、もしコンテキストが既に実行状態なら(副作用なく)即時にリゾルブされます。
          Promise はもしコンテキストがクローズされている場合
          リジェクトされます。もしコンテキストが現在サスペンド状態でない場合 Promise はリゾルブされます。
        </p>
        <p>
          このメソッドの呼び出しの後、オーディオの最初のブロックがレンダリングされるまで <a href="#widl-BaseAudioContext-currentTime">currentTime</a> は変化しない事に注意してください。
        </p>
      <div><em>パラメータなし</em></div><div><em>戻り値: </em><code>Promise&lt;void&gt;</code></div>
    </dd>
        <dt id="widl-BaseAudioContext-suspend-Promise-void"><code>suspend</code></dt>
<!--        <dd>
            <p>
              Suspends the progression of
              <a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a>'s <a href="#widl-BaseAudioContext-currentTime">currentTime</a>, allows any
              current context processing blocks that are already processed to
              be played to the destination, and then allows the system to
              release its claim on audio hardware. This is generally useful
              when the application knows it will not need the
              <a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a> for some time, and wishes to let the
              audio hardware power down. The promise resolves when the frame
              buffer is empty (has been handed off to the hardware), or
              immediately (with no other effect) if the context is already
              suspended. The promise is rejected if the context has been
              closed.
            </p>
            <p>
              While the system is suspended, MediaStreams will have their
              output ignored; that is, data will be lost by the real time
              nature of media streams. HTMLMediaElements will similarly have
              their output ignored until the system is resumed. Audio Workers
              and ScriptProcessorNodes will simply not fire their
              onaudioprocess events while suspended, but will resume when
              resumed. For the purpose of AnalyserNode window functions, the
              data is considered as a continuous stream - i.e. the
              resume()/suspend() does not cause silence to appear in the
              AnalyserNode's stream of data.
            </p>
          <div><em>No parameters.</em></div><div><em>Return type: </em><code>Promise&lt;void&gt;</code></div>
        </dd>-->
        <dd>
            <p>
              <a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a> の<a href="#widl-BaseAudioContext-currentTime">currentTime</a> の進行をサスペンドします。現在既にディスティネーションに送り出すために処理されているブロックの処理は許可され、システムはオーディオハードウェアの使用を解放します。これは一般的にアプリケーションが <a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a> をしばらく使用しない事がわかっていて、オーディオハードウェアのパワーダウンを行いたい場合に有用です。
              Promise はフレームバッファが空になった(ハードウェアに渡し終えた)時か、もしコンテキストが既にサスペンド状態にあれば(副作用なく)即時にリゾルブされます。 Promise はもしコンテキストがクローズされていればリジェクトされます。
            </p>
            <p>
              システムがサスペンドされている間、 MediaStream は出力が無視されます---つまりメディアストリームのリアルタイム性によってデータが失われる事になります。 HTMLMediaElement も同様にシステムが resume されるまで出力が無視されます。
              AudioWorker と ScriptProcessorNode は単純に onaudioprocess イベントが発行されなくなりますが、resume された時には復帰します。
              AnalyserNode ではウィンドウ関数の目的から、データは継続的に流れているものとみなされます - つまり resume() / suspend() は AnalyserNode のデータストリームに無音状態を作りません。
            </p>
          <div><em>パラメータなし</em></div><div><em>戻り値: </em><code>Promise&lt;void&gt;</code></div>
        </dd>
      </dl></section>
        <section property="bibo:hasPart" resource="#callback-decodesuccesscallback-parameters" typeof="bibo:Chapter" id="callback-decodesuccesscallback-parameters"><h4 resource="#h-callback-decodesuccesscallback-parameters" id="h-callback-decodesuccesscallback-parameters"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.1.3 </span>Callback <a href="#idl-def-DecodeSuccessCallback" class="idlType"><code>DecodeSuccessCallback</code></a> パラメータ</span></h4><dl class="callback-members"><dt id="widl-DecodeSuccessCallback-decodedData"><code>decodedData</code> <span class="idlMemberType"><a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a></span>型</dt>
<!--          <dd>
            The AudioBuffer containing the decoded audio data.
          </dd>-->
          <dd>
            デコードされたオーディオデータを保持する AudioBuffer です。
          </dd>
        </dl></section>
        <section property="bibo:hasPart" resource="#callback-decodeerrorcallback-parameters" typeof="bibo:Chapter" id="callback-decodeerrorcallback-parameters"><h4 resource="#h-callback-decodeerrorcallback-parameters" id="h-callback-decodeerrorcallback-parameters"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.1.4 </span>Callback <a href="#idl-def-DecodeErrorCallback" class="idlType"><code>DecodeErrorCallback</code></a> パラメータ</span></h4><dl class="callback-members"><dt id="widl-DecodeErrorCallback-error"><code>error</code> <span class="idlMemberType">DOMException　型</span></dt>
<!--          <dd>
            The error that occurred while decoding.
          </dd>-->
          <dd>
            デコード中に発生したエラーです。
          </dd>
        </dl></section>
        <section property="bibo:hasPart" resource="#dictionary-audiocontextoptions-members" typeof="bibo:Chapter" id="dictionary-audiocontextoptions-members"><h4 resource="#h-dictionary-audiocontextoptions-members" id="h-dictionary-audiocontextoptions-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.1.5 </span>ディレクトリ <a href="#idl-def-AudioContextOptions" class="idlType"><code>AudioContextOptions</code></a> メンバー</span></h4><dl class="dictionary-members"><dt id="widl-AudioContextOptions-playbackCategory"><code>playbackCategory</code> <span class="idlMemberType"><a class="idlType" href="#idl-def-AudioContextPlaybackCategory"><code>AudioContextPlaybackCategory　型</code></a></span>, デフォルトは <code>"interactive"</code></dt>
<!--          <dd>
            Identify the type of playback, which affects tradeoffs between
            audio output latency and power consumption.
          </dd>-->
          <dd>
            オーディオ出力のレイテンシーと消費電力のバランスに影響する再生のタイプを識別します。
          </dd>
        </dl></section>
        <section property="bibo:hasPart" resource="#lifetime-AudioContext" typeof="bibo:Chapter">
          <h4 resource="#lifetime-AudioContext" id="lifetime-AudioContext" class="informative"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.1.6 </span>
            ライフタイム
          </span></h4>
<!--          <p>
            Once created, an <code>AudioContext</code> will continue to play
            sound until it has no more sound to play, or the page goes away.
          </p>-->
          <p>
            <code>AudioContext</code> は一度作成された後、これ以上再生する音がなくなるまで、あるいはページを移動するまで再生を続けます。
          </p>
        </section>
        <section property="bibo:hasPart" resource="#lack-of-introspection-or-serialization-primitives" typeof="bibo:Chapter" id="lack-of-introspection-or-serialization-primitives" class="informative">
          <h4 resource="#h-lack-of-introspection-or-serialization-primitives" id="h-lack-of-introspection-or-serialization-primitives"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.1.7 </span>
            内部検査やシリアライゼーションの基本機能の欠如
          </span></h4><p><em>このセクションは参考情報です</em></p>
<!--          <p>
            The Web Audio <abbr title="Application Programming Interface">API</abbr> takes a <em>fire-and-forget</em> approach to
            audio source scheduling. That is, <a data-link-type="dfn" class="internalDFN" href="#dfn-source-nodes">source nodes</a> are created
            for each note during the lifetime of the <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>, and
            never explicitely removed from the graph. This is incompatible with
            a serialization <abbr title="Application Programming Interface">API</abbr>, since there is no stable set of nodes that
            could be serialized.
          </p>-->
          <p>
            Web Audio <abbr title="Application Programming Interface">API</abbr> は音源のスケジューリングに <em>fire-and-forget</em> アプローチを取っています。つまり、<a data-link-type="dfn" class="internalDFN" href="#dfn-source-nodes">音源ノード</a>は、 <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> のライフタイムの間の1つひとつの音に対応して作成され、明示的にグラフからの削除は行いません。これはシリアライゼーション <abbr title="Application Programming Interface">API</abbr> とは互換性がなく、そのためシリアライズ可能な固定的なノードのセットもありません。
          </p>
<!--          <p>
            Moreover, having an introspection <abbr title="Application Programming Interface">API</abbr> would allow content script to
            be able to observe garbage collections.
          </p>-->
          <p>
            更に、内部検査のための <abbr title="Application Programming Interface">API</abbr> を持つためにはスクリプトの中身のガベージコレクションの監視が必要になります。
          </p>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#AudioContext" typeof="bibo:Chapter">
        <h3 resource="#AudioContext" id="AudioContext"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.2 </span>
          AudioContext インターフェース
        </span></h3>
<!--        <p>
          This interface represents an audio graph whose
          <a class="idlType" href="#idl-def-AudioDestinationNode"><code>AudioDestinationNode</code></a> is routed to a real-time
          output device that produces a signal directed at the user. In most
          use cases, only a single <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> is used per
          document.
        </p>-->
        <p>
          このインターフェースは、その <a class="idlType" href="#idl-def-AudioDestinationNode"><code>AudioDestinationNode</code></a> がデバイスへのリアルタイム出力によって直接ユーザーに信号が届くオーディオグラフを表します。多くの場合、１つのドキュメントにつき1つの <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> が使用されます。
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-AudioContext">interface <span class="idlInterfaceID">AudioContext</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a></span> {
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-MediaElementAudioSourceNode"><code>MediaElementAudioSourceNode</code></a></span>     <span class="idlMethName"><a href="#widl-AudioContext-createMediaElementSource-MediaElementAudioSourceNode-HTMLMediaElement-mediaElement">createMediaElementSource</a></span> (<span class="idlParam"><span class="idlParamType">HTMLMediaElement</span> <span class="idlParamName">mediaElement</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-MediaStreamAudioSourceNode"><code>MediaStreamAudioSourceNode</code></a></span>      <span class="idlMethName"><a href="#widl-AudioContext-createMediaStreamSource-MediaStreamAudioSourceNode-MediaStream-mediaStream">createMediaStreamSource</a></span> (<span class="idlParam"><span class="idlParamType">MediaStream</span> <span class="idlParamName">mediaStream</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-MediaStreamAudioDestinationNode"><code>MediaStreamAudioDestinationNode</code></a></span> <span class="idlMethName"><a href="#widl-AudioContext-createMediaStreamDestination-MediaStreamAudioDestinationNode">createMediaStreamDestination</a></span> ();</span>
};</span></pre><section property="bibo:hasPart" resource="#methods-1" typeof="bibo:Chapter" id="methods-1"><h4 resource="#h-methods-1" id="h-methods-1"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.2.1 </span>メソッド</span></h4><dl class="methods"><dt id="widl-AudioContext-createMediaElementSource-MediaElementAudioSourceNode-HTMLMediaElement-mediaElement"><code>createMediaElementSource</code></dt>
<!--  <dd>
    Creates a <a href="#MediaElementAudioSourceNode">MediaElementAudioSourceNode</a>
    given an HTMLMediaElement. As a consequence of calling this method,
    audio playback from the HTMLMediaElement will be re-routed into the
    processing graph of the <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>.

  <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">mediaElement</td><td class="prmType"><code>HTMLMediaElement</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
        The media element that will be re-routed.
      </td></tr></tbody></table><div><em>Return type: </em><code><a class="idlType" href="#idl-def-MediaElementAudioSourceNode"><code>MediaElementAudioSourceNode</code></a></code></div>
  </dd>-->
  <dd>
    与えられた HTMLMediaElement の <a href="#MediaElementAudioSourceNode">MediaElementAudioSourceNode</a> を作成します。
    このメソッドの呼び出しの結果、 HTMLMediaElement からのオーディオの再生は <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> の処理グラフにリルートされるようになります。

  <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">mediaElement</td><td class="prmType"><code>HTMLMediaElement</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td>
    <td class="prmDesc">
      リルートされるメディアエレメントです。
    </td>
  </tr></tbody></table><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-MediaElementAudioSourceNode"><code>MediaElementAudioSourceNode</code></a></code></div>
  </dd>
          <dt id="widl-AudioContext-createMediaStreamDestination-MediaStreamAudioDestinationNode"><code>createMediaStreamDestination</code></dt>
<!--          <dd>
              Creates a <a class="idlType" href="#idl-def-MediaStreamAudioDestinationNode"><code>MediaStreamAudioDestinationNode</code></a>
            <div><em>No parameters.</em></div><div><em>Return type: </em><code><a class="idlType" href="#idl-def-MediaStreamAudioDestinationNode"><code>MediaStreamAudioDestinationNode</code></a></code></div>
          </dd>-->
          <dd>
            <a class="idlType" href="#idl-def-MediaStreamAudioDestinationNode"><code>MediaStreamAudioDestinationNode</code></a> を作成します。
            <div><em>パラメータなし</em></div><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-MediaStreamAudioDestinationNode"><code>MediaStreamAudioDestinationNode</code></a></code></div>
          </dd>
        <dt id="widl-AudioContext-createMediaStreamSource-MediaStreamAudioSourceNode-MediaStream-mediaStream"><code>createMediaStreamSource</code></dt><dd>

          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">mediaStream</td><td class="prmType"><code>MediaStream</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
              音源となるメディアストリームです。
            </td></tr></tbody></table><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-MediaStreamAudioSourceNode"><code>MediaStreamAudioSourceNode</code></a></code></div></dd></dl></section>
      </section>
      <section property="bibo:hasPart" resource="#OfflineAudioContext" typeof="bibo:Chapter">
        <h3 resource="#OfflineAudioContext" id="OfflineAudioContext"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.3 </span>
          OfflineAudioContext インターフェース
        </span></h3>
<!--        <p>
          <a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a> is a particular type of
          <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> for rendering/mixing-down
          (potentially) faster than real-time. It does not render to the audio
          hardware, but instead renders as quickly as possible, fulfilling the
          returned promise with the rendered result as an
          <code>AudioBuffer</code>.
        </p>-->
        <p>
          <a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a> はレンダリング/ミックスダウンで使用される特殊な <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> であり、(可能性としては)リアルタイムよりも高速に動作します。 それはオーディオハードウェアに出力しない代わりに可能な限り高速に動作して、 Promise にレンダリング結果を <code>AudioBuffer</code> として戻します。
        </p>
<!--        <p>
          The OfflineAudioContext is constructed with the same arguments as
          AudioContext.createBuffer. A NotSupportedException exception <em title="MUST" class="rfc2119">MUST</em> be
          thrown if any of the arguments is negative, zero, or outside its
          nominal range.
        </p>-->
        <p>
          OfflineAudioContext は AudioContext.CreateBuffer と同じ引数で作成されます。
          もし引数のどれかが負の値、0、あるいは範囲外であった場合は NotSupportedException 例外を発生します<em title="MUST" class="rfc2119">MUST</em>。
        </p>
        <dl class="parameters">
          <dt>
            unsigned long numberOfChannels
          </dt>
          <dd class="orig">
            Determines how many channels the buffer will have. See <a href="#widl-BaseAudioContext-createBuffer-AudioBuffer-unsigned-long-numberOfChannels-unsigned-long-length-float-sampleRate">
            createBuffer</a> for the supported number of channels.
          </dd>
          <dd>
            バッファが幾つのチャンネルを持つかを指定します。サポートされるチャンネル数については
            <a href="#widl-BaseAudioContext-createBuffer-AudioBuffer-unsigned-long-numberOfChannels-unsigned-long-length-float-sampleRate">
            createBuffer</a>を参照してください。
          </dd>
          <dt>
            unsigned long length
          </dt>
          <dd class="orig">
            Determines the size of the buffer in sample-frames.
          </dd>
          <dd>
            バッファのサイズをサンプルフレーム数で指定します。
          </dd>
          <dt>
            float sampleRate
          </dt>
          <dd class="orig">
            Describes the sample-rate of the linear PCM audio data in the
            buffer in sample-frames per second. See <a href="#widl-BaseAudioContext-createBuffer-AudioBuffer-unsigned-long-numberOfChannels-unsigned-long-length-float-sampleRate">
            createBuffer</a> for valid sample rates.
          </dd>
          <dd>
            バッファ内のリニア PCM のオーディオデータのサンプルレートを毎秒のサンプルフレーム数で記述します。
            使用できるサンプルレートについては <a href="#widl-BaseAudioContext-createBuffer-AudioBuffer-unsigned-long-numberOfChannels-unsigned-long-length-float-sampleRate">
            createBuffer</a> を参照してください。
          </dd>
        </dl>
        <pre class="idl"><span class="idlInterface" id="idl-def-OfflineAudioContext">[<span class="extAttr">Constructor(unsigned long numberOfChannels, unsigned long length, float sampleRate)</span>]
interface <span class="idlInterfaceID">OfflineAudioContext</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a></span> {
<span class="idlMethod">    <span class="idlMethType">Promise&lt;<a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>&gt;</span> <span class="idlMethName"><a href="#widl-OfflineAudioContext-startRendering-Promise-AudioBuffer">startRendering</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType">Promise&lt;void&gt;</span>        <span class="idlMethName"><a href="#widl-OfflineAudioContext-resume-Promise-void">resume</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType">Promise&lt;void&gt;</span>        <span class="idlMethName"><a href="#widl-OfflineAudioContext-suspend-Promise-void--double-suspendTime">suspend</a></span> (<span class="idlParam"><span class="idlParamType">double</span> <span class="idlParamName">suspendTime</span></span>);</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-OfflineAudioContext-oncomplete">oncomplete</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-1" typeof="bibo:Chapter" id="attributes-1"><h4 resource="#h-attributes-1" id="h-attributes-1"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.3.1 </span>属性</span></h4><dl class="attributes"><dt id="widl-OfflineAudioContext-oncomplete"><code>oncomplete</code> <span class="idlAttrType">EventHandler　型</span></dt><dd>
  <p class="orig">
    An EventHandler of type <a href="#OfflineAudioCompletionEvent">OfflineAudioCompletionEvent</a>.
  </p>
  <p>
    <a href="#OfflineAudioCompletionEvent">OfflineAudioCompletionEvent</a> 型のイベントハンドラーです。
  </p>
</dd></dl></section><section property="bibo:hasPart" resource="#methods-2" typeof="bibo:Chapter" id="methods-2"><h4 resource="#h-methods-2" id="h-methods-2"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.3.2 </span>メソッド</span></h4><dl class="methods"><dt id="widl-OfflineAudioContext-resume-Promise-void"><code>resume</code></dt><dd>
  <p class="orig">
    Resumes the progression of time in an audio context that has been
    suspended. The promise resolves immediately because the
    <a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a> does not require the
    audio hardware. If the context is not currently suspended or the
    rendering has not started, the promise is rejected with
    <code>InvalidStateError</code>.
  </p>
  <p>
    サスペンド状態のオーディオコンテキストの進行を再開します。
    <a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a> はオーディオハードウェアを必要としないため、 Promise は即時にリゾルブされます。もしコンテキストが現在サスペンド状態でない、あるいはレンダリングがまだ開始されていない場合、 Promise は <code>InvalidStateError</code> でリジェクトされます。
  </p>
  <p class="orig">
    In contrast to a live <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>, the value
    of <a href="#widl-BaseAudioContext-currentTime">currentTime</a>
    always reflects the start time of the next block to be rendered
    by the audio graph, since the context's audio stream does not
    advance in time during suspension.
  </p>
  <p>
    ライブ情報を扱う <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> とは違い、サスペンド状態の間コンテキストのオーディオストリームが進まないため、 <a href="#widl-BaseAudioContext-currentTime">currentTime</a> の値は常にオーディオグラフによって次にレンダリングされるブロックの先頭時間を指します。
  </p>
          <div><em>パラメータなし</em></div><div><em>戻り値: </em><code>Promise&lt;void&gt;</code></div></dd><dt id="widl-OfflineAudioContext-startRendering-Promise-AudioBuffer"><code>startRendering</code></dt><dd>
            <p class="orig">
              Given the current connections and scheduled changes, starts
              rendering audio. The system shall ensure that the
              <code>OfflineAudioContext</code> is not garbage collected until
              either the promise is resolved and any callback function is
              called and completes, or until the <code>suspend</code> function
              is called.
            </p>
            <p>
              与えられた現在の接続とスケジュールされたオートメーションでオーディオのレンダリングを開始します。システムは Promise がリゾルブされコールバック関数が呼び出されるまで、あるいは <code>suspend</code> 関数が呼び出されるまで <code>OfflineAudioContext</code> がガベージコレクションされない事を保証します。
            </p>
            <p class="orig">
              Although the primary method of getting the rendered audio data is
              via its promise return value, the instance will also fire an
              event named <code>complete</code> for legacy reasons.
            </p>
            <p>
              オーディオデータのレンダリング結果を得る基本的なメソッドは Promise の戻り値ですが、歴史的な理由によりこのインスタンスは <code>complete</code> という名前のイベントも発行します。
            </p>
            <p class="orig">
              The following steps must be performed:
            </p>
            <p>
              次のステップが実行されなくてはなりません:
            </p>
            <ol class="orig">
              <li>If <code>startRendering</code> has already been called
              previously, then return a promise rejected with
              <code>InvalidStateError</code>.
              </li>
              <li>Let <var>promise</var> be a new promise.
              </li>
              <li>Asynchronously perform the following steps:
                <ol>
                  <li>Let <var>buffer</var> be a new <code>AudioBuffer</code>,
                  with a number of channels, length and sample rate equal
                  respectively to the <code>numberOfChannels</code>,
                  <code>length</code> and <code>sampleRate</code> parameters
                  used when this instance's constructor was called.
                  </li>
                  <li>Given the current connections and scheduled changes,
                  start rendering <code>length</code> sample-frames of audio
                  into <var>buffer</var>.
                  </li>
                  <li>For every render quantum, check and suspend the rendering
                  if necessary.
                  </li>
                  <li>If a suspended context is resumed, continue to render the
                  buffer.
                  </li>
                  <li>Once the rendering is complete,
                    <ol>
                      <li>Resolve <var>promise</var> with <var>buffer</var>.
                      </li>
                      <li>Queue a task to fire an event named
                      <code>complete</code> at this instance, using an instance
                      of <a class="idlType" href="#idl-def-OfflineAudioCompletionEvent"><code>OfflineAudioCompletionEvent</code></a> whose
                      <code>renderedBuffer</code> property is set to
                      <var>buffer</var>.
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li>Return <var>promise</var>.
              </li>
            </ol>

            <ol>
              <li>もし、 <code>startRendering</code> が既に呼ばれている場合、 Promise は <code>InvalidStateError</code> でリジェクトされます。
              </li>
              <li><var>promise</var> を新しい Promise とします。
              </li>
              <li>非同期に次のステップを実行します:
                <ol>
                  <li>このインスタンスのコンストラクタが呼ばれた時の <code>numberOfChannels</code> をチャンネル数、 <code>length</code> を長さ、 <code>sampleRate</code> をサンプルレートとした新しい <code>AudioBuffer</code> を <var>buffer</var> とします。
                  </li>
                  <li>現在の接続とスケジューリングで <code>length</code> のサンプルフレーム数のオーディオを <var>buffer</var> にレンダリング開始します。
                  </li>
                  <li>必要があればレンダリングを行うブロック毎にチェックとサスペンドを行います。
                  </li>
                  <li>もしサスペンド状態のコンテキストが再開した場合、バッファへのレンダリングを再開します。
                  </li>
                  <li>レンダリングが完了した時、
                    <ol>
                      <li><var>promise</var> を <var>buffer</var> でリゾルブします。
                      </li>
                      <li><a class="idlType" href="#idl-def-OfflineAudioCompletionEvent"><code>OfflineAudioCompletionEvent</code></a> のインスタンスで <code>complete</code> という名前のイベントを発行するためにキューに入れ、その <code>renderedBuffer</code> プロパティに <var>buffer</var> をセットします。
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li><var>promise</var> を戻します。
              </li>
            </ol>


          <div><em>パラメータなし</em></div><div><em>戻り値: </em><code>Promise&lt;<a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>&gt;</code></div></dd><dt id="widl-OfflineAudioContext-suspend-Promise-void--double-suspendTime"><code>suspend</code></dt><dd>
<!--            <p>
              Schedules a suspension of the time progression in the audio
              context at the specified time and returns a promise. This is
              generally useful when manipulating the audio graph synchronously
              on <a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a>.
            </p>-->
            <p>
              オーディオコンテキストの時間の進行を指定の時刻にサスペンドする事をスケジューリングし、 Promise を返します。
              これは一般的に <a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a> 上でオーディオグラフを同期的に操作するために役立ちます。
            </p>
<!--            <p>
              Note that the maximum precision of suspension is the size of the
              render quantum and the specified suspension time will be rounded
              down to the nearest render quantum boundary. For this reason, it
              is not allowed to schedule multiple suspends at the same
              quantized frame. Also scheduling should be done while the context
              is not running to ensure the precise suspension.
            </p>-->
            <p>
              サスペンドの最大の精度はレンダリング処理の分割のサイズであり、指定されたサスペンド時刻は最も近い分割の境界に丸められる事に注意してください。このため、同じ分割フレーム内に複数のサスペンドをスケジューリングする事はできません。また、スケジューリングはコンテキストが高精度のサスペンドを保証しない実行を行っている間に行わなくてはなりません。
            </p>

          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">suspendTime</td><td class="prmType"><code>double</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
<!--            <p>Schedules a suspension of the rendering at the specified time,
              which is quantized and rounded down to the render quantum size.
              If the quantized frame number
            </p>-->
            <p>レンダリングのサスペンドをスケジュールする時刻。これはレンダリングの分割サイズの境界に丸められます。
              もし丸められた結果のフレーム数が、
            </p>
                <ol>
                  <li>負の値
                  </li>
                  <li>現在の時刻より小さいまたは同じ
                  </li>
                  <li>レンダリングのトータルの長さより大きいか同じ
                  </li>
                  <li>他のサスペンドのスケジューリングと同じ時刻
                  </li>
                </ol>の場合は、 Promise は <code>InvalidStateError</code> でリジェクトされます。
              </td></tr></tbody></table><div><em>戻り値: </em><code>Promise&lt;void&gt;</code></div></dd></dl></section>
        <pre class="idl"><span class="idlInterface" id="idl-def-AudioContext-1">[<span class="extAttr">Constructor</span>]
interface <span class="idlInterfaceID">AudioContext</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a></span> {
};</span></pre>
        <section property="bibo:hasPart" resource="#OfflineAudioCompletionEvent" typeof="bibo:Chapter">
          <h4 resource="#OfflineAudioCompletionEvent" id="OfflineAudioCompletionEvent"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.3.3 </span>
            OfflineAudioCompletionEvent インターフェース
          </span></h4>
<!--          <p>
            This is an <code>Event</code> object which is dispatched to
            <a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a> for legacy reasons.
          </p>-->
          <p>これは <a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a> に対して歴史的な理由により、ディスパッチされる <code>Event</code> です。
          </p>
          <pre class="idl"><span class="idlInterface" id="idl-def-OfflineAudioCompletionEvent">interface <span class="idlInterfaceID">OfflineAudioCompletionEvent</span> : <span class="idlSuperclass">Event</span> {
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a></span> <span class="idlAttrName"><a href="#widl-OfflineAudioCompletionEvent-renderedBuffer">renderedBuffer</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-2" typeof="bibo:Chapter" id="attributes-2"><h5 resource="#h-attributes-2" id="h-attributes-2"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.3.3.1 </span>属性</span></h5><dl class="attributes"><dt id="widl-OfflineAudioCompletionEvent-renderedBuffer"><code>renderedBuffer</code>  <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer　型</code></a></span>, readonly       </dt><dd>
<!--  <p>
    An <code>AudioBuffer</code> containing the rendered audio data.
  </p>-->
  <p>
    レンダリングされたオーディオデータを保持する <code>AudioBuffer</code> です。
  </p>
            </dd></dl></section>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#the-audionode-interface" typeof="bibo:Chapter" id="the-audionode-interface">
        <h3 resource="#h-the-audionode-interface" id="h-the-audionode-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.4 </span>
          <dfn id="dfn-audionode" data-dfn-type="dfn">AudioNode</dfn> インターフェース
        </span></h3>
<!--        <p>
          AudioNodes are the building blocks of an <a href="#AudioContext"><code>AudioContext</code></a>. This interface
          represents audio sources, the audio destination, and intermediate
          processing modules. These modules can be connected together to form
          <a href="#ModularRouting">processing graphs</a> for rendering audio
          to the audio hardware. Each node can have <a data-link-type="dfn" class="internalDFN" href="#dfn-inputs">inputs</a> and/or
          <a data-link-type="dfn" class="internalDFN" href="#dfn-outputs">outputs</a>. A <a data-link-type="dfn" class="internalDFN" href="#dfn-source-node">source node</a> has no inputs and a single
          output. An <a href="#AudioDestinationNode"><code>AudioDestinationNode</code></a> has one
          input and no outputs and represents the final destination to the
          audio hardware. Most processing nodes such as filters will have one
          input and one output. Each type of <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>
          differs in the details of how it processes or synthesizes audio. But,
          in general, an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> will process its inputs
          (if it has any), and generate audio for its outputs (if it has any).
        </p>-->
        <p>
          AudioNode は <a href="#AudioContext"><code>AudioContext</code></a> の構成ブロックです。
          このインターフェースはオーディオのソース、出力先、中間の処理モジュールを表しています。これらのモジュールは互いに接続されて、 音をオーディオハードウェアに出力するための<a href="#ModularRouting">処理グラフ</a>を形成します。 それぞれのノードは<a data-link-type="dfn" class="internalDFN" href="#dfn-inputs">入力</a>や<a data-link-type="dfn" class="internalDFN" href="#dfn-outputs">出力</a>を持つ事ができます。 <a data-link-type="dfn" class="internalDFN" href="#dfn-source-node">ソースノード</a>は入力を持たず、単一の出力を持ちます。
          <a href="#AudioDestinationNode"><code>AudioDestinationNode</code></a> は 単一の入力を持ち、出力を持たず、オーディオハードウェアへの最終的な出力地点を表しています。
          フィルターのような殆どの処理ノードは1つの入力と1つの出力を持ちます。
          それぞれのタイプの <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> はどのようにオーディオを処理したり合成したりするかの詳細が異なっています。 しかし、一般的に AudioNode は(持っていれば)その入力を処理し、(持っていれば)その出力にオーディオ信号を送り出します。
        </p>
<!--        <p>
          Each output has one or more channels. The exact number of channels
          depends on the details of the specific <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>.
        </p>-->
        <p>
          それぞれの出力は1つ以上のチャンネルを持っています。正確なチャンネル数はそれぞれの <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の詳細に依存します。
        </p>
<!--        <p>
          An output may connect to one or more <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>
          inputs, thus <em>fan-out</em> is supported. An input initially has no
          connections, but may be connected from one or more <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>
          outputs, thus <em>fan-in</em> is supported. When the
          <code>connect()</code> method is called to connect an output of an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> to an input of an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>, we call that a
          <dfn id="dfn-connection" data-dfn-type="dfn">connection</dfn> to the input.
        </p>-->
        <p>
          出力は1つ以上の <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> 入力に接続でき、つまり<em>ファンアウト</em>がサポートされています。
          入力は初期化時には接続されていません。しかし、1つ以上の <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> 出力から接続する事ができ、即ち、<em>ファンイン</em>がサポートされています。
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の出力を <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の入力に接続するため <code>connect()</code> メソッドが呼ばれた時、それをその入力への<dfn id="dfn-connection" data-dfn-type="dfn">接続</dfn>と呼びます。
        </p>
<!--        <p>
          Each <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> <dfn id="dfn-input" data-dfn-type="dfn">input</dfn> has a specific number of
          channels at any given time. This number can change depending on the
          <a data-link-type="dfn" class="internalDFN" href="#dfn-connection">connection</a>(s) made to the input. If the input has no
          connections then it has one channel which is silent.
        </p>-->
        <p>
          各 <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の<dfn id="dfn-input" data-dfn-type="dfn">入力</dfn>はその時々で特定のチャンネル数を持ちます。この数はその入力への<a data-link-type="dfn" class="internalDFN" href="#dfn-connection">接続</a>によって変化します。 もし入力が接続を持っていない場合、チャンネル数は1で無音となります。

        </p>
<!--        <p>
          For each <a data-link-type="dfn" class="internalDFN" href="#dfn-input">input</a>, an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> performs a
          mixing (usually an up-mixing) of all connections to that input.
          Please see <a class="sec-ref" href="#mixer-gain-structure"><span class="secno">3.</span> <span class="sec-title">
        Mixer Gain Structure
      </span></a> for more informative
          details, and the <a class="sec-ref" href="#channel-up-mixing-and-down-mixing"><span class="secno">5.</span> <span class="sec-title">
        Channel up-mixing and down-mixing
      </span></a>
          section for normative requirements.
        </p>-->
        <p>
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a はそれぞれの<a data-link-type="dfn" class="internalDFN" href="#dfn-input">入力</a>について、その入力への接続のミックス(通常はアップミックス)を行います。 この詳細に関して参考情報としては
          <a class="sec-ref" href="#mixer-gain-structure"><span class="secno">3.</span> <span class="sec-title">ミキサーゲイン構成</span></a>
          、基準としての詳細要件については
          <a class="sec-ref" href="#channel-up-mixing-and-down-mixing"><span class="secno">5.</span> <span class="sec-title">
          チャンネルのアップミックスとダウンミックス
        </span></a>セクションを参照してください。
        </p>
<!--        <p>
          The processing of inputs and the internal operations of an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> take place continuously with respect to
          <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> time, regardless of whether the node has
          connected outputs, and regardless of whether these outputs ultimately
          reach an <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s <a class="idlType" href="#idl-def-AudioDestinationNode"><code>AudioDestinationNode</code></a>.
        </p>-->
        <p>
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の入力および内部の処理は、そのノードが出力を接続されているか、またそれらの出力が <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> の <a class="idlType" href="#idl-def-AudioDestinationNode"><code>AudioDestinationNode</code></a> に到達しているかに関わらず、 <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> の時刻を踏まえて継続的に行われます。
        </p>
        <p>
          パフォーマンス的な理由から実際の実装ではそれぞれの <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> は決まった<em>ブロックサイズ</em>のサンプルフレームをブロック単位に処理する事が必要になると思われます。
           実装による振る舞いを統一するため、この値を明示的に定めます。<em>ブロックサイズ</em>はサンプルレート44.1kHzにおいて約3msとなる128サンプルフレームとします。
        </p>
        <p>
          AudioNode は、<cite><a href="https://dom.spec.whatwg.org/">DOM</a></cite> [<cite><a href="#bib-DOM" class="bibref">DOM</a></cite>] で記述される <em>EventTarget</em> です。 これは他の EventTarget がイベントを受け取るのと同じ方法でイベントを <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> にディスパッチする事が可能である事を意味します。
        </p>
        <pre class="idl"><span class="idlEnum" id="idl-def-ChannelCountMode">enum <span class="idlEnumID">ChannelCountMode</span> {
    "<a href="#idl-def-ChannelCountMode.max" class="idlEnumItem">max</a>",
    "<a href="#idl-def-ChannelCountMode.clamped-max" class="idlEnumItem">clamped-max</a>",
    "<a href="#idl-def-ChannelCountMode.explicit" class="idlEnumItem">explicit</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">列挙値の説明</th></tr><tr><td><code id="idl-def-ChannelCountMode.max">max</code></td>
          <td>
<!--            <p>
            <a data-link-type="dfn" class="internalDFN" href="#dfn-computednumberofchannels"><code><code>computedNumberOfChannels</code></code></a> is computed as the
            maximum of the number of channels of all connections. In this mode
            channelCount is ignored
          </p>-->
            <a data-link-type="dfn" class="internalDFN" href="#dfn-computednumberofchannels"><code><code>computedNumberOfChannels</code></code></a> は全ての接続のチャンネル数の最大値として計算されます。 このモードでは channelCount は無視されます。
          </td>
        </tr><tr>
          <td>
            <code id="idl-def-ChannelCountMode.clamped-max">clamped-max</code>
          </td>
          <td>
            <!--<p>Same as “max” up to a limit of the channelCount</p>-->
            "max" と同様ですが、 channelCount を上限とします。
          </td>
        </tr><tr>
          <td><code id="idl-def-ChannelCountMode.explicit">explicit</code></td>
          <td>
<!--            <p><a data-link-type="dfn" class="internalDFN" href="#dfn-computednumberofchannels"><code><code>computedNumberOfChannels</code></code></a> is the exact value as
            specified in channelCount
          </p>-->
            <a data-link-type="dfn" class="internalDFN" href="#dfn-computednumberofchannels"><code><code>computedNumberOfChannels</code></code></a> の値は channelCount によって指定された値そのものになります。
          </td>
        </tr></tbody></table>
        <pre class="idl"><span class="idlEnum" id="idl-def-ChannelInterpretation">enum <span class="idlEnumID">ChannelInterpretation</span> {
    "<a href="#idl-def-ChannelInterpretation.speakers" class="idlEnumItem">speakers</a>",
    "<a href="#idl-def-ChannelInterpretation.discrete" class="idlEnumItem">discrete</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">列挙値の説明</th></tr><tr><td><code id="idl-def-ChannelInterpretation.speakers">speakers</code></td><td>
<!--        use <a href="#ChannelLayouts">up-down-mix equations for
            mono/stereo/quad/5.1</a>. In cases where the number of channels do
            not match any of these basic speaker layouts, revert to "discrete".-->
             <a href="#ChannelLayouts">モノラル/ステレオ/クワッド/5.1のためのアップ・ダウンミックス式</a>を使用します。 チャンネル数がこれらのスピーカー基本レイアウトに一致しない場合、 "discrete" に戻します。
          </td></tr><tr><td><code id="idl-def-ChannelInterpretation.discrete">discrete</code></td><td>
<!--            <p>
            Up-mix by filling channels until they run out then zero out
            remaining channels. down-mix by filling as many channels as
            possible, then dropping remaining channels.
          </p>-->
            アップミックスの場合、チャンネルを使い切るまで順に埋めて行き、余っているチャンネルには0を出力します。 ダウンミックスでは、可能な限りチャンネルを順に埋め、余ったチャンネルは捨てられます。
          </td></tr></tbody></table>
        <pre class="idl"><span class="idlInterface" id="idl-def-AudioNode">interface <span class="idlInterfaceID">AudioNode</span> : <span class="idlSuperclass">EventTarget</span> {
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> <span class="idlMethName"><a href="#widl-AudioNode-connect-AudioNode-AudioNode-destination-unsigned-long-output-unsigned-long-input">connect</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> <span class="idlParamName">destination</span></span>, <span class="idlParam">optional <span class="idlParamType">unsigned long</span> <span class="idlParamName">output</span> = <span class="idlDefaultValue">0
              </span></span>, <span class="idlParam">optional <span class="idlParamType">unsigned long</span> <span class="idlParamName">input</span> = <span class="idlDefaultValue">0
              </span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span>      <span class="idlMethName"><a href="#widl-AudioNode-connect-void-AudioParam-destination-unsigned-long-output">connect</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlParamName">destination</span></span>, <span class="idlParam">optional <span class="idlParamType">unsigned long</span> <span class="idlParamName">output</span> = <span class="idlDefaultValue">0
              </span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span>      <span class="idlMethName"><a href="#widl-AudioNode-disconnect-void">disconnect</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType">void</span>      <span class="idlMethName"><a href="#widl-AudioNode-disconnect-void-unsigned-long-output">disconnect</a></span> (<span class="idlParam"><span class="idlParamType">unsigned long</span> <span class="idlParamName">output</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span>      <span class="idlMethName"><a href="#widl-AudioNode-disconnect-void-AudioNode-destination">disconnect</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> <span class="idlParamName">destination</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span>      <span class="idlMethName"><a href="#widl-AudioNode-disconnect-void-AudioNode-destination-unsigned-long-output">disconnect</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> <span class="idlParamName">destination</span></span>, <span class="idlParam"><span class="idlParamType">unsigned long</span> <span class="idlParamName">output</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span>      <span class="idlMethName"><a href="#widl-AudioNode-disconnect-void-AudioNode-destination-unsigned-long-output-unsigned-long-input">disconnect</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> <span class="idlParamName">destination</span></span>, <span class="idlParam"><span class="idlParamType">unsigned long</span> <span class="idlParamName">output</span></span>, <span class="idlParam"><span class="idlParamType">unsigned long</span> <span class="idlParamName">input</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span>      <span class="idlMethName"><a href="#widl-AudioNode-disconnect-void-AudioParam-destination">disconnect</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlParamName">destination</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span>      <span class="idlMethName"><a href="#widl-AudioNode-disconnect-void-AudioParam-destination-unsigned-long-output">disconnect</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlParamName">destination</span></span>, <span class="idlParam"><span class="idlParamType">unsigned long</span> <span class="idlParamName">output</span></span>);</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a></span>          <span class="idlAttrName"><a href="#widl-AudioNode-context">context</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">unsigned long</span>         <span class="idlAttrName"><a href="#widl-AudioNode-numberOfInputs">numberOfInputs</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">unsigned long</span>         <span class="idlAttrName"><a href="#widl-AudioNode-numberOfOutputs">numberOfOutputs</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">unsigned long</span>         <span class="idlAttrName"><a href="#widl-AudioNode-channelCount">channelCount</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-ChannelCountMode"><code>ChannelCountMode</code></a></span>      <span class="idlAttrName"><a href="#widl-AudioNode-channelCountMode">channelCountMode</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-ChannelInterpretation"><code>ChannelInterpretation</code></a></span> <span class="idlAttrName"><a href="#widl-AudioNode-channelInterpretation">channelInterpretation</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-3" typeof="bibo:Chapter" id="attributes-3"><h4 resource="#h-attributes-3" id="h-attributes-3"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.4.1 </span>属性</span></h4><dl class="attributes"><dt id="widl-AudioNode-channelCount"><code>channelCount</code> <span class="idlAttrType">unsigned long</span>型</dt><dd>
<!--            <p>
              The number of channels used when up-mixing and down-mixing
              connections to any inputs to the node. The default value is 2
              except for specific nodes where its value is specially
              determined. This attribute has no effect for nodes with no
              inputs. If this value is set to zero or to a value greater than
              the implementation's maximum number of channels the
              implementation <em title="MUST" class="rfc2119">MUST</em> throw a NotSupportedError exception.
            </p>-->
            <p>
              ノードへの入力の接続におけるアップミックスおよびダウンミックスで使用されるチャンネル数です。
              値が別途定められている特定のノードを除いて、デフォルトは2です。
              この属性は入力を持たないノードでは意味を持ちません。 もしこの値が0、あるいは実装のチャンネル数の最大値より大きい値にセットされた場合、実装は NotSupportedError 例外を発生します(<em title="MUST" class="rfc2119">MUST</em>)。
            </p>
<!--            <p>
              See the <a class="sec-ref" href="#channel-up-mixing-and-down-mixing"><span class="secno">5.</span> <span class="sec-title">
        Channel up-mixing and down-mixing
      </span></a> section
              for more information on this attribute.
            </p>-->
            <p>
              この属性の詳細ついては<a class="sec-ref" href="#channel-up-mixing-and-down-mixing"><span class="secno">5.</span> <span class="sec-title">チャンネルのアップミックスとダウンミックス</span></a>セクションを参照してください。
            </p>
          </dd><dt id="widl-AudioNode-channelCountMode"><code>channelCountMode</code> <span class="idlAttrType"><a class="idlType" href="#idl-def-ChannelCountMode"><code>ChannelCountMode</code></a></span>型</dt><dd>
<!--            <p>
              Determines how channels will be counted when up-mixing and
              down-mixing connections to any inputs to the node. This attribute
              has no effect for nodes with no inputs.
            </p>-->
            <p>
              このノードの入力のアップミックスおよびダウンミックス時のチャンネル数の数え方を決定します。 この属性は入力を持たないノードでは意味を持ちません。
            </p>
<!--            <p>
              See the <a class="sec-ref" href="#channel-up-mixing-and-down-mixing"><span class="secno">5.</span> <span class="sec-title">
        Channel up-mixing and down-mixing
      </span></a> section
              for more information on this attribute.
            </p>-->
            <p>
              この属性の詳細ついては<a class="sec-ref" href="#channel-up-mixing-and-down-mixing"><span class="secno">5.</span> <span class="sec-title">チャンネルのアップミックスとダウンミックス</span></a>セクションを参照してください。
            </p>
          </dd><dt id="widl-AudioNode-channelInterpretation"><code>channelInterpretation</code> <span class="idlAttrType"><a class="idlType" href="#idl-def-ChannelInterpretation"><code>ChannelInterpretation</code></a></span>型</dt><dd>
<!--            <p>
              Determines how individual channels will be treated when up-mixing
              and down-mixing connections to any inputs to the node. This
              attribute has no effect for nodes with no inputs.
            </p>-->
            <p>このノードの入力への接続のアップミックスおよびダウンミックス時に各チャンネルをどのように扱うかを決定します。 この属性は入力を持たないノードでは意味を持ちません。
            </p>
<!--            <p>
              See the <a class="sec-ref" href="#channel-up-mixing-and-down-mixing"><span class="secno">5.</span> <span class="sec-title">
        Channel up-mixing and down-mixing
      </span></a> section
              for more information on this attribute.
            </p>-->
            <p>
              この属性の詳細ついては<a class="sec-ref" href="#channel-up-mixing-and-down-mixing"><span class="secno">5.</span> <span class="sec-title">チャンネルのアップミックスとダウンミックス</span></a>セクションを参照してください。
            </p>
          </dd><dt id="widl-AudioNode-context"><code>context</code> <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a></span>型, readonly       </dt>
<!--          <dd>
            The <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> which owns this
            <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>.
          </dd>-->
          <dd>
            この<a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>を持つ<a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>です。
          </dd>
          <dt id="widl-AudioNode-numberOfInputs"><code>numberOfInputs</code> <span class="idlAttrType">unsigned long</span>型, readonly       </dt>
<!--          <dd>
            The number of inputs feeding into the
            <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>. For <dfn id="dfn-source-nodes" data-dfn-type="dfn">source nodes</dfn>, this
            will be 0. This attribute is predetermined for many
            <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> types, but some
            <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>, like the
            <a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a> and the
            <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> have variable number of inputs.
          </dd>-->
          <dd>
            この <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の入力の数です。
            <dfn id="dfn-source-nodes" data-dfn-type="dfn">ソースノード</dfn>ではこれは0になります。この属性は多くの <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> のタイプで固定の値になりますが、 <a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a> や <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> のような幾つかの <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> では入力の数は可変です。
          </dd>
          <dt id="widl-AudioNode-numberOfOutputs"><code>numberOfOutputs</code> <span class="idlAttrType">unsigned long</span>型, readonly       </dt>
<!--          <dd>
            The number of outputs coming out of the
            <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>. This attribute is predetermined for
            some <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> types, but can be variable, like
            for the <a class="idlType" href="#idl-def-ChannelSplitterNode"><code>ChannelSplitterNode</code></a> and the
            <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a>.
          </dd>-->
          <dd>
            この <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> から出る出力の数です。この属性は幾つかの <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> では固定の値ですが、 <a class="idlType" href="#idl-def-ChannelSplitterNode"><code>ChannelSplitterNode</code></a> や <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> などでは可変になります。
          </dd>
        </dl></section><section property="bibo:hasPart" resource="#methods-3" typeof="bibo:Chapter" id="methods-3"><h4 resource="#h-methods-3" id="h-methods-3"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.4.2 </span>メソッド</span></h4><dl class="methods"><dt id="widl-AudioNode-connect-AudioNode-AudioNode-destination-unsigned-long-output-unsigned-long-input"><code>connect</code></dt><dd>

          <!--<p>
            There can only be one connection between a given output of one
            specific node and a given input of another specific node.
            Multiple connections with the same termini are ignored. For
            example:
          </p>-->
          <p>
            あるノードの特定の出力から別のノードの特定の入力への接続は1つだけ存在できます。同じ端子間の複数回の接続は無視されます。例えば:
          </p>
            <div class="example"><div class="example-title"><span>例 4</span></div><pre style="" class="highlight example prettyprint prettyprinted"><span class="pln">nodeA</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">nodeB</span><span class="pun">);</span><span class="pln">
nodeA</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">nodeB</span><span class="pun">);</span></pre></div>
<!--<p>
  will have the same effect as
</p>-->
<p>
  は次のものと同じ効果になります。
</p>
            <div class="example"><div class="example-title"><span>例 5</span></div><pre style="" class="highlight example prettyprint prettyprinted"><span class="pln">nodeA</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">nodeB</span><span class="pun">);</span></pre></div>
          <table class="parameters"><tbody><tr><th>例</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">destination</td><td class="prmType"><code><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
            <!--<p>
              The <code>destination</code> parameter is the
            <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> to connect to. If the
            <code>destination</code> parameter is an
            <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> that has been created using
            another <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>, an InvalidAccessError
            <em title="MUST" class="rfc2119">MUST</em> be thrown. That is, <code>AudioNodes</code> cannot
            be shared between <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>s.
          </p>-->
          <code>destination</code>パラメータは接続先の<a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>です。もし<code>destination</code>が他の<a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>によって作成された<a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>の場合、InvalidAccessError 例外を発生します(<em title="MUST" class="rfc2119">MUST</em>)。
          つまり <code>AudioNodes</code> は複数の <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> 間で共有する事はできません。
          </td>
            </tr><tr><td class="prmName">output</td><td class="prmType"><code>unsigned long = 0
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
              <!--<p>
                  The <code>output</code> parameter is an index describing which
                output of the <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> from which to
                connect. If this paremeter is out-of-bound, an IndexSizeError
                exception <em title="MUST" class="rfc2119">MUST</em> be thrown. It is possible to connect an
                <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> output to more than one input
                with multiple calls to connect(). Thus, "fan-out" is supported.
              </p>-->
              <code>output</code> パラメータは <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> のどの出力を接続するかを指定するインデックスです。
              もしこのパラメータが範囲外の場合、 IndexSizeError 例外を発生します (<em title="MUST" class="rfc2119">MUST</em>)。
              connect() を複数回呼び出して <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の出力から複数の入力に接続する事は可能です。つまり、"ファンアウト"がサポートされています。
              </td></tr><tr><td class="prmName">input</td><td class="prmType"><code>unsigned long = 0
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
              <!--<p>
                The <code>input</code> parameter is an index describing which
                input of the destination <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> to
                connect to. If this parameter is out-of-bounds, an
                IndexSizeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown. It is possible to
                connect an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> to another
                <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> which creates a <dfn id="dfn-cycle" data-dfn-type="dfn">cycle</dfn>:
                an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> may connect to another
                <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>, which in turn connects back to
                the first <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>. This is allowed only
                if there is at least one <a class="idlType" href="#idl-def-DelayNode"><code>DelayNode</code></a> in the
                <em>cycle</em> or a NotSupportedError exception <em title="MUST" class="rfc2119">MUST</em> be thrown.
              </p>-->
              <code>input</code> パラメータは接続先の <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> のどの入力に接続するかを指定するインデックスです。もしこのパラメータが範囲外の場合、 IndexSizeError 例外を発生します (<em title="MUST" class="rfc2119">MUST</em>)。
              ある <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> から他の <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> に<dfn id="dfn-cycle" data-dfn-type="dfn">循環</dfn>を作るような接続を行う事も可能です:
              つまりある <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> から、最初の <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> に接続を行っている別の <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> に対して接続を行う事ができます。
              これは<em>循環</em>の中に少なくとも1つの <a class="idlType" href="#idl-def-DelayNode"><code>DelayNode</code></a> がある場合にのみ可能で、そうでなければ NotSupportedError 例外を発生します (<em title="MUST" class="rfc2119">MUST</em>)。
              </td>
            </tr></tbody></table><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></code></div></dd><dt id="widl-AudioNode-connect-void-AudioParam-destination-unsigned-long-output"><code>connect</code></dt>
            <dd>
<!--              Connects the <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> to an
              <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>, controlling the parameter value
              with an audio-rate signal.-->
              <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> を <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> に接続し、パラメータの値をオーディオレートの信号で制御します。

<!--              <p>
                It is possible to connect an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> output
                to more than one <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> with multiple
                calls to connect(). Thus, "fan-out" is supported.
              </p>-->
              <p>
                connect() を複数回呼び出す事で <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の出力を複数の <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> に接続する事が可能です。即ち、"ファンアウト"がサポートされています。
              </p>
<!--              <p>
                It is possible to connect more than one
                <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> output to a single
                <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> with multiple calls to connect().
                Thus, "fan-in" is supported.
              </p>-->
              <p>
                connect() を複数回呼び出す事で、複数の <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> を1つの <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> に接続する事が可能です。即ち、"ファンイン"がサポートされています。
              </p>
<!--              <p>
                An <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> will take the rendered audio
                data from any <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> output connected to
                it and <a href="#down-mix">convert it to mono</a> by down-mixing
                if it is not already mono, then mix it together with other such
                outputs and finally will mix with the <em>intrinsic</em>
                parameter value (the <code>value</code> the
                <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> would normally have without any
                audio connections), including any timeline changes scheduled for
                the parameter.
              </p>-->
              <p>
                <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> はそれに接続されている <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の出力からレンダリングされたオーディオデータを取り出し、それがモノラルでなければ、ダウンミックスによって<a href="#down-mix">モノラルに変換</a>します。 そして接続されている各出力をミックスし、更に最終的にパラメータが持っているタイムラインの変化スケジュールを含む<em>固有</em>値( <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> に何も接続されていない状態での<code>値</code>)とミックスします。
              </p>
<!--              <p>
                There can only be one connection between a given output of one
                specific node and a specific <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>.
                Multiple connections with the same termini are ignored. For
                example:
              </p>-->
              <p>
                特定のノードの出力と特定の <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> の間の接続は1つのみ存在できます。 同じ終端点を持つ複数の接続は無視されます。例えば:
              </p>
            <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">      nodeA</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">param</span><span class="pun">);</span><span class="pln">
      nodeA</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">param</span><span class="pun">);</span><span class="pln">
    </span></pre><!--will have the same effect as-->は次と同じ効果を持ちます
            <pre>      nodeA.connect(param);

</pre>
          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">destination</td><td class="prmType"><code><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
<!--                The <code>destination</code> parameter is the
                <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> to connect to. This method does
                not return <code>destination</code>
                <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> object.-->
                  <code>destination</code> パラメータは接続先の <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>です。
                  このメソッドは <code>接続先</code>の <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> オブジェクトを返しません。

              </td></tr><tr><td class="prmName">output</td><td class="prmType"><code>unsigned long = 0
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
<!--                The <code>output</code> parameter is an index describing which
                output of the <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> from which to
                connect. If the <code>parameter</code> is out-of-bound, an
                IndexSizeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown.-->
                <code>output</code> パラメータは <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> のどの出力から接続するかを指定するインデックスです。
                  もし <code>parameter</code> が範囲外の場合、IndexSizeError 例外を発生します (<em title="MUST" class="rfc2119">MUST</em>)。
              </td></tr></tbody></table><div><em>戻り値: </em><code>void</code></div></dd><dt id="widl-AudioNode-disconnect-void"><code>disconnect</code></dt><dd>
            <p>
<!--              Disconnects all outgoing connections from the
              <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>.-->
              <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> から出る全ての接続を切断します。
            </p>
          <div><em>パラメータなし</em></div><div><em>戻り値: </em><code>void</code></div></dd><dt id="widl-AudioNode-disconnect-void-unsigned-long-output"><code>disconnect</code></dt><dd>
            <p>
<!--              Disconnects a single output of the <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>
              from any other <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> or
              <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> objects to which it is connected.-->
              <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の1つの出力から他の<a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>または<a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>オブジェクトへの接続を全て切断します。
            </p>

          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">output</td><td class="prmType"><code>unsigned long</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
<!--                This parameter is an index describing which output of the
                <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> to disconnect. It disconnects all
                outgoing connections from the given output. If this parameter
                is out-of-bounds, an IndexSizeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown.-->
                このパラメータは接続を切る <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の出力のインデックスです。 これは与えられた出力から出る全ての接続を切断します。
                もしこのパラメータが範囲外の場合、IndexSizeError 例外を発生します (<em title="MUST" class="rfc2119">MUST</em>)。
              </td></tr></tbody></table><div><em>戻り値: </em><code>void</code></div></dd><dt id="widl-AudioNode-disconnect-void-AudioNode-destination"><code>disconnect</code></dt><dd>
            <p>
<!--              Disconnects all outputs of the <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> that
              go to a specific destination <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>.-->
              <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の全ての出力から特定の接続先となる <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> に繋がる接続を切断します。
            </p>

          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">destination</td><td class="prmType"><code><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
<!--                The <code>destination</code> parameter is the
                <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> to disconnect. It disconnects all
                outgoing connections to the given <code>destination</code>. If
                there is no connection to <code>destination</code>, an
                InvalidAccessError exception <em title="MUST" class="rfc2119">MUST</em> be thrown.-->
                <code>destination</code> パラメータは切断する <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。これは与えられた <code>destination</code> に対する全ての接続を切断します。
                もし<code>destination</code> に対する接続がない場合、InvalidAccessError を発生します (<em title="MUST" class="rfc2119">MUST</em>)。
              </td></tr></tbody></table><div><em>戻り値: </em><code>void</code></div></dd><dt id="widl-AudioNode-disconnect-void-AudioNode-destination-unsigned-long-output"><code>disconnect</code></dt><dd>
            <p>
<!--              Disconnects a specific output of the
              <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> from a specific destination
              <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>.-->
              <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の特定の出力から特定の <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> への接続を切断します。
            </p>

          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">destination</td><td class="prmType"><code><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
<!--                The <code>destination</code> parameter is the
                <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> to disconnect. If there is no
                connection to the <code>destination</code> from the given
                output, an InvalidAccessError exception <em title="MUST" class="rfc2119">MUST</em> be thrown.-->
                <code>destination</code> パラメータは切断する <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。もし、与えられた出力から <code>destination</code> への接続が存在しない場合、InvalidAccessError 例外を発生します (<em title="MUST" class="rfc2119">MUST</em> )。
              </td></tr><tr><td class="prmName">output</td><td class="prmType"><code>unsigned long</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
<!--                The <code>output</code> parameter is an index describing which
                output of the <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> from which to
                disconnect. If this parameter is out-of-bound, an
                IndexSizeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown.-->
                <code>output</code> パラメータは接続を切る <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の出力を表すインデックスです。もしこのパラメータが範囲外の場合は IndexSizeError 例外を発生します (<em title="MUST" class="rfc2119">MUST</em>)。
              </td></tr></tbody></table><div><em>戻り値: </em><code>void</code></div></dd><dt id="widl-AudioNode-disconnect-void-AudioNode-destination-unsigned-long-output-unsigned-long-input"><code>disconnect</code></dt><dd>
            <p>
<!--              Disconnects a specific output of the
              <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> from a specific input of some
              destination <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>.-->
              <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の特定の出力から
              接続先 <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の特定の入力への接続を切断します。
            </p>

          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">destination</td><td class="prmType"><code><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
<!--                The <code>destination</code> parameter is the
                <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> to disconnect. If there is no
                connection to the <code>destination</code> from the given
                output to the given input, an InvalidAccessError exception <em title="MUST" class="rfc2119">MUST</em>
                be thrown.-->
                <code>destination</code> パラメータは切断する <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> です。もし与えられた出力から <code>destination</code> の与えられた入力への接続が存在しない場合、InvalidAccessError 例外を発生します (<em title="MUST" class="rfc2119">MUST</em>)。
              </td></tr><tr><td class="prmName">output</td><td class="prmType"><code>unsigned long</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
<!--                The <code>output</code> parameter is an index describing which
                output of the <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> from which to
                disconnect. If this parameter is out-of-bound, an
                IndexSizeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown.-->
                <code>output</code> パラメータは切断する <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の出力のインデックスです。もしこのパラメータが範囲外の場合、IndexSizeError 例外を発生します (<em title="MUST" class="rfc2119">MUST</em>)。
              </td></tr><tr><td class="prmName">input</td><td class="prmType"><code>unsigned long</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
<!--                The <code>input</code> parameter is an index describing which
                input of the destination <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> to
                disconnect. If this parameter is out-of-bounds, an
                IndexSizeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown.-->
                <code>input</code> パラメータは切断する接続先 <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の入力のインデックスです。もしこのパラメータが範囲外の場合、IndexSizeError 例外を発生します (<em title="MUST" class="rfc2119">MUST</em>)。
              </td></tr></tbody></table><div><em>戻り値: </em><code>void</code></div></dd><dt id="widl-AudioNode-disconnect-void-AudioParam-destination"><code>disconnect</code></dt><dd>
            <p>
<!--              Disconnects all outputs of the <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> that
              go to a specific destination <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>. The
              contribution of this <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> to the
              computed parameter value goes to 0 when this operation takes
              effect. The intrinsic parameter value is not affected by this
              operation.-->
              特定の接続先 <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> に繋がる <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の全ての出力を切断します。
              この操作によって、この <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> からパラメータ値の計算への寄与は0となります。パラメータの固有値はこの操作に影響されません。
            </p>

          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">destination</td><td class="prmType"><code><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
<!--                The <code>destination</code> parameter is the
                <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> to disconnect. If there is no
                connection to the <code>destination</code>, an
                InvalidAccessError exception <em title="MUST" class="rfc2119">MUST</em> be thrown.-->
                <code>destination</code> パラメータは切断する <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> です。もし <code>destination</code> への接続が存在しない場合、InvalidAccessError 例外を発生します (<em title="MUST" class="rfc2119">MUST</em>)。
              </td></tr></tbody></table><div><em>戻り値: </em><code>void</code></div></dd><dt id="widl-AudioNode-disconnect-void-AudioParam-destination-unsigned-long-output"><code>disconnect</code></dt><dd>
            <p>
<!--              Disconnects a specific output of the
              <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> from a specific destination
              <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>. The contribution of this
              <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> to the computed parameter value
              goes to 0 when this operation takes effect. The intrinsic
              parameter value is not affected by this operation.-->
              <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>の特定の出力から特定の<a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>への接続を切断します。
              この操作によって、この <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> からパラメータ値の計算への寄与は0となります。パラメータの固有値はこの操作に影響されません。
            </p>

          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">destination</td><td class="prmType"><code><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
<!--                The <code>destination</code> parameter is the
                <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> to disconnect. If there is no
                connection to the <code>destination</code>, an
                InvalidAccessError exception <em title="MUST" class="rfc2119">MUST</em> be thrown.-->
                <code>destination</code> パラメータは切断される <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> です。もし <code>destination</code> への接続が存在しない場合、InvalidAccessError 例外を発生します (<em title="MUST" class="rfc2119">MUST</em>)。

              </td></tr><tr><td class="prmName">output</td><td class="prmType"><code>unsigned long</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
<!--                The <code>output</code> parameter is an index describing which
                output of the <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> from which to
                disconnect. If the <code>parameter</code> is out-of-bound, an
                IndexSizeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown.-->
                 <code>output</code> パラメータは切断される <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> の出力のインデックスです。もし、<code>parameter</code>が範囲外の場合、IndexSizeError 例外を発生します (<em title="MUST" class="rfc2119">MUST</em>)。
               </td></tr></tbody></table><div><em>戻り値: </em><code>void</code></div></dd></dl></section>
        <section property="bibo:hasPart" resource="#lifetime-AudioNode" typeof="bibo:Chapter">
          <h4 resource="#lifetime-AudioNode" id="lifetime-AudioNode" class="informative"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.4.3 </span>
            Lifetime
          </span></h4>
          <p>
            <i>This section is informative.</i>
          </p>
          <p>
            An implementation may choose any method to avoid unnecessary
            resource usage and unbounded memory growth of unused/finished
            nodes. The following is a description to help guide the general
            expectation of how node lifetime would be managed.
          </p>
          <p>
            An <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> will live as long as there are any
            references to it. There are several types of references:
          </p>
          <ol>
            <li>A <em>normal</em> JavaScript reference obeying normal garbage
            collection rules.
            </li>
            <li>A <em>playing</em> reference for both
            <a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a>s and
            <a class="idlType" href="#idl-def-OscillatorNode"><code>OscillatorNode</code></a>s. These nodes maintain a
            <em>playing</em> reference to themselves while they are currently
            playing.
            </li>
            <li>A <em>connection</em> reference which occurs if another
            <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> is connected to it.
            </li>
            <li>A <em>tail-time</em> reference which an
            <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> maintains on itself as long as it has
            any internal processing state which has not yet been emitted. For
            example, a <a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a> has a tail which
            continues to play even after receiving silent input (think about
            clapping your hands in a large concert hall and continuing to hear
            the sound reverberate throughout the hall). Some
            <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s have this property. Please see
            details for specific nodes.
            </li>
          </ol>
          <p>
            Any <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s which are connected in a cycle
            <em>and</em> are directly or indirectly connected to the
            <a class="idlType" href="#idl-def-AudioDestinationNode"><code>AudioDestinationNode</code></a> of the
            <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> will stay alive as long as the
            <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> is alive.
          </p>
          <div class="note"><div id="h-note1" role="heading" aria-level="5" class="note-title"><span>Note</span></div><p class="">
            The uninterrupted operation of <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s implies that as
            long as live references exist to a node, the node will continue
            processing its inputs and evolving its internal state even if it is
            disconnected from the audio graph. Since this processing will
            consume CPU and power, developers should carefully consider the
            resource usage of disconnected nodes. In particular, it is a good
            idea to minimize resource consumption by explicitly putting
            disconnected nodes into a stopped state when possible.
          </p></div>
          <p>
            When an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> has no references it will be
            deleted. Before it is deleted, it will disconnect itself from any
            other <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s which it is connected to. In
            this way it releases all connection references (3) it has to other
            nodes.
          </p>
          <p>
            Regardless of any of the above references, it can be assumed that
            the <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> will be deleted when its
            <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> is deleted.
          </p>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#AudioDestinationNode" typeof="bibo:Chapter">
        <h3 resource="#AudioDestinationNode" id="AudioDestinationNode"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.5 </span>
          The AudioDestinationNode Interface
        </span></h3>
        <p>
          This is an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> representing the final audio
          destination and is what the user will ultimately hear. It can often
          be considered as an audio output device which is connected to
          speakers. All rendered audio to be heard will be routed to this node,
          a "terminal" node in the <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s routing
          graph. There is only a single AudioDestinationNode per
          <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>, provided through the
          <code>destination</code> attribute of
          <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>.
        </p>
        <pre>      numberOfInputs  : 1
      numberOfOutputs : 0

      channelCount = 2;
      channelCountMode = "explicit";
      channelInterpretation = "speakers";
</pre>
        <pre class="idl"><span class="idlInterface" id="idl-def-AudioDestinationNode">interface <span class="idlInterfaceID">AudioDestinationNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">unsigned long</span> <span class="idlAttrName"><a href="#widl-AudioDestinationNode-maxChannelCount">maxChannelCount</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-4" typeof="bibo:Chapter" id="attributes-4"><h4 resource="#h-attributes-4" id="h-attributes-4"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.5.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-AudioDestinationNode-maxChannelCount"><code>maxChannelCount</code> of type <span class="idlAttrType">unsigned long</span>, readonly       </dt><dd>
            <p>
              The maximum number of channels that the <a href="#widl-AudioNode-channelCount"><code>channelCount</code></a>
              attribute can be set to. An
              <a class="idlType" href="#idl-def-AudioDestinationNode"><code>AudioDestinationNode</code></a> representing the audio
              hardware end-point (the normal case) can potentially output more
              than 2 channels of audio if the audio hardware is multi-channel.
              <code>maxChannelCount</code> is the maximum number of channels
              that this hardware is capable of supporting. If this value is 0,
              then this indicates that <a href="#widl-AudioNode-channelCount">channelCount</a> may not be
              changed. This will be the case for an
              <a class="idlType" href="#idl-def-AudioDestinationNode"><code>AudioDestinationNode</code></a> in an
              <a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a> and also for basic
              implementations with hardware support for stereo output only.
            </p>
            <p>
              <a href="#widl-AudioNode-channelCount">channelCount</a> defaults
              to 2 for a destination in a normal
              <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>, and may be set to any non-zero
              value less than or equal to <code>maxChannelCount</code>. An
              <code>IndexSizeError</code> exception <em title="MUST" class="rfc2119">MUST</em> be thrown if
              this value is not within the valid range. Giving a concrete
              example, if the audio hardware supports 8-channel output, then we
              may set <a href="#widl-AudioNode-channelCount">channelCount</a>
              to 8, and render 8-channels of output.
            </p>
            <p>
              For an<a class="idlType" href="#idl-def-AudioDestinationNode"><code>AudioDestinationNode</code></a> in an
              <a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a>, the <a href="#widl-AudioNode-channelCount"><code>channelCount</code></a> is
              determined when the offline context is created and this value may
              not be changed.
            </p>
          </dd></dl></section>
      </section>
      <section property="bibo:hasPart" resource="#AudioParam" typeof="bibo:Chapter">
        <h3 resource="#AudioParam" id="AudioParam"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.6 </span>
          The AudioParam Interface
        </span></h3>
        <p>
          <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> controls an individual aspect of an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>'s functioning, such as volume. The
          parameter can be set immediately to a particular value using the
          <code>value</code> attribute. Or, value changes can be scheduled to
          happen at very precise times (in the coordinate system of
          <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s <a href="#widl-BaseAudioContext-currentTime">currentTime</a> attribute), for
          envelopes, volume fades, LFOs, filter sweeps, grain windows, etc. In
          this way, arbitrary timeline-based automation curves can be set on
          any <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>. Additionally, audio signals from
          the outputs of <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s can be connected to an
          <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>, summing with the <em>intrinsic</em>
          parameter value.
        </p>
        <p>
          Some synthesis and processing <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s have
          <code>AudioParams</code> as attributes whose values must be taken
          into account on a per-audio-sample basis. For other
          <code>AudioParams</code>, sample-accuracy is not important and the
          value changes can be sampled more coarsely. Each individual
          <code>AudioParam</code> will specify that it is either an
          <a data-link-type="dfn" class="internalDFN" href="#a-rate">a-rate</a> parameter which means that its values must be taken
          into account on a per-audio-sample basis, or it is a <a data-link-type="dfn" class="internalDFN" href="#k-rate">k-rate</a>
          parameter.
        </p>
        <p>
          Implementations must use block processing, with each
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> processing 128 sample-frames in each
          block.
        </p>
        <p>
          For each 128 sample-frame block, the value of a <dfn data-dfn-type="dfn" id="k-rate">k-rate</dfn> parameter must be sampled at the time of the
          very first sample-frame, and that value must be used for the entire
          block. <dfn data-dfn-type="dfn" id="a-rate">a-rate</dfn> parameters must be sampled for
          each sample-frame of the block.
        </p>
        <p>
          An <code>AudioParam</code> maintains a time-ordered event list which
          is initially empty. The times are in the time coordinate system of
          the <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s <a href="#widl-BaseAudioContext-currentTime">currentTime</a> attribute. The
          events define a mapping from time to value. The following methods can
          change the event list by adding a new event into the list of a type
          specific to the method. Each event has a time associated with it, and
          the events will always be kept in time-order in the list. These
          methods will be called <em>automation</em> methods:
        </p>
        <ul>
          <li>
            <a href="#widl-AudioParam-setValueAtTime-AudioParam-float-value-double-startTime">
            setValueAtTime()</a> - <em>SetValue</em>
          </li>
          <li>
            <a href="#widl-AudioParam-linearRampToValueAtTime-AudioParam-float-value-double-endTime">
            linearRampToValueAtTime()</a> - <em>LinearRampToValue</em>
          </li>
          <li>
            <a href="#widl-AudioParam-exponentialRampToValueAtTime-AudioParam-float-value-double-endTime">
            exponentialRampToValueAtTime()</a> -
            <em>ExponentialRampToValue</em>
          </li>
          <li>
            <a href="#widl-AudioParam-setTargetAtTime-AudioParam-float-target-double-startTime-float-timeConstant">
            setTargetAtTime()</a> - <em>SetTarget</em>
          </li>
          <li>
            <a href="#widl-AudioParam-setValueCurveAtTime-AudioParam-Float32Array-values-double-startTime-double-duration">
            setValueCurveAtTime()</a> - <em>SetValueCurve</em>
          </li>
        </ul>
        <p>
          The following rules will apply when calling these methods:
        </p>
        <ul>
          <li>If one of these events is added at a time where there is already
          an event of the exact same type, then the new event will replace the
          old one.
          </li>
          <li>If one of these events is added at a time where there is already
          one or more events of a different type, then it will be placed in the
          list after them, but before events whose times are after the event.
          </li>
          <li>If setValueCurveAtTime() is called for time \(T\) and duration
          \(D\) and there are any events having a time greater than \(T\), but
          less than \(T + D\), then a NotSupportedError exception <em title="MUST" class="rfc2119">MUST</em> be
          thrown. In other words, it's not ok to schedule a value curve during
          a time period containing other events.
          </li>
          <li>Similarly a NotSupportedError exception <em title="MUST" class="rfc2119">MUST</em> be thrown if any
          <em>automation</em> method is called at a time which is inside of the
          time interval of a <em>SetValueCurve</em> event at time T and
          duration D.
          </li>
        </ul>
        <pre class="idl"><span class="idlInterface" id="idl-def-AudioParam">interface <span class="idlInterfaceID">AudioParam</span> {
<span class="idlAttribute">                    attribute <span class="idlAttrType">float</span> <span class="idlAttrName"><a href="#widl-AudioParam-value">value</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">float</span> <span class="idlAttrName"><a href="#widl-AudioParam-defaultValue">defaultValue</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlMethName"><a href="#widl-AudioParam-setValueAtTime-AudioParam-float-value-double-startTime">setValueAtTime</a></span> (<span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">value</span></span>, <span class="idlParam"><span class="idlParamType">double</span> <span class="idlParamName">startTime</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlMethName"><a href="#widl-AudioParam-linearRampToValueAtTime-AudioParam-float-value-double-endTime">linearRampToValueAtTime</a></span> (<span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">value</span></span>, <span class="idlParam"><span class="idlParamType">double</span> <span class="idlParamName">endTime</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlMethName"><a href="#widl-AudioParam-exponentialRampToValueAtTime-AudioParam-float-value-double-endTime">exponentialRampToValueAtTime</a></span> (<span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">value</span></span>, <span class="idlParam"><span class="idlParamType">double</span> <span class="idlParamName">endTime</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlMethName"><a href="#widl-AudioParam-setTargetAtTime-AudioParam-float-target-double-startTime-float-timeConstant">setTargetAtTime</a></span> (<span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">target</span></span>, <span class="idlParam"><span class="idlParamType">double</span> <span class="idlParamName">startTime</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">timeConstant</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlMethName"><a href="#widl-AudioParam-setValueCurveAtTime-AudioParam-Float32Array-values-double-startTime-double-duration">setValueCurveAtTime</a></span> (<span class="idlParam"><span class="idlParamType">Float32Array</span> <span class="idlParamName">values</span></span>, <span class="idlParam"><span class="idlParamType">double</span> <span class="idlParamName">startTime</span></span>, <span class="idlParam"><span class="idlParamType">double</span> <span class="idlParamName">duration</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlMethName"><a href="#widl-AudioParam-cancelScheduledValues-AudioParam-double-startTime">cancelScheduledValues</a></span> (<span class="idlParam"><span class="idlParamType">double</span> <span class="idlParamName">startTime</span></span>);</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-5" typeof="bibo:Chapter" id="attributes-5"><h4 resource="#h-attributes-5" id="h-attributes-5"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.6.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-AudioParam-defaultValue"><code>defaultValue</code> of type <span class="idlAttrType">float</span>, readonly       </dt><dd>
            Initial value for the <code>value</code> attribute.
          </dd><dt id="widl-AudioParam-value"><code>value</code> of type <span class="idlAttrType">float</span></dt><dd>
            <p>
              The parameter's floating-point value. This attribute is
              initialized to the <code>defaultValue</code>. If
              <code>value</code> is set during a time when there are any
              automation events scheduled then it will be ignored and no
              exception will be thrown.
            </p>
            <p>
              The effect of setting this attribute is equivalent to calling
              <code>setValueAtTime()</code> with the current
              <code>AudioContext</code>'s <code>currentTime</code> and the
              requested value. Subsequent accesses to this attribute's getter
              will return the same value.
            </p>
          </dd></dl></section><section property="bibo:hasPart" resource="#methods-4" typeof="bibo:Chapter" id="methods-4"><h4 resource="#h-methods-4" id="h-methods-4"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.6.2 </span>Methods</span></h4><dl class="methods"><dt id="widl-AudioParam-cancelScheduledValues-AudioParam-double-startTime"><code>cancelScheduledValues</code></dt><dd>
            <p>
              Cancels all scheduled parameter changes with times greater than
              or equal to <code>startTime</code>. Active
              <code>setTargetAtTime</code> automations (those with
              <code>startTime</code> less than the supplied time value) will
              also be cancelled.
            </p>

          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">startTime</td><td class="prmType"><code>double</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The starting time at and after which any previously scheduled
                parameter changes will be cancelled. It is a time in the same
                time coordinate system as the
                <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s <a href="#widl-BaseAudioContext-currentTime">currentTime</a> attribute.
                A TypeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown if <code>startTime</code>
                is negative or is not a finite number.
              </td></tr></tbody></table><div><em>Return type: </em><code><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></code></div></dd><dt id="widl-AudioParam-exponentialRampToValueAtTime-AudioParam-float-value-double-endTime"><code>exponentialRampToValueAtTime</code></dt><dd>
            <p>
              Schedules an exponential continuous change in parameter value
              from the previous scheduled parameter value to the given value.
              Parameters representing filter frequencies and playback rate are
              best changed exponentially because of the way humans perceive
              sound.
            </p>
            <p>
              The value during the time interval \(T_0 \leq t &lt; T_1\) (where
              \(T_0\) is the time of the previous event and \(T_1\) is the
              <code>endTime</code> parameter passed into this method) will be
              calculated as:
            </p>
            <pre>              $$
                v(t) = V_0 \left(\frac{V_1}{V_0}\right)^\frac{t - T_0}{T_1 - T_0}
              $$

</pre>
            <p>
              where \(V_0\) is the value at the time \(T_0\) and \(V_1\) is the
              <code>value</code> parameter passed into this method. It is an
              error if either \(V_0\) or \(V_1\) is not strictly positive.
            </p>
            <p>
              This also implies an exponential ramp to 0 is not possible. A
              good approximation can be achieved using <a href="#widl-AudioParam-setTargetAtTime-AudioParam-float-target-double-startTime-float-timeConstant">
              setTargetAtTime</a> with an appropriately chosen time constant.
            </p>
            <p>
              If there are no more events after this ExponentialRampToValue
              event then for \(t \geq T_1\), \(v(t) = V_1\).
            </p>

          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">value</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The value the parameter will exponentially ramp to at the given
                time. A NotSupportedError exception <em title="MUST" class="rfc2119">MUST</em> be thrown if this
                value is less than or equal to 0, or if the value at the time
                of the previous event is less than or equal to 0.
              </td></tr><tr><td class="prmName">endTime</td><td class="prmType"><code>double</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The time in the same time coordinate system as the
                <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s <a href="#widl-BaseAudioContext-currentTime">currentTime</a> attribute
                where the exponential ramp ends. A TypeError exception <em title="MUST" class="rfc2119">MUST</em> be
                thrown if <code>endTime</code> is negative or is not a finite
                number.
              </td></tr></tbody></table><div><em>Return type: </em><code><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></code></div></dd><dt id="widl-AudioParam-linearRampToValueAtTime-AudioParam-float-value-double-endTime"><code>linearRampToValueAtTime</code></dt><dd>
            <p>
              Schedules a linear continuous change in parameter value from the
              previous scheduled parameter value to the given value.
            </p>

            <p>
              The value during the time interval \(T_0 \leq t &lt; T_1\) (where
              \(T_0\) is the time of the previous event and \(T_1\) is the
              <code>endTime</code> parameter passed into this method) will be
              calculated as:
            </p>
            <pre>              $$
                v(t) = V_0 + (V_1 - V_0) \frac{t - T_0}{T_1 - T_0}
              $$

</pre>
            <p>
              Where \(V_0\) is the value at the time \(T_0\) and \(V_1\) is the
              <code>value</code> parameter passed into this method.
            </p>
            <p>
              If there are no more events after this LinearRampToValue event
              then for \(t \geq T_1\), \(v(t) = V_1\).
            </p>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">value</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The value the parameter will linearly ramp to at the given
                time.
              </td></tr><tr><td class="prmName">endTime</td><td class="prmType"><code>double</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The time in the same time coordinate system as the
                <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s <a href="#widl-BaseAudioContext-currentTime">currentTime</a> attribute
                at which the automation ends. A TypeError exception <em title="MUST" class="rfc2119">MUST</em> be
                thrown if <code>endTime</code> is negative or is not a finite
                number.
              </td></tr></tbody></table><div><em>Return type: </em><code><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></code></div></dd><dt id="widl-AudioParam-setTargetAtTime-AudioParam-float-target-double-startTime-float-timeConstant"><code>setTargetAtTime</code></dt><dd>
            <p>
              Start exponentially approaching the target value at the given
              time with a rate having the given time constant. Among other
              uses, this is useful for implementing the "decay" and "release"
              portions of an ADSR envelope. Please note that the parameter
              value does not immediately change to the target value at the
              given time, but instead gradually changes to the target value.
            </p>

            <p>
              During the time interval: \(T_0 \leq t &lt; T_1\), where \(T_0\)
              is the <code>startTime</code> parameter and \(T_1\) represents
              the time of the event following this event (or \(\infty\) if
              there are no following events):
            </p>
            <pre>              $$
                v(t) = V_1 + (V_0 - V_1)\, e^{-\left(\frac{t - T_0}{\tau}\right)}
              $$

</pre>
            <p>
              where \(V_0\) is the initial value (the <code>.value</code>
              attribute) at \(T_0\) (the <code>startTime</code> parameter),
              \(V_1\) is equal to the <code>target</code> parameter, and
              \(\tau\) is the <code>timeConstant</code> parameter.
            </p>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">target</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The value the parameter will <em>start</em> changing to at the
                given time.
              </td></tr><tr><td class="prmName">startTime</td><td class="prmType"><code>double</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The time at which the exponential approach will begin, in the
                same time coordinate system as the
                <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s <a href="#widl-BaseAudioContext-currentTime">currentTime</a> attribute.
                A TypeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown if <code>start</code> is
                negative or is not a finite number.
              </td></tr><tr><td class="prmName">timeConstant</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The time-constant value of first-order filter (exponential)
                approach to the target value. The larger this value is, the
                slower the transition will be. The value must be strictly
                positive or a TypeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown.
                <p>
                  More precisely, <em>timeConstant</em> is the time it takes a
                  first-order linear continuous time-invariant system to reach
                  the value \(1 - 1/e\) (around 63.2%) given a step input
                  response (transition from 0 to 1 value).
                </p>
              </td></tr></tbody></table><div><em>Return type: </em><code><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></code></div></dd><dt id="widl-AudioParam-setValueAtTime-AudioParam-float-value-double-startTime"><code>setValueAtTime</code></dt><dd>
            <p>
              Schedules a parameter value change at the given time.
            </p>

            <p>
              If there are no more events after this <em>SetValue</em> event,
              then for \(t \geq T_0\), \(v(t) = V\), where \(T_0\) is the
              <code>startTime</code> parameter and \(V\) is the
              <code>value</code> parameter. In other words, the value will
              remain constant.
            </p>
            <p>
              If the next event (having time \(T_1\)) after this
              <em>SetValue</em> event is not of type <em>LinearRampToValue</em>
              or <em>ExponentialRampToValue</em>, then, for \(T_0 \leq t &lt;
              T_1\):
            </p>
            <pre>              $$
                v(t) = V
              $$

</pre>
            <p>
              In other words, the value will remain constant during this time
              interval, allowing the creation of "step" functions.
            </p>
            <p>
              If the next event after this <em>SetValue</em> event is of type
              <em>LinearRampToValue</em> or <em>ExponentialRampToValue</em>
              then please see <code><a href="#widl-AudioParam-linearRampToValueAtTime-AudioParam-float-value-double-endTime">
              linearRampToValueAtTime</a></code> or <code><a href="#widl-AudioParam-exponentialRampToValueAtTime-AudioParam-float-value-double-endTime">
              exponentialRampToValueAtTime</a></code>, respectively.
            </p>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">value</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The value the parameter will change to at the given time.
              </td></tr><tr><td class="prmName">startTime</td><td class="prmType"><code>double</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The time in the same time coordinate system as the
                <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s <a href="#widl-BaseAudioContext-currentTime">currentTime</a> attribute
                at which the parameter changes to the given value. A TypeError
                exception <em title="MUST" class="rfc2119">MUST</em> be thrown if <code>startTime</code> is negative
                or is not a finite number.
              </td></tr></tbody></table><div><em>Return type: </em><code><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></code></div></dd><dt id="widl-AudioParam-setValueCurveAtTime-AudioParam-Float32Array-values-double-startTime-double-duration"><code>setValueCurveAtTime</code></dt><dd>
            <p>
              Sets an array of arbitrary parameter values starting at the given
              time for the given duration. The number of values will be scaled
              to fit into the desired duration.
            </p>

            <p>
              Let \(T_0\) be <code>startTime</code>, \(T_D\) be
              <code>duration</code>, \(V\) be the <code>values</code> array,
              and \(N\) be the length of the <code>values</code> array. Then,
              during the time interval: \(T_0 \le t &lt; T_0 + T_D\), let
            </p>
            <pre>              $$
                \begin{align*} k &amp;= \left\lfloor \frac{N - 1}{T_D}(t-T_0) \right\rfloor \\
                \end{align*}
              $$

</pre>
            <p>
              Then \(v(t)\) is computed by linearly interpolating between
              \(V[k]\) and \(V[k+1]\),
            </p>
            <p>
              After the end of the curve time interval (\(t \ge T_0 + T_D\)),
              the value will remain constant at the final curve value, until
              there is another automation event (if any).
            </p>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">values</td><td class="prmType"><code>Float32Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                A Float32Array representing a parameter value curve. These
                values will apply starting at the given time and lasting for
                the given duration. When this method is called, an internal
                copy of the curve is created for automation purposes.
                Subsequent modifications of the contents of the passed-in array
                therefore have no effect on the the <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>.
              </td></tr><tr><td class="prmName">startTime</td><td class="prmType"><code>double</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The start time in the same time coordinate system as the
                <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s <a href="#widl-BaseAudioContext-currentTime">currentTime</a> attribute
                at which the value curve will be applied. A TypeError exception
                <em title="MUST" class="rfc2119">MUST</em> be thrown if <code>startTime</code> is negative or is not
                a finite number.
              </td></tr><tr><td class="prmName">duration</td><td class="prmType"><code>double</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The amount of time in seconds (after the <em>time</em>
                parameter) where values will be calculated according to the
                <em>values</em> parameter.
              </td></tr></tbody></table><div><em>Return type: </em><code><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></code></div></dd></dl></section>
        <section property="bibo:hasPart" resource="#computation-of-value" typeof="bibo:Chapter" id="computation-of-value">
          <h4 resource="#h-computation-of-value" id="h-computation-of-value"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.6.3 </span>
            Computation of Value
          </span></h4>
          <p>
            <dfn id="dfn-computedvalue" data-dfn-type="dfn">computedValue</dfn> is the final value controlling the audio
            DSP and is computed by the audio rendering thread during each
            rendering time quantum. It must be internally computed as follows:
          </p>
          <ol>
            <li>An <em>intrinsic</em> parameter value will be calculated at
            each time, which is either the value set directly to the
            <code>value</code> attribute, or, if there are any scheduled
            parameter changes (automation events) with times before or at this
            time, the value as calculated from these events. If the
            <code>value</code> attribute is set after any automation events
            have been scheduled, then these events will be removed. When read,
            the <code>value</code> attribute always returns the
            <em>intrinsic</em> value for the current time. If automation events
            are removed from a given time range, then the <em>intrinsic</em>
            value will remain unchanged and stay at its previous value until
            either the <code>value</code> attribute is directly set, or
            automation events are added for the time range.
            </li>
            <li>An <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> will take the rendered audio
            data from any <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> output connected to it
            and <a href="#down-mix">convert it to mono</a> by down-mixing if it
            is not already mono, then mix it together with other such outputs.
            If there are no <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s connected to it,
            then this value is 0, having no effect on the
            <em>computedValue</em>.
            </li>
            <li>The <em>computedValue</em> is the sum of the <em>intrinsic</em>
            value and the value calculated from (2).
            </li>
          </ol>
        </section>
        <section property="bibo:hasPart" resource="#example1-AudioParam" typeof="bibo:Chapter">
          <h4 resource="#example1-AudioParam" id="example1-AudioParam"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.6.4 </span>
            AudioParam Automation Example
          </span></h4>
          <figure id="fig-an-example-of-parameter-automation.x">
            <!-- The image here was created from
  http://googlechrome.github.io/web-audio-samples/samples/audio/timeline.html -->
            <img alt="AudioParam automation" src="images/audioparam-automation1.png">
            <figcaption>Fig. <span class="figno">4</span> <span class="fig-title">
              An example of parameter automation.
            </span></figcaption>
          </figure>
          <div class="example"><div class="example-title"><span>Example 6</span></div><pre class="code example"><code style="" class="es-code highlight prettyprint prettyprinted"><span class="pln">
</span><span class="kwd">var</span><span class="pln"> curveLength </span><span class="pun">=</span><span class="pln"> </span><span class="lit">44100</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> curve </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Float32Array</span><span class="pun">(</span><span class="pln">curveLength</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> curveLength</span><span class="pun">;</span><span class="pln"> </span><span class="pun">++</span><span class="pln">i</span><span class="pun">)</span><span class="pln">
    curve</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">sin</span><span class="pun">(</span><span class="typ">Math</span><span class="pun">.</span><span class="pln">PI </span><span class="pun">*</span><span class="pln"> i </span><span class="pun">/</span><span class="pln"> curveLength</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">var</span><span class="pln"> t0 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> t1 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.1</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> t2 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.2</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> t3 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.3</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> t4 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.325</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> t5 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.5</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> t6 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.6</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> t7 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.7</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> t8 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1.0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> timeConstant </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.1</span><span class="pun">;</span><span class="pln">

param</span><span class="pun">.</span><span class="pln">setValueAtTime</span><span class="pun">(</span><span class="lit">0.2</span><span class="pun">,</span><span class="pln"> t0</span><span class="pun">);</span><span class="pln">
param</span><span class="pun">.</span><span class="pln">setValueAtTime</span><span class="pun">(</span><span class="lit">0.3</span><span class="pun">,</span><span class="pln"> t1</span><span class="pun">);</span><span class="pln">
param</span><span class="pun">.</span><span class="pln">setValueAtTime</span><span class="pun">(</span><span class="lit">0.4</span><span class="pun">,</span><span class="pln"> t2</span><span class="pun">);</span><span class="pln">
param</span><span class="pun">.</span><span class="pln">linearRampToValueAtTime</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> t3</span><span class="pun">);</span><span class="pln">
param</span><span class="pun">.</span><span class="pln">linearRampToValueAtTime</span><span class="pun">(</span><span class="lit">0.8</span><span class="pun">,</span><span class="pln"> t4</span><span class="pun">);</span><span class="pln">
param</span><span class="pun">.</span><span class="pln">setTargetAtTime</span><span class="pun">(.</span><span class="lit">5</span><span class="pun">,</span><span class="pln"> t4</span><span class="pun">,</span><span class="pln"> timeConstant</span><span class="pun">);</span><span class="pln">
</span><span class="com">// Compute where the setTargetAtTime will be at time t5 so we can make</span><span class="pln">
</span><span class="com">// the following exponential start at the right point so there's no</span><span class="pln">
</span><span class="com">// jump discontinuity.  From the spec, we have</span><span class="pln">
</span><span class="com">//   v(t) = 0.5 + (0.8 - 0.5)*exp(-(t-t4)/timeConstant)</span><span class="pln">
</span><span class="com">// Thus v(t5) = 0.5 + (0.8 - 0.5)*exp(-(t5-t4)/timeConstant)</span><span class="pln">
param</span><span class="pun">.</span><span class="pln">setValueAtTime</span><span class="pun">(</span><span class="lit">0.5</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="pun">(</span><span class="lit">0.8</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">0.5</span><span class="pun">)*</span><span class="typ">Math</span><span class="pun">.</span><span class="pln">exp</span><span class="pun">(-(</span><span class="pln">t5 </span><span class="pun">-</span><span class="pln"> t4</span><span class="pun">)/</span><span class="pln">timeConstant</span><span class="pun">),</span><span class="pln"> t5</span><span class="pun">);</span><span class="pln">
param</span><span class="pun">.</span><span class="pln">exponentialRampToValueAtTime</span><span class="pun">(</span><span class="lit">0.75</span><span class="pun">,</span><span class="pln"> t6</span><span class="pun">);</span><span class="pln">
param</span><span class="pun">.</span><span class="pln">exponentialRampToValueAtTime</span><span class="pun">(</span><span class="lit">0.05</span><span class="pun">,</span><span class="pln"> t7</span><span class="pun">);</span><span class="pln">
param</span><span class="pun">.</span><span class="pln">setValueCurveAtTime</span><span class="pun">(</span><span class="pln">curve</span><span class="pun">,</span><span class="pln"> t7</span><span class="pun">,</span><span class="pln"> t8 </span><span class="pun">-</span><span class="pln"> t7</span><span class="pun">);</span></code></pre></div>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#GainNode" typeof="bibo:Chapter">
        <h3 resource="#GainNode" id="GainNode"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.7 </span>
          The GainNode Interface
        </span></h3>
        <p>
          Changing the gain of an audio signal is a fundamental operation in
          audio applications. The <code>GainNode</code> is one of the building
          blocks for creating <a href="#mixer-gain-structure">mixers</a>. This
          interface is an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> with a single input and
          single output:
        </p>
        <pre>  numberOfInputs  : 1
  numberOfOutputs : 1

  channelCountMode = "max";
  channelInterpretation = "speakers";
</pre>
        <p>
          Each sample of each channel of the input data of the
          <a class="idlType" href="#idl-def-GainNode"><code>GainNode</code></a> <em title="MUST" class="rfc2119">MUST</em> be multiplied by the
          <a data-link-type="dfn" class="internalDFN" href="#dfn-computedvalue">computedValue</a> of the <a href="#widl-GainNode-gain"><code>gain</code></a>
          <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>.
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-GainNode">interface <span class="idlInterfaceID">GainNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-GainNode-gain">gain</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-6" typeof="bibo:Chapter" id="attributes-6"><h4 resource="#h-attributes-6" id="h-attributes-6"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.7.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-GainNode-gain"><code>gain</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            Represents the amount of gain to apply. Its default
            <code>value</code> is 1 (no gain change). The nominal
            <code>minValue</code> is 0, but may be set negative for phase
            inversion. The nominal <code>maxValue</code> is 1, but higher
            values are allowed (no exception thrown).This parameter is
            <a data-link-type="dfn" class="internalDFN" href="#a-rate">a-rate</a>
          </dd></dl></section>
      </section>
      <section property="bibo:hasPart" resource="#DelayNode" typeof="bibo:Chapter">
        <h3 resource="#DelayNode" id="DelayNode"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.8 </span>
          The DelayNode Interface
        </span></h3>
        <p>
          A delay-line is a fundamental building block in audio applications.
          This interface is an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> with a single
          input and single output:
        </p>
        <pre>    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCountMode = "max";
    channelInterpretation = "speakers";
</pre>
        <p>
          The number of channels of the output always equals the number of
          channels of the input.
        </p>
        <p>
          It delays the incoming audio signal by a certain amount.
          Specifically, at each time <em>t</em>, input signal
          <em>input(t)</em>, delay time <em>delayTime(t)</em> and output signal
          <em>output(t)</em>, the output will be <em>output(t) = input(t -
          delayTime(t))</em>. The default <code>delayTime</code> is 0 seconds
          (no delay).
        </p>
        <p>
          When the number of channels in a <a class="idlType" href="#idl-def-DelayNode"><code>DelayNode</code></a>'s input changes
          (thus changing the output channel count also), there may be delayed
          audio samples which have not yet been output by the node and are part
          of its internal state. If these samples were received earlier with a
          different channel count, they must be upmixed or downmixed before
          being combined with newly received input so that all internal
          delay-line mixing takes place using the single prevailing channel
          layout.
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-DelayNode">interface <span class="idlInterfaceID">DelayNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-DelayNode-delayTime">delayTime</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-7" typeof="bibo:Chapter" id="attributes-7"><h4 resource="#h-attributes-7" id="h-attributes-7"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.8.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-DelayNode-delayTime"><code>delayTime</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            <p>
              An <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> object representing the amount
              of delay (in seconds) to apply. Its default <code>value</code> is
              0 (no delay). The minimum value is 0 and the maximum value is
              determined by the <code>maxDelayTime</code> argument to the
              <code>AudioContext</code> method <code>createDelay</code>.
            </p>
            <p>
              If <a class="idlType" href="#idl-def-DelayNode"><code>DelayNode</code></a> is part of a <a data-link-type="dfn" class="internalDFN" href="#dfn-cycle">cycle</a>, then
              the value of the <code>delayTime</code> attribute is
              clamped to a minimum of 128 frames (one block).
            </p>
            <p>
              This parameter is <a data-link-type="dfn" class="internalDFN" href="#a-rate">a-rate</a>.
            </p>
          </dd></dl></section>
      </section>
      <section property="bibo:hasPart" resource="#AudioBuffer" typeof="bibo:Chapter">
        <h3 resource="#AudioBuffer" id="AudioBuffer"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.9 </span>
          The AudioBuffer Interface
        </span></h3>
        <p>
          This interface represents a memory-resident audio asset (for one-shot
          sounds and other short audio clips). Its format is non-interleaved
          IEEE 32-bit linear PCM with a nominal range of -1 -&gt; +1. It can
          contain one or more channels. Typically, it would be expected that
          the length of the PCM data would be fairly short (usually somewhat
          less than a minute). For longer sounds, such as music soundtracks,
          streaming should be used with the <code>audio</code> element and
          <code>MediaElementAudioSourceNode</code>.
        </p>
        <p>
          An <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a> may be used by one or more
          <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>s, and can be shared between an
          <a class="idlType" href="#idl-def-OfflineAudioContext"><code>OfflineAudioContext</code></a> and an
          <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>.
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-AudioBuffer">interface <span class="idlInterfaceID">AudioBuffer</span> {
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">float</span>  <span class="idlAttrName"><a href="#widl-AudioBuffer-sampleRate">sampleRate</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">long</span>   <span class="idlAttrName"><a href="#widl-AudioBuffer-length">length</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">double</span> <span class="idlAttrName"><a href="#widl-AudioBuffer-duration">duration</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">long</span>   <span class="idlAttrName"><a href="#widl-AudioBuffer-numberOfChannels">numberOfChannels</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType">Float32Array</span> <span class="idlMethName"><a href="#widl-AudioBuffer-getChannelData-Float32Array-unsigned-long-channel">getChannelData</a></span> (<span class="idlParam"><span class="idlParamType">unsigned long</span> <span class="idlParamName">channel</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span>         <span class="idlMethName"><a href="#widl-AudioBuffer-copyFromChannel-void-Float32Array-destination-unsigned-long-channelNumber-unsigned-long-startInChannel">copyFromChannel</a></span> (<span class="idlParam"><span class="idlParamType">Float32Array</span> <span class="idlParamName">destination</span></span>, <span class="idlParam"><span class="idlParamType">unsigned long</span> <span class="idlParamName">channelNumber</span></span>, <span class="idlParam">optional <span class="idlParamType">unsigned long</span> <span class="idlParamName">startInChannel</span> = <span class="idlDefaultValue">0
              </span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span>         <span class="idlMethName"><a href="#widl-AudioBuffer-copyToChannel-void-Float32Array-source-unsigned-long-channelNumber-unsigned-long-startInChannel">copyToChannel</a></span> (<span class="idlParam"><span class="idlParamType">Float32Array</span> <span class="idlParamName">source</span></span>, <span class="idlParam"><span class="idlParamType">unsigned long</span> <span class="idlParamName">channelNumber</span></span>, <span class="idlParam">optional <span class="idlParamType">unsigned long</span> <span class="idlParamName">startInChannel</span> = <span class="idlDefaultValue">0
              </span></span>);</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-8" typeof="bibo:Chapter" id="attributes-8"><h4 resource="#h-attributes-8" id="h-attributes-8"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.9.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-AudioBuffer-duration"><code>duration</code> of type <span class="idlAttrType">double</span>, readonly       </dt><dd>
            Duration of the PCM audio data in seconds.
          </dd><dt id="widl-AudioBuffer-length"><code>length</code> of type <span class="idlAttrType">long</span>, readonly       </dt><dd>
            Length of the PCM audio data in sample-frames.
          </dd><dt id="widl-AudioBuffer-numberOfChannels"><code>numberOfChannels</code> of type <span class="idlAttrType">long</span>, readonly       </dt><dd>
            The number of discrete audio channels.
          </dd><dt id="widl-AudioBuffer-sampleRate"><code>sampleRate</code> of type <span class="idlAttrType">float</span>, readonly       </dt><dd>
            The sample-rate for the PCM audio data in samples per second.
          </dd></dl></section><section property="bibo:hasPart" resource="#methods-5" typeof="bibo:Chapter" id="methods-5"><h4 resource="#h-methods-5" id="h-methods-5"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.9.2 </span>Methods</span></h4><dl class="methods"><dt id="widl-AudioBuffer-copyFromChannel-void-Float32Array-destination-unsigned-long-channelNumber-unsigned-long-startInChannel"><code>copyFromChannel</code></dt><dd>
            The <code>copyFromChannel</code> method copies the samples from the
            specified channel of the <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a> to the
            <code>destination</code> array.

          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">destination</td><td class="prmType"><code>Float32Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The array the channel data will be copied to.
              </td></tr><tr><td class="prmName">channelNumber</td><td class="prmType"><code>unsigned long</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The index of the channel to copy the data from. If
                <code>channelNumber</code> is greater or equal than the number
                of channel of the <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>, an
                <code>IndexSizeError</code> <em title="MUST" class="rfc2119">MUST</em> be thrown.
              </td></tr><tr><td class="prmName">startInChannel</td><td class="prmType"><code>unsigned long = 0
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                An optional offset to copy the data from. If
                <code>startInChannel</code> is greater than the
                <code>length</code> of the <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>, an
                <code>IndexSizeError</code> <em title="MUST" class="rfc2119">MUST</em> be thrown.
              </td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-AudioBuffer-copyToChannel-void-Float32Array-source-unsigned-long-channelNumber-unsigned-long-startInChannel"><code>copyToChannel</code></dt><dd>
            The <code>copyToChannel</code> method copies the samples to the
            specified channel of the <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>, from the
            <code>source</code> array.

          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">source</td><td class="prmType"><code>Float32Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The array the channel data will be copied from.
              </td></tr><tr><td class="prmName">channelNumber</td><td class="prmType"><code>unsigned long</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                The index of the channel to copy the data to. If
                <code>channelNumber</code> is greater or equal than the number
                of channel of the <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>, an
                <code>IndexSizeError</code> <em title="MUST" class="rfc2119">MUST</em> be thrown.
              </td></tr><tr><td class="prmName">startInChannel</td><td class="prmType"><code>unsigned long = 0
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                An optional offset to copy the data to. If
                <code>startInChannel</code> is greater than the
                <code>length</code> of the <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>, an
                <code>IndexSizeError</code> <em title="MUST" class="rfc2119">MUST</em> be thrown.
              </td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-AudioBuffer-getChannelData-Float32Array-unsigned-long-channel"><code>getChannelData</code></dt><dd>
            Returns the <code>Float32Array</code> representing the PCM audio
            data for the specific channel.

          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">channel</td><td class="prmType"><code>unsigned long</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                This parameter is an index representing the particular channel
                to get data for. An index value of 0 represents the first
                channel. This index value <em title="MUST" class="rfc2119">MUST</em> be less than
                <code>numberOfChannels</code> or an IndexSizeError exception
                <em title="MUST" class="rfc2119">MUST</em> be thrown.
              </td></tr></tbody></table><div><em>Return type: </em><code>Float32Array</code></div></dd></dl></section>
        <div class="note"><div id="h-note2" role="heading" aria-level="4" class="note-title"><span>Note</span></div><p class="">
          The methods <code>copyToChannel</code> and
          <code>copyFromChannel</code> can be used to fill part of an array by
          passing in a <code>Float32Array</code> that's a view onto the larger
          array. When reading data from an <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>'s channels, and
          the data can be processed in chunks, <code>copyFromChannel</code>
          should be preferred to calling <code>getChannelData</code> and
          accessing the resulting array, because it may avoid unnecessary
          memory allocation and copying.
        </p></div>
        <p>
          An internal operation <a href="#acquire-the-content">acquire the
          contents of an <code>AudioBuffer</code></a> is invoked when the
          contents of an <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a> are needed by some <abbr title="Application Programming Interface">API</abbr>
          implementation. This operation returns immutable channel data to the
          invoker.
        </p>
        <p>
          When an <dfn data-dfn-type="dfn" id="acquire-the-content">acquire the content</dfn>
          operation occurs on an <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>, run the following steps:
        </p>
        <ol>
          <li>If any of the <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>'s <code>ArrayBuffer</code> have
          been neutered, abort these steps, and return a zero-length channel
          data buffers to the invoker.
          </li>
          <li>Neuter all <code>ArrayBuffer</code>s for arrays previously
          returned by <code>getChannelData</code> on this <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>.
          </li>
          <li>Retain the underlying data buffers from those
          <code>ArrayBuffer</code>s and return references to them to the
          invoker.
          </li>
          <li>Attach <code>ArrayBuffer</code>s containing copies of the data to
          the <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>, to be returned by the next call to
          <code>getChannelData</code>.
          </li>
        </ol>The <a href="#acquire-the-content">acquire the contents of an
        AudioBuffer</a> operation is invoked in the following cases:
        <ul>
          <li>When <code>AudioBufferSourceNode.start</code> is called, it
          <a href="#acquire-the-content">acquires the contents</a> of the
          node's <code>buffer</code>. If the operation fails, nothing is
          played.
          </li>
          <li>When a <a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a>'s <code>buffer</code> is set to an
          <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a> while the node is connected to an output node, or
          a <a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a> is connected to an output node while the
          <a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a>'s <code>buffer</code> is set to an
          <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>, it <a href="#acquire-the-content">acquires the
          content</a> of the <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>.
          </li>
          <li>When the dispatch of an <a class="idlType" href="#idl-def-AudioProcessingEvent"><code>AudioProcessingEvent</code></a> completes, it
          <a href="#acquire-the-content">acquires the contents</a> of its
          <code>outputBuffer</code>.
          </li>
        </ul>
        <div class="note"><div id="h-note3" role="heading" aria-level="4" class="note-title"><span>Note</span></div><p class="">
          This means that <code>copyToChannel</code> cannot be used to change
          the content of an <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a> currently in use by an
          <code>AudioNode</code> that has <a href="#acquire-the-content">acquired the content of an AudioBuffer</a>,
          since the <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> will continue to use the data previously
          acquired.
        </p></div>
      </section>
      <section property="bibo:hasPart" resource="#AudioBufferSourceNode" typeof="bibo:Chapter">
        <h3 resource="#AudioBufferSourceNode" id="AudioBufferSourceNode"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.10 </span>
          The AudioBufferSourceNode Interface
        </span></h3>
        <p>
          This interface represents an audio source from an in-memory audio
          asset in an <code>AudioBuffer</code>. It is useful for playing audio
          assets which require a high degree of scheduling flexibility, for
          instance, playing back in rhythmically-perfect ways. If
          sample-accurate playback of network- or disk-backed assets is
          required, an implementer should use <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a>
          to implement playback.
        </p>
        <p>
          The start() method is used to schedule when sound playback will
          happen. The start() method may not be issued multiple times. The
          playback will stop automatically when the buffer's audio data has
          been completely played (if the <code>loop</code> attribute is false),
          or when the stop() method has been called and the specified time has
          been reached. Please see more details in the start() and stop()
          description.
        </p>
        <pre>  numberOfInputs  : 0
  numberOfOutputs : 1
</pre>
        <p>
          The number of channels of the output always equals the number of
          channels of the AudioBuffer assigned to the .buffer attribute, or is
          one channel of silence if .buffer is NULL.
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-AudioBufferSourceNode">interface <span class="idlInterfaceID">AudioBufferSourceNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlAttribute">                    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>?</span> <span class="idlAttrName"><a href="#widl-AudioBufferSourceNode-buffer">buffer</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>   <span class="idlAttrName"><a href="#widl-AudioBufferSourceNode-playbackRate">playbackRate</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>   <span class="idlAttrName"><a href="#widl-AudioBufferSourceNode-detune">detune</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">boolean</span>      <span class="idlAttrName"><a href="#widl-AudioBufferSourceNode-loop">loop</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">double</span>       <span class="idlAttrName"><a href="#widl-AudioBufferSourceNode-loopStart">loopStart</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">double</span>       <span class="idlAttrName"><a href="#widl-AudioBufferSourceNode-loopEnd">loopEnd</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-AudioBufferSourceNode-start-void-double-when-double-offset-double-duration">start</a></span> (<span class="idlParam">optional <span class="idlParamType">double</span> <span class="idlParamName">when</span> = <span class="idlDefaultValue">0
              </span></span>, <span class="idlParam">optional <span class="idlParamType">double</span> <span class="idlParamName">offset</span> = <span class="idlDefaultValue">0
              </span></span>, <span class="idlParam">optional <span class="idlParamType">double</span> <span class="idlParamName">duration</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-AudioBufferSourceNode-stop-void-double-when">stop</a></span> (<span class="idlParam">optional <span class="idlParamType">double</span> <span class="idlParamName">when</span> = <span class="idlDefaultValue">0
              </span></span>);</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-AudioBufferSourceNode-onended">onended</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-9" typeof="bibo:Chapter" id="attributes-9"><h4 resource="#h-attributes-9" id="h-attributes-9"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.10.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-AudioBufferSourceNode-buffer"><code>buffer</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a></span>, nullable</dt><dd>
            Represents the audio asset to be played. This attribute can only be
            set once, or a <code>InvalidStateError</code> <em title="MUST" class="rfc2119">MUST</em> be thrown.
          </dd><dt id="widl-AudioBufferSourceNode-detune"><code>detune</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            An aditional parameter to modulate the speed at which is rendered
            the audio stream. Its default value is 0. Its nominal range is
            [-1200; 1200]. This parameter is <a data-link-type="dfn" class="internalDFN" href="#k-rate">k-rate</a>.
          </dd><dt id="widl-AudioBufferSourceNode-loop"><code>loop</code> of type <span class="idlAttrType">boolean</span></dt><dd>
            Indicates if the audio data should play in a loop. The default
            value is false. If <code>loop</code> is dynamically modified during
            playback, the new value will take effect on the next processing
            block of audio.
          </dd><dt id="widl-AudioBufferSourceNode-loopEnd"><code>loopEnd</code> of type <span class="idlAttrType">double</span></dt><dd>
            An optional value in seconds where looping should end if the
            <code>loop</code> attribute is true. Its value is exclusive of the
            content of the loop: the sample frames comprising the loop run from
            the values <code>loopStart</code> to
            <code>loopEnd-(1.0/sampleRate)</code>. Its default
            <code>value</code> is 0, and it may usefully be set to any value
            between 0 and the duration of the buffer. If <code>loopEnd</code>
            is less than 0, looping will end at 0. If <code>loopEnd</code> is
            greater than the duration of the buffer, looping will end at the
            end of the buffer. This attribute is converted to an exact sample
            frame offset within the buffer by multiplying by the buffer's
            sample rate and rounding to the nearest integer value. Thus its
            behavior is independent of the value of the <a href="#widl-AudioBufferSourceNode-playbackRate"><code>playbackRate</code></a>
            parameter.
          </dd><dt id="widl-AudioBufferSourceNode-loopStart"><code>loopStart</code> of type <span class="idlAttrType">double</span></dt><dd>
            An optional value in seconds where looping should begin if the
            <code>loop</code> attribute is true. Its default <code>value</code>
            is 0, and it may usefully be set to any value between 0 and the
            duration of the buffer. If <code>loopStart</code> is less than 0,
            looping will begin at 0. If <code>loopStart</code> is greater than
            the duration of the buffer, looping will begin at the end of the
            buffer. This attribute is converted to an exact sample frame offset
            within the buffer by multiplying by the buffer's sample rate and
            rounding to the nearest integer value. Thus its behavior is
            independent of the value of the <a href="#widl-AudioBufferSourceNode-playbackRate"><code>playbackRate</code></a>
            parameter.
          </dd><dt id="widl-AudioBufferSourceNode-onended"><code>onended</code> of type <span class="idlAttrType">EventHandler</span></dt><dd>
            A property used to set the <code>EventHandler</code> (described in
            <cite><a href="https://html.spec.whatwg.org/multipage/webappapis.html#eventhandler">
            HTML</a></cite>[<cite><a href="#bib-HTML" class="bibref">HTML</a></cite>]) for the ended event that is dispatched to
            <a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a> node types. When the
            playback of the buffer for an
            <a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a> is finished, an event of
            type <code>Event</code> (described in <cite><a href="https://html.spec.whatwg.org/multipage/infrastructure.html#event">HTML</a></cite>
            [<cite><a href="#bib-HTML" class="bibref">HTML</a></cite>]) will be dispatched to the event handler.
          </dd><dt id="widl-AudioBufferSourceNode-playbackRate"><code>playbackRate</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            The speed at which to render the audio stream. Its default
            <code>value</code> is 1. This parameter is <a data-link-type="dfn" class="internalDFN" href="#k-rate">k-rate</a>.
          </dd></dl></section><section property="bibo:hasPart" resource="#methods-6" typeof="bibo:Chapter" id="methods-6"><h4 resource="#h-methods-6" id="h-methods-6"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.10.2 </span>Methods</span></h4><dl class="methods"><dt id="widl-AudioBufferSourceNode-start-void-double-when-double-offset-double-duration"><code>start</code></dt><dd>
            Schedules a sound to playback at an exact time. <code>start</code>
            may only be called one time and must be called before
            <code>stop</code> is called or an InvalidStateError exception <em title="MUST" class="rfc2119">MUST</em>
            be thrown.

          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">when</td><td class="prmType"><code>double = 0
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                The <code>when</code> parameter describes at what time
                (in seconds) the sound should start playing. It is in the same
                time coordinate system as the
                <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s <a href="#widl-BaseAudioContext-currentTime">currentTime</a> attribute.
                If 0 is passed in for this value or if the value is less than
                <b>currentTime</b>, then the sound will start playing
                immediately. A TypeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown if
                <code>when</code> is negative.
              </td></tr><tr><td class="prmName">offset</td><td class="prmType"><code>double = 0
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                The <dfn data-dfn-type="dfn" id="dfn-offset">offset</dfn> parameter describes the
                offset time in the buffer (in seconds) where playback will
                begin. If 0 is passed in for this value, then playback will
                start from the beginning of the buffer. A TypeError exception
                <em title="MUST" class="rfc2119">MUST</em> be thrown if <code>offset</code> is negative. If
                <code>offset</code> is greater than <code>loopEnd</code>,
                playback will begin at <code>loopEnd</code> (and immediately
                loop to <code>loopStart</code>). This parameter is converted to
                an exact sample frame offset within the buffer by multiplying
                by the buffer's sample rate and rounding to the nearest integer
                value. Thus its behavior is independent of the value of the
                <a href="#widl-AudioBufferSourceNode-playbackRate"><code>playbackRate</code></a>
                parameter.
              </td></tr><tr><td class="prmName">duration</td><td class="prmType"><code>double</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                The <code>duration</code> parameter describes the
                duration of the portion (in seconds) to be played. If this
                parameter is not passed, the duration will be equal to the
                total duration of the AudioBuffer minus the <code>offset</code>
                parameter. Thus if neither <code>offset</code> nor
                <code>duration</code> are specified then the implied duration
                is the total duration of the AudioBuffer. An TypeError
                exception <em title="MUST" class="rfc2119">MUST</em> be thrown if <code>duration</code> is negative.
              </td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-AudioBufferSourceNode-stop-void-double-when"><code>stop</code></dt><dd>
            Schedules a sound to stop playback at an exact time.

          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">when</td><td class="prmType"><code>double = 0
              </code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc">
                The <code>when</code> parameter describes at what time
                (in seconds) the sound should stop playing. It is in the same
                time coordinate system as the
                <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s <a href="#widl-BaseAudioContext-currentTime">currentTime</a> attribute.
                If 0 is passed in for this value or if the value is less than
                <code>currentTime</code>, then the sound will stop
                playing immediately. A TypeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown if
                <code>when</code> is negative. If <code>stop</code> is called
                again after already have been called, the last invocation will
                be the only one applied; stop times set by previous calls will
                not be applied, unless the buffer has already stopped prior to
                any subsequent calls. If the buffer has already stopped,
                further calls to <code>stop</code> will have no effect. If a
                stop time is reached prior to the scheduled start time, the
                sound will not play.
              </td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd></dl></section>
        <p>
          Both <code>playbackRate</code> and <code>detune</code> are
          <a data-link-type="dfn" class="internalDFN" href="#k-rate">k-rate</a> parameters and are used together to determine a
          <em>computedPlaybackRate</em> value:
        </p>
        <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">  computedPlaybackRate</span><span class="pun">(</span><span class="pln">t</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> playbackRate</span><span class="pun">(</span><span class="pln">t</span><span class="pun">)</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> pow</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> detune</span><span class="pun">(</span><span class="pln">t</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">1200</span><span class="pun">)</span></pre>
        <p>
          The <code>computedPlaybackRate</code> is the effective speed at which
          the <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a> of this
          <a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a> <em title="MUST" class="rfc2119">MUST</em> be played.
        </p>
        <p>
          This <em title="MUST" class="rfc2119">MUST</em> be implemented by <em>resampling</em> the input data using
          a resampling ratio of 1 / <code>computedPlaybackRate</code>, hence
          changing both the pitch and speed of the audio.
        </p>
        <section property="bibo:hasPart" resource="#looping-AudioBufferSourceNode" typeof="bibo:Chapter">
          <h4 resource="#looping-AudioBufferSourceNode" id="looping-AudioBufferSourceNode"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.10.3 </span>
            Looping
          </span></h4>
          <p>
            If the <code>loop</code> attribute is true when
            <code>start()</code> is called, then playback will continue
            indefinitely until <code>stop()</code> is called and the stop time
            is reached. We'll call this "loop" mode. Playback always starts at
            the point in the buffer indicated by the <code>offset</code>
            argument of <code>start()</code>, and in <em>loop</em> mode will
            continue playing until it reaches the <em>actualLoopEnd</em>
            position in the buffer (or the end of the buffer), at which point
            it will wrap back around to the <em>actualLoopStart</em> position
            in the buffer, and continue playing according to this pattern.
          </p>
          <p>
            In <em>loop</em> mode then the <em>actual</em> loop points are
            calculated as follows from the <code>loopStart</code> and
            <code>loopEnd</code> attributes:
          </p>
          <blockquote>
            <pre style="" class="highlight prettyprint prettyprinted"><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">loopStart </span><span class="pun">||</span><span class="pln"> loopEnd</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> loopStart </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> loopEnd </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> loopStart </span><span class="pun">&lt;</span><span class="pln"> loopEnd</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    actualLoopStart </span><span class="pun">=</span><span class="pln"> loopStart</span><span class="pun">;</span><span class="pln">
    actualLoopEnd </span><span class="pun">=</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">loopEnd</span><span class="pun">,</span><span class="pln"> buffer</span><span class="pun">.</span><span class="pln">duration</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    actualLoopStart </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    actualLoopEnd </span><span class="pun">=</span><span class="pln"> buffer</span><span class="pun">.</span><span class="pln">duration</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></pre>
          </blockquote>
          <p>
            Note that the default <code>value</code>s for
            <code>loopStart</code> and <code>loopEnd</code> are both 0, which
            indicates that looping should occur from the very start to the very
            end of the buffer.
          </p>
          <p>
            Please note that as a low-level implementation detail, the
            AudioBuffer is at a specific sample-rate (usually the same as the
            <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> sample-rate), and that the loop
            times (in seconds) must be converted to the appropriate
            sample-frame positions in the buffer according to this sample-rate.
          </p>
          <p>
            When scheduling the beginning and the end of playback using the
            <code>start()</code> and <code>stop()</code> methods, the resulting
            start or stop time <em title="MUST" class="rfc2119">MUST</em> be rounded to the nearest sample-frame in
            the sample rate of the <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>. That is,
            no sub-sample scheduling is possible.
          </p>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#MediaElementAudioSourceNode" typeof="bibo:Chapter">
        <h3 resource="#MediaElementAudioSourceNode" id="MediaElementAudioSourceNode"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.11 </span>
          The MediaElementAudioSourceNode Interface
        </span></h3>
        <p>
          This interface represents an audio source from an <code>audio</code>
          or <code>video</code> element.
        </p>
        <pre>  numberOfInputs  : 0
  numberOfOutputs : 1
</pre>
        <p>
          The number of channels of the output corresponds to the number of
          channels of the media referenced by the
          <code>HTMLMediaElement</code>. Thus, changes to the media element's
          .src attribute can change the number of channels output by this node.
          If the .src attribute is not set, then the number of channels output
          will be one silent channel.
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-MediaElementAudioSourceNode">interface <span class="idlInterfaceID">MediaElementAudioSourceNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
};</span></pre>
        <p>
          A <a class="idlType" href="#idl-def-MediaElementAudioSourceNode"><code>MediaElementAudioSourceNode</code></a> is created given an
          <code>HTMLMediaElement</code> using the <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>
          <code>createMediaElementSource()</code> method.
        </p>
        <p>
          The number of channels of the single output equals the number of
          channels of the audio referenced by the <code>HTMLMediaElement</code>
          passed in as the argument to <code>createMediaElementSource()</code>,
          or is 1 if the <code>HTMLMediaElement</code> has no audio.
        </p>
        <p>
          The <code>HTMLMediaElement</code> must behave in an identical fashion
          after the <a class="idlType" href="#idl-def-MediaElementAudioSourceNode"><code>MediaElementAudioSourceNode</code></a> has been created,
          <em>except</em> that the rendered audio will no longer be heard
          directly, but instead will be heard as a consequence of the
          <a class="idlType" href="#idl-def-MediaElementAudioSourceNode"><code>MediaElementAudioSourceNode</code></a> being connected through the
          routing graph. Thus pausing, seeking, volume, <code>src</code>
          attribute changes, and other aspects of the
          <code>HTMLMediaElement</code> must behave as they normally would if
          <em>not</em> used with a <a class="idlType" href="#idl-def-MediaElementAudioSourceNode"><code>MediaElementAudioSourceNode</code></a>.
        </p>
        <div class="example"><div class="example-title"><span>Example 7</span></div><pre style="" class="highlight example prettyprint prettyprinted"><span class="kwd">var</span><span class="pln"> mediaElement </span><span class="pun">=</span><span class="pln"> document</span><span class="pun">.</span><span class="pln">getElementById</span><span class="pun">(</span><span class="str">'mediaElementID'</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> sourceNode </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createMediaElementSource</span><span class="pun">(</span><span class="pln">mediaElement</span><span class="pun">);</span><span class="pln">
sourceNode</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">filterNode</span><span class="pun">);</span></pre></div>
        <section property="bibo:hasPart" resource="#security-with-mediaelementaudiosourcenode-and-cross-origin-resources" typeof="bibo:Chapter" id="security-with-mediaelementaudiosourcenode-and-cross-origin-resources">
          <h4 resource="#h-security-with-mediaelementaudiosourcenode-and-cross-origin-resources" id="h-security-with-mediaelementaudiosourcenode-and-cross-origin-resources"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.11.1 </span>
            Security with MediaElementAudioSourceNode and cross-origin
            resources
          </span></h4>
          <p>
            <code>HTMLMediaElement</code> allows the playback of cross-origin
            resources. Because Web Audio can allows one to inspect the content
            of the resource (e.g. using a <a class="idlType" href="#idl-def-MediaElementAudioSourceNode"><code>MediaElementAudioSourceNode</code></a>,
            and a <a class="idlType" href="#idl-def-ScriptProcessorNode"><code>ScriptProcessorNode</code></a> to read the samples), information
            leakage can occur if scripts from one <a href="http://www.w3.org/html/wg/drafts/html/master/browsers.html#origin">
            origin</a> inspect the content of a resource from another <a href="http://www.w3.org/html/wg/drafts/html/master/browsers.html#origin">
            origin</a>.
          </p>
          <p>
            To prevent this, a <a class="idlType" href="#idl-def-MediaElementAudioSourceNode"><code>MediaElementAudioSourceNode</code></a> <em title="MUST" class="rfc2119">MUST</em> output
            <em>silence</em> instead of the normal output of the
            <code>HTMLMediaElement</code> if it has been created using an
            <code>HTMLMediaElement</code> for which the execution of the
            <!--a href=
            "http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#cors-enabled-fetch"-->
            fetch algorithm labeled the resource as <a href="http://www.w3.org/html/wg/drafts/html/master/infrastructure.html#cors-cross-origin">
            CORS-cross-origin</a>.
          </p>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#AudioWorker" typeof="bibo:Chapter">
        <h3 resource="#AudioWorker" id="AudioWorker"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12 </span>
          <dfn id="dfn-audioworker" data-dfn-type="dfn">AudioWorker</dfn> インターフェース <button onclick="OpenOriginal('AudioWorker')">原文</button>
        </span></h3>
<!--        <p>
          An AudioWorker object is the main-thread representation of a worker
          "thread" that supports processing of audio in Javascript. This
          AudioWorker object is a factory that is used to create multiple audio
          nodes of the same type; this enables easy sharing of code, program
          data and global state across nodes. An AudioWorker can then be used
          to create instances of <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a>, which is the
          main-thread representation of an individual node processed by that
          AudioWorker.
        </p>-->
        <p>
          AudioWorker オブジェクトは Javascript でオーディオを処理するワーカー"スレッド"のメインスレッドでの表現です。
          この AudioWorker オブジェクトは同じタイプの複数のオーディオノードを作成するのに使用されるファクトリになっています。
          つまりこれによりコード、プログラムデータ、グローバルな状態をノードをまたいで共有する事が簡単にできます。
          AudioWorker はその AudioWorker で処理される個別のノードのメインスレッドでの表現である <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> のインスタンスを作成するために使用されます。
        </p>
<!--        <p>
          These main thread objects cause the instantiation of a processing
          context in the audio thread. All audio processing by AudioWorkerNodes
          runs in the audio processing thread. This has a few side effects that
          bear mentioning: blocking the audio worker's thread can cause
          glitches in the audio, and if the audio thread is normally elevated
          in thread priority (to reduce glitching possibility), it must be
          demoted to normal thread priority (in order to avoid escalating
          thread priority of user-supplied script code).
        </p>-->
        <p>
          これらのメインスレッドオブジェクトはオーディオスレッドでのコンテキストの処理をインスタンス化します。
          全ての AudioWorkerNode のオーディオ処理はオーディオ処理スレッド内で実行されます。
          これは特に注意すべき幾つかの副作用を持っています:
          オーディオワーカーのスレッドをブロックすると音のグリッジが発生し、(グリッジが起こる可能性を下げるために)もしオーディオ処理スレッドの優先度を上げるなら(ユーザーが供給するスクリプトコードのスレッド優先度の上昇の連鎖を避けるため)通常のスレッドの優先度を格下げしなくてはなりません。
        </p>
<!--        <p>
          From inside an audio worker script, the Audio Worker factory is
          represented by an <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> object
          representing the node's contextual information, and individual audio
          nodes created by the factory are represented by
          <a class="idlType" href="#idl-def-AudioWorkerNodeProcessor"><code>AudioWorkerNodeProcessor</code></a> objects.
        </p>-->
        <p>
          オーディオワーカースクリプトの内部からは、オーディオワーカーのファクトリはノードのコンテキストの情報を表す <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> オブジェクトとして、ファクトリで作成された個別のノードは <a class="idlType" href="#idl-def-AudioWorkerNodeProcessor"><code>AudioWorkerNodeProcessor</code></a> として見えます。
        </p>
<!--        <p>
          In addition, all <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a>s that are created by the same
          <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a> share an <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a>; this can
          allow them to share context and data across nodes (for example,
          loading a single instance of a shared database used by the individual
          nodes, or sharing context in order to implement oscillator
          synchronization).
        </p>-->
        <p>
          加えて、同じ <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a> で作成された全ての <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> は <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> を共有します。つまりこれにより、それらのノードはコンテキストを共有し、ノードをまたいでデータの共有(例えば、1つの共有データベースの実体をロードして各ノードで使用する、あるいはコンテキストを共有してオシレータの同期を実装するなど)ができます。
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-AudioWorker">interface <span class="idlInterfaceID">AudioWorker</span> : <span class="idlSuperclass">Worker</span> {
<span class="idlMethod">    <span class="idlMethType">void</span>            <span class="idlMethName"><a href="#widl-AudioWorker-terminate-void">terminate</a></span> ();</span>
<span class="idlMethod">    <span class="idlMethType">void</span>            <span class="idlMethName"><a href="#widl-AudioWorker-postMessage-void-any-message-sequence-Transferable--transfer">postMessage</a></span> (<span class="idlParam"><span class="idlParamType">any</span> <span class="idlParamName">message</span></span>, <span class="idlParam">optional <span class="idlParamType">sequence&lt;Transferable&gt;</span> <span class="idlParamName">transfer</span></span>);</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioWorkerParamDescriptor"><code>AudioWorkerParamDescriptor</code></a>[]</span> <span class="idlAttrName"><a href="#widl-AudioWorker-parameters">parameters</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">EventHandler</span>                 <span class="idlAttrName"><a href="#widl-AudioWorker-onmessage">onmessage</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">EventHandler</span>                 <span class="idlAttrName"><a href="#widl-AudioWorker-onloaded">onloaded</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a></span> <span class="idlMethName"><a href="#widl-AudioWorker-createNode-AudioWorkerNode-int-numberOfInputs-int-numberOfOutputs">createNode</a></span> (<span class="idlParam"><span class="idlParamType">int</span> <span class="idlParamName">numberOfInputs</span></span>, <span class="idlParam"><span class="idlParamType">int</span> <span class="idlParamName">numberOfOutputs</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>      <span class="idlMethName"><a href="#widl-AudioWorker-addParameter-AudioParam-DOMString-name-float-defaultValue">addParameter</a></span> (<span class="idlParam"><span class="idlParamType">DOMString</span> <span class="idlParamName">name</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">defaultValue</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span>            <span class="idlMethName"><a href="#widl-AudioWorker-removeParameter-void-DOMString-name">removeParameter</a></span> (<span class="idlParam"><span class="idlParamType">DOMString</span> <span class="idlParamName">name</span></span>);</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-10" typeof="bibo:Chapter" id="attributes-10"><h4 resource="#h-attributes-10" id="h-attributes-10"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.1 </span>属性 <button onclick="OpenOriginal('h-attributes-10')">原文</button></span></h4><dl class="attributes"><dt id="widl-AudioWorker-onloaded"><code>onloaded</code> <span class="idlAttrType">EventHandler</span>型</dt>
<!--  <dd>
            The onloaded handler is called after the script is successfully
            loaded and its global scope code is run to initialize the
            <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a>.
  </dd>-->
  <dd>
      onloaded ハンドラーはスクリプトの読み込みに成功した後に呼び出され、<a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> を初期化するためにそのグローバルスコープのコードが実行されます。
  </dd>

          <dt id="widl-AudioWorker-onmessage"><code>onmessage</code> <span class="idlAttrType">EventHandler</span>型</dt>
<!--  <dd>
      The onmessage handler is called whenever the
      <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> posts a message back to the main
      thread.
  </dd>-->
  <dd>
      onmessage ハンドラーは <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> がメインスレッドにメッセージをポストした時に常に呼び出されます。
  </dd>
          <dt id="widl-AudioWorker-parameters"><code>parameters</code> array of <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioWorkerParamDescriptor"><code>AudioWorkerParamDescriptor</code></a></span>型, readonly       </dt>
<!--          <dd>
            This array contains descriptors for each of the current parameters
            on nodes created by this AudioWorker. This enables users of the
            AudioWorker to easily iterate over the AudioParam names and default
            values.
          </dd>-->
          <dd>
            この配列はこの AudioWorker で作成されたノードの現在の各パラメータのディスクリプタを保持しています。
            これにより、AudioWorker のユーザーは簡単に AudioParam の名前とデフォルト値に対する繰り返し処理を行う事ができます。
          </dd>

        </dl></section><section property="bibo:hasPart" resource="#methods-7" typeof="bibo:Chapter" id="methods-7"><h4 resource="#h-methods-7" id="h-methods-7"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.2 </span>メソッド <button onclick="OpenOriginal('h-methods-7')">原文</button></span></h4><dl class="methods"><dt id="widl-AudioWorker-addParameter-AudioParam-DOMString-name-float-defaultValue"><code>addParameter</code></dt><dd>
<!--          <p>
            Causes a correspondingly-named read-only <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> to be
            present on any <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a>s created (previously or
            subsequently) by this <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a>, and a
            correspondingly-named read-only Float32Array to be present
            on the <code>parameters</code> object exposed on the
            <a class="idlType" href="#idl-def-AudioProcessEvent"><code>AudioProcessEvent</code></a> on subsequent audio processing events
            for such nodes. The AudioParam may immediately have its
            scheduling methods called, its .value set, or
            <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s connected to it.
          </p>-->
          <p>
            この <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a> によって作成される(既に存在するあるいは今後作成される)全ての <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> に名前に対応したリードオンリーの <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> を付加し、
            以降のこれらのノードの <a class="idlType" href="#idl-def-AudioProcessEvent"><code>AudioProcessEvent</code></a>  上に現れる <code>parameters</code> オブジェクトに名前に対応したリードオンリーの Float32Array を付加します。
             AudioParam は即時にそのスケジューリングメソッドが呼び出されたり、 .value に値を設定されたり、あるいは <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> から接続されたりするかも知れません。
          </p>
<!--          <p>
            The <code>name</code> parameter is the name used for the
            read-only AudioParam added to the AudioWorkerNode, and the name
            used for the read-only <code>Float32Array</code> that will be
            present on the <code>parameters</code> object exposed on
            subsequent <a class="idlType" href="#idl-def-AudioProcessEvent"><code>AudioProcessEvent</code></a>s.
          </p>-->
          <p>
            <code>name</code> パラメータはそのリードオンリーの AudioParam を AudioWorkerNode に追加する際に使用され、また、以降の <a class="idlType" href="#idl-def-AudioProcessEvent"><code>AudioProcessEvent</code></a> 上の <code>parameters</code> オブジェクトでのリードオンリー <code>Float32Array</code> の名前として使用されます。
          </p>
<!--          <p>
            The <a data-link-type="dfn" class="internalDFN" href="#dfn-defaultValue"><code>defaultValue</code></a> parameter is the default
            value for the <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>'s value attribute, as well
            as therefore the default value that will appear in the
            Float32Array in the worker script (if no other parameter changes
            or connections affect the value).
          </p>-->
          <p>
            <a data-link-type="dfn" class="internalDFN" href="#dfn-defaultValue"><code>defaultValue</code></a> パラメータはその <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> の value 属性のデフォルト値です。そのため、ワーカースクリプトでは(もしパラメータの書き換えや接続によって値が変わらなければ) Float32Array のデフォルトの値として現れます。
          </p>
          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">name</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">defaultValue</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></code></div></dd><dt id="widl-AudioWorker-createNode-AudioWorkerNode-int-numberOfInputs-int-numberOfOutputs"><code>createNode</code></dt>
          <dd>
            <!--<p>Creates a node instance in the audio worker.</p>-->
            オーディオワーカー内でノードのインスタンスを作成します。
          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">numberOfInputs</td><td class="prmType"><code>int</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">numberOfOutputs</td><td class="prmType"><code>int</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a></code></div></dd><dt id="widl-AudioWorker-postMessage-void-any-message-sequence-Transferable--transfer"><code>postMessage</code></dt>
          <dd>
<!--            <p>
            postMessage may be called to send a message to the
            <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a>, similar to the algorithm defined by
            [<cite><a href="#bib-Workers" class="bibref">Workers</a></cite>].
          </p>-->
            postMessage は [<cite><a href="#bib-Workers" class="bibref">Workers</a></cite>] で定義されているアルゴリズムと同様に、<a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> にメッセージを送るために呼ばれます。
          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">message</td><td class="prmType"><code>any</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">transfer</td><td class="prmType"><code>sequence&lt;Transferable&gt;</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>戻り値: </em><code>void</code></div></dd>
          <dt id="widl-AudioWorker-removeParameter-void-DOMString-name"><code>removeParameter</code></dt><dd>
<!--            <p>
              Removes a previously-added parameter named <code>name</code> from
              all <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a>s associated with this
              <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a> and its <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a>. This
              will also remove the correspondingly-named read-only
              <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> from the <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a>, and will
              remove the correspondingly-named read-only Float32Arrays
              from the <a class="idlType" href="#idl-def-AudioProcessEvent"><code>AudioProcessEvent</code></a>'s
              <code>parameters</code> member on subsequent audio
              processing events. A NotFoundError exception must be thrown if no
              parameter with that name exists on this <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a>.
            </p>-->
            <p>
              この <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a> とその <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> に結びついた全ての <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> から、それまでに追加された <code>name</code> の名前を持つパラメータを削除します。
              またこれは名前の付いたリードオンリーの <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> を <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> から削除し、さらに<a class="idlType" href="#idl-def-AudioProcessEvent"><code>AudioProcessEvent</code></a> の <code>parameters</code> メンバーからその名前の付いたリードオンリーの Float32Array を 削除します。
              この <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a> にその名前のパラメーターが存在しない場合、NotFoundError 例外を発生します。
            </p>
<!--            <p>
              The <code>name</code> parameter identifies the parameter to be
              removed.
            </p>-->
            <p>
              <code>name</code> は削除するパラメータを指定します。
            </p>
          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">name</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>戻り値: </em><code>void</code></div></dd><dt id="widl-AudioWorker-terminate-void"><code>terminate</code></dt>
<!--          <dd>
            The terminate() method, when invoked, must cause the cessation of
            any <a class="idlType" href="#idl-def-AudioProcessEvent"><code>AudioProcessEvent</code></a>s being dispatched inside the
            AudioWorker's associated <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a>. It will
            also cause all associated AudioWorkerNodes to cease processing, and
            will cause the destruction of the worker's context. In practical
            terms, this means all nodes created from this AudioWorker will
            disconnect themselves, and will cease performing any useful
            functions.
          <div><em>No parameters.</em></div><div><em>Return type: </em><code>void</code></div>
        </dd>-->
        <dd>
          terminate() メソッドが呼び出された時、 <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> に関連するオーディオワーカー内の全ての <a class="idlType" href="#idl-def-AudioProcessEvent"><code>AudioProcessEvent</code></a> のディスパッチを停止しなくてはなりません。
          これはまた全ての関連する AudioWorkerNode の処理を停止し、ワーカーのコンテキストも破棄します。実際的な言い方をすれば、これは AudioWorker から作成された全てのノード自体を切断し、全ての意味のある動作を停止させます。
        <div><em>パラメータなし</em></div><div><em>戻り値: </em><code>void</code></div>
      </dd>
      </dl></section>
<!--      <p>
        Note that <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> objects will also have read-only
        AudioParam objects for each named parameter added via the
        <code>addParameter</code> method. As this is dynamic, it cannot be
        captured in IDL.
      </p>-->
      <p>
        <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> オブジェクトは <code>addParameter</code> メソッドによって追加されたそれぞれの名前に対応したリードオンリーの AudioParam オブジェクトを持っている事に注意してください。これは動的に行われるため、IDL 表現には含まれていません。
      </p>
<!--      <p>
        As the <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a> interface inherits from
        <code>Worker</code>, <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a>s must implement the
        <code>Worker</code> interface for communication with the audio worker
        script.
      </p>-->
      <p>
        <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a> インターフェースは <code>Worker</code> から継承されるため、オーディオワーカースクリプトとの通信のために <code>Worker</code> のインターフェースを実装しなくてはなりません。
      </p>
        <section property="bibo:hasPart" resource="#AudioWorkerNode" typeof="bibo:Chapter">
          <h4 resource="#AudioWorkerNode" id="AudioWorkerNode"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.3 </span>
            <dfn id="dfn-audioworkernode" data-dfn-type="dfn">AudioWorkerNode</dfn> インターフェース <button onclick="OpenOriginal('AudioWorkerNode')">原文</button>
          </span></h4>
<!--          <p>
            This interface represents an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> which
            interacts with a <code>Worker</code> thread to generate, process,
            or analyse audio directly. The user creates a separate audio
            processing worker script, which is hosted inside the
            AudioWorkerGlobalScope and runs inside the audio processing thread,
            rather than the main UI thread. The AudioWorkerNode represents the
            processing node in the main processing thread's node graph; the
            AudioWorkerGlobalScope represents the context in which the user's
            audio processing script is run.
          </p>-->
          <p>
            このインターフェースはオーディオを直接生成、処理、分析する <code>Worker</code> スレッドに対して作用する <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> を表します。
            ユーザーは AudioWorkerGlobalScope 内に保持される分離されたオーディオ処理のワーカースクリプトを作成し、メインUIスレッドではなくオーディオ処理スレッド内で実行されます。
            AudioWorkerNode はメイン処理スレッドのノードグラフ内では処理ノードとして表されます。つまり、AudioWorkerGlobalScope  はユーザーのオーディオ処理スクリプトを動作させるコンテキストを表します。
          </p>
<!--          <p>
            Nota bene that if the Web Audio implementation normally runs audio
            process at higher than normal thread priority, utilizing
            AudioWorkerNodes may cause demotion of the priority of the audio
            thread (since user scripts cannot be run with higher than normal
            priority).
          </p>-->
          <p>
            Web Audio の実装は通常オーディオ処理スレッドの優先度をノーマルよりも高くするのが普通である事に注意してください。(ユーザースクリプトはノーマルよりも高い優先度で動作させる事ができないため) AudioWokerNode の利用はオーディオ処理スレッドの優先度を格下げする場合があります。
          </p>
          <pre>    numberOfInputs  : variable
    numberOfOutputs : variable

    channelCount = numberOfInputChannels;
    channelCountMode = "explicit";
    channelInterpretation = "speakers";
</pre>
<!--<p>
  The number of input and output channels specified in the
  createAudioWorkerNode() call determines the initial number of input
  and output channels (and the number of channels present for each
  input and output in the AudioBuffers passed to the AudioProcess
  event handler inside the <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a>). It is
  invalid for both <a data-link-type="dfn" class="internalDFN" href="#dfn-numberofinputchannels"><code>numberOfInputChannels</code></a>
  and <a data-link-type="dfn" class="internalDFN" href="#dfn-numberofoutputchannels"><code>numberOfOutputChannels</code></a>
  to be zero.
</p>-->
<p>
  createAudioWorkerNode()(<span class="annotate">訳注:createNode()の間違いと思われます</span>) の呼び出しの際に指定された入力と出力のチャンネルの数が初期状態の入出力のチャンネル数(および入出力それぞれに対応して <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> 内に存在する AudioProcess イベントハンドラーに渡されるAudioBufferのチャンネル数) を決定します)。
  <a data-link-type="dfn" class="internalDFN" href="#dfn-numberofinputchannels"><code>numberOfInputChannels</code></a> と <a data-link-type="dfn" class="internalDFN" href="#dfn-numberofoutputchannels"><code>numberOfOutputChannels</code></a> の両方が0になるのは不正となります。
</p>
          <p>
            使用例:
          </p>
          <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">    </span><span class="kwd">var</span><span class="pln"> bitcrusherFactory </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createAudioWorker</span><span class="pun">(</span><span class="pln"> </span><span class="str">"bitcrusher.js"</span><span class="pln"> </span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> bitcrusherNode </span><span class="pun">=</span><span class="pln"> bitcrusherFactory</span><span class="pun">.</span><span class="pln">createNode</span><span class="pun">();</span></pre>
          <pre class="idl"><span class="idlInterface" id="idl-def-AudioWorkerNode">interface <span class="idlInterfaceID">AudioWorkerNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-AudioWorkerNode-postMessage-void-any-message-sequence-Transferable--transfer">postMessage</a></span> (<span class="idlParam"><span class="idlParamType">any</span> <span class="idlParamName">message</span></span>, <span class="idlParam">optional <span class="idlParamType">sequence&lt;Transferable&gt;</span> <span class="idlParamName">transfer</span></span>);</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-AudioWorkerNode-onmessage">onmessage</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-11" typeof="bibo:Chapter" id="attributes-11"><h5 resource="#h-attributes-11" id="h-attributes-11"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.3.1 </span>属性 <button onclick="OpenOriginal('h-attributes-11')">原文</button></span></h5><dl class="attributes"><dt id="widl-AudioWorkerNode-onmessage"><code>onmessage</code> <span class="idlAttrType">EventHandler</span>型</dt>
<!--  <dd>
              The onmessage handler is called whenever the
              AudioWorkerNodeProcessor posts a node message back to the main
              thread.
  </dd>-->
  <dd>
    onmessage ハンドラーは AudioWorkerNodeProcessor がメインスレッドに対してノードメッセージを送り返した際に常に呼び出されます。
  </dd>
</dl></section><section property="bibo:hasPart" resource="#methods-8" typeof="bibo:Chapter" id="methods-8"><h5 resource="#h-methods-8" id="h-methods-8"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.3.2 </span>メソッド <button onclick="OpenOriginal('h-methods-8')">原文</button></span></h5><dl class="methods"><dt id="widl-AudioWorkerNode-postMessage-void-any-message-sequence-Transferable--transfer"><code>postMessage</code></dt>
<!--  <dd>
              postMessage may be called to send a message to the
              AudioWorkerNodeProcessor, via the algorithm defined by <a href="https://w3c.github.io/workers/#dom-worker-postmessage">the
              Worker specification</a>. Note that this is different from
              calling postMessage() on the AudioWorker itself, as that would
              affect the AudioWorkerGlobalScope.
            <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">message</td><td class="prmType"><code>any</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">transfer</td><td class="prmType"><code>sequence&lt;Transferable&gt;</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div>
    </dd>-->
    <dd>
      postMessage は AudioWorkerNodeProcessor に対して <a href="https://w3c.github.io/workers/#dom-worker-postmessage">the
      Worker specification</a> で定義されたアルゴリズムでメッセージを送るために呼び出されます。
      これは AudioWorkerGlobalScope に影響を与えるため、AudioWorker 自身で postMessage() を呼び出すのとは異なる事に注意してください。
              <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">message</td><td class="prmType"><code>any</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">transfer</td><td class="prmType"><code>sequence&lt;Transferable&gt;</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>戻り値: </em><code>void</code></div>
      </dd>
  </dl></section>
<!--  <p>
    Note that <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> objects will also have read-only
    AudioParam objects for each named parameter added via the
    <code>addParameter</code> method on the AudioWorker. As this is
    dynamic, it cannot be captured here in IDL.
  </p>-->
  <p>
<a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> オブジェクトはまた、AudioWorker の <code>addParameter</code> メソッドによって追加された名前付きパラメータ毎に対応したリードオンリーの AudioParam オブジェクトを持っている事に注意してください。これは動的に行われるため、IDL には表現されていません。
  </p>
        </section>
        <section property="bibo:hasPart" resource="#AudioWorkerParamDescriptor" typeof="bibo:Chapter">
          <h4 resource="#AudioWorkerParamDescriptor" id="AudioWorkerParamDescriptor"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.4 </span>
            <dfn id="dfn-audioworkerparamdescriptor" data-dfn-type="dfn">AudioWorkerParamDescriptor</dfn> インターフェース <button onclick="OpenOriginal('AudioWorkerParamDescriptor')">原文</button>
          </span></h4>
<!--          <p>
            This interface represents the description of an AudioWorkerNode
            AudioParam - in short, its name and default value. This enables
            easy iteration over the AudioParams from an AudioWorkerGlobalScope
            (which does not have an instance of those AudioParams).
          </p>-->
          <p>
            このインターフェースは AudioWorkerNodeのAudioParam -- 端的にはその名前とデフォルト値を表します。これは (AudioParamのインスタンスを保持していない) AudioWorkerGlobalScope から AudioParam に対する反復処理を行いやすくします。
          </p>
          <pre class="idl"><span class="idlInterface" id="idl-def-AudioWorkerParamDescriptor">interface <span class="idlInterfaceID">AudioWorkerParamDescriptor</span> {
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">DOMString</span> <span class="idlAttrName"><a href="#widl-AudioWorkerParamDescriptor-name">name</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">float</span>     <span class="idlAttrName"><a href="#widl-AudioWorkerParamDescriptor-defaultValue">defaultValue</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-12" typeof="bibo:Chapter" id="attributes-12"><h5 resource="#h-attributes-12" id="h-attributes-12"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.4.1 </span>属性 <button onclick="OpenOriginal('attributes-12')">原文</button></span></h5><dl class="attributes"><dt id="widl-AudioWorkerParamDescriptor-defaultValue"><code>defaultValue</code> of type <span class="idlAttrType">float</span>, readonly       </dt>
<!--  <dd>
              The default value of the AudioParam.
  </dd>-->
  <dd>
      AudioParam のデフォルト値です。
  </dd>
            <dt id="widl-AudioWorkerParamDescriptor-name"><code>name</code> <span class="idlAttrType">DOMString</span>型, readonly       </dt>
<!--            <dd>
                        The name of the AudioParam.
            </dd>-->
            <dd>
              AudioParamの名前です。
            </dd>
</dl></section>
        </section>
        <section property="bibo:hasPart" resource="#the-audioworkerglobalscope-interface" typeof="bibo:Chapter" id="the-audioworkerglobalscope-interface">
          <h4 resource="#h-the-audioworkerglobalscope-interface" id="h-the-audioworkerglobalscope-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.5 </span>
            AudioWorkerGlobalScope インターフェース <button onclick="OpenOriginal('h-the-audioworkerglobalscope-interface')">原文</button>
          </span></h4>
<!--          <p>
            This interface is a <code>DedicatedWorkerGlobalScope</code>-derived
            object representing the context in which an audio processing script
            is run; it is designed to enable the generation, processing, and
            analysis of audio data directly using JavaScript in a Worker
            thread, with shared context between multiple instances of audio
            nodes. This facilitates nodes that may have substantial shared
            data, e.g. a convolution node.
          </p>-->
          <p>
            このインターフェースは <code>DedicatedWorkerGlobalScope</code> の派生オブジェクトでオーディオ処理スクリプトが実行されるコンテキストを表します -- そしてそれはオーディオノードの複数のインスタンスで共有され、ワーカースレッド内の JavaScript を用いてオーディオの直接的な合成、処理、分析ができるように設計されています。
            これはノードが例えばコンポリューションノードのように大量の共有データを持つ場合に役立ちます。
          </p>
          -
<!--          <p>
            The <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> handles - <dfn data-dfn-type="dfn" id="audioprocess-worker">audioprocess</dfn> events dispatched -
            synchronously to process audio frame blocks for nodes created by
            this worker. - <a href="#audioprocess-worker"><code>audioprocess</code></a> events are
            only - dispatched for nodes that have at least one input - or one
            output connected. TODO: should this be true?
          </p>-->
          <p>
            <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> は
            このワーカーで作成されたノードのオーディオフレームの処理に同期してディスパッチされる <dfn data-dfn-type="dfn" id="audioprocess-worker">audioprocess</dfn> イベントを管理します。
            - <a href="#audioprocess-worker"><code>audioprocess</code></a> イベントは
            少なくとも1つの入力あるいは1つの接続された出力を持つノードにのみディスパッチされます。

            TODO : これは本当?
            (<span class="annotate">訳注:このあたりはまだ完全な文書にはなっていないようです</span>)
          </p>
          <pre class="idl"><span class="idlInterface" id="idl-def-AudioWorkerGlobalScope">interface <span class="idlInterfaceID">AudioWorkerGlobalScope</span> : <span class="idlSuperclass">DedicatedWorkerGlobalScope</span> {
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">float</span>                        <span class="idlAttrName"><a href="#widl-AudioWorkerGlobalScope-sampleRate">sampleRate</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlMethName"><a href="#widl-AudioWorkerGlobalScope-addParameter-AudioParam-DOMString-name-float-defaultValue">addParameter</a></span> (<span class="idlParam"><span class="idlParamType">DOMString</span> <span class="idlParamName">name</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">defaultValue</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span>       <span class="idlMethName"><a href="#widl-AudioWorkerGlobalScope-removeParameter-void-DOMString-name">removeParameter</a></span> (<span class="idlParam"><span class="idlParamType">DOMString</span> <span class="idlParamName">name</span></span>);</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">EventHandler</span>                 <span class="idlAttrName"><a href="#widl-AudioWorkerGlobalScope-onaudioprocess">onaudioprocess</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">EventHandler</span>                 <span class="idlAttrName"><a href="#widl-AudioWorkerGlobalScope-onnodecreate">onnodecreate</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioWorkerParamDescriptor"><code>AudioWorkerParamDescriptor</code></a>[]</span> <span class="idlAttrName"><a href="#widl-AudioWorkerGlobalScope-parameters">parameters</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-13" typeof="bibo:Chapter" id="attributes-13"><h5 resource="#h-attributes-13" id="h-attributes-13"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.5.1 </span>属性 <button onclick="OpenOriginal('h-attributes-13')">原文</button></span></h5><dl class="attributes"><dt id="widl-AudioWorkerGlobalScope-onaudioprocess"><code>onaudioprocess</code> <span class="idlAttrType">EventHandler</span>型</dt>
<!--  <dd>
              A property used to set the <code>EventHandler</code> (described
              in [<cite><a href="#bib-HTML" class="bibref">HTML</a></cite>]) for the <a href="#audioprocess-worker"><code>audioprocess</code></a> event that
              is dispatched to <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> to
              process audio while the associated nodes are connected (to at
              least one input or output). An event of type
              <a class="idlType" href="#idl-def-AudioProcessEvent"><code>AudioProcessEvent</code></a> will be dispatched to the
              event handler.
  </dd>-->
  <dd>
        関連するノードが (少なくとも1つの入力または出力が) 接続されている間、オーディオ処理のために <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> にディスパッチされる <a href="#audioprocess-worker"><code>audioprocess</code></a> イベントに対応する ([<cite><a href="#bib-HTML" class="bibref">HTML</a></cite>]で説明される) <code>EventHandler</code> を設定するために使用されるプロパティです。
  </dd>

            <dt id="widl-AudioWorkerGlobalScope-onnodecreate"><code>onnodecreate</code> <span class="idlAttrType">EventHandler</span>型</dt>
<!--            <dd>
                      A property used to set the <code>EventHandler</code> (described
                      in [<cite><a href="#bib-HTML" class="bibref">HTML</a></cite>]) for the <a href="#audioprocess-worker"><code>nodecreate</code></a> event that is
                      dispatched to <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> when a
                      new <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> has been created. This
                      enables the scope to do node-level initialization of the
                      AudioNodeProcessor object. An event of type
                      <a class="idlType" href="#idl-def-AudioWorkerNodeCreationEvent"><code>AudioWorkerNodeCreationEvent</code></a> will be
                      dispatched to the event handler.
            </dd>-->
            <dd>
              <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> が新しく作成された時に
              <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> にディスパッチされる
              <a href="#audioprocess-worker"><code>nodecreate</code></a> イベントのための ([<cite><a href="#bib-HTML" class="bibref">HTML</a></cite>]で説明されている) <code>EventHandler</code> を設定するために使用されるプロパティです。
              これは AudioNodeProcessor オブジェクトのノードレベルの初期化を行う事を可能にします。
              <a class="idlType" href="#idl-def-AudioWorkerNodeCreationEvent"><code>AudioWorkerNodeCreationEvent</code></a> がイベントハンドラーにディスパッチされます。
            </dd>

            <dt id="widl-AudioWorkerGlobalScope-parameters"><code>parameters</code> array of <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioWorkerParamDescriptor"><code>AudioWorkerParamDescriptor</code></a></span>型, readonly       </dt>
<!--            <dd>
              This array contains descriptors for each of the current
              parameters on nodes created in this AudioWorkerGlobalScope. This
              enables audio worker implementations to easily iterate over the
              AudioParam names and default values.
            </dd>-->
            <dd>
              この配列はこの AudioWorkerGlobalScope 内で作成されたノード上の現在の各パラメータのディスクリプターを保持しています。
              これによりオーディオワーカーの実装は簡単に AudioParam の名前とデフォルト値の反復操作を行う事ができます。
            </dd>
            <dt id="widl-AudioWorkerGlobalScope-sampleRate"><code>sampleRate</code> <span class="idlAttrType">float</span>型, readonly       </dt>
<!--            <dd>
              The sample rate of the host <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> (since inside the
              <code>Worker</code> scope, the user will not have direct access
              to the <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>.
            </dd>-->
            <dd>
              ホストとなる <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> のサンプルレートです。
              (<code>Worker</code> 内のスコープではユーザーは <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> に直接のアクセスはできません)
            </dd>
          </dl></section><section property="bibo:hasPart" resource="#methods-9" typeof="bibo:Chapter" id="methods-9"><h5 resource="#h-methods-9" id="h-methods-9"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.5.2 </span>メソッド <button onclick="OpenOriginal('h-methods-9')">原文</button></span></h5><dl class="methods"><dt id="widl-AudioWorkerGlobalScope-addParameter-AudioParam-DOMString-name-float-defaultValue"><code>addParameter</code></dt><dd>
<!--            <p>
              Causes a correspondingly-named read-only <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> to
              be present on previously-created and subsequently-created
              <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a>s created by this factory, and a
              correspondingly-named read-only Float32Array to be
              present on the <code>parameters</code> object exposed on
              the <a class="idlType" href="#idl-def-AudioProcessEvent"><code>AudioProcessEvent</code></a> on subsequent audio processing
              events for nodes created from this factory.
            </p>-->
            <p>
              このファクトリによって作成される(既に存在するあるいは今後作成される)全ての <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> に名前に応じたリードオンリーの <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> を付加し、 また以降のこれらのノードの <a class="idlType" href="#idl-def-AudioProcessEvent"><code>AudioProcessEvent</code></a> 上の <code>parameters</code> オブジェクトに名前に応じたリードオンリーの Float32Array を付加します。
              </p>
<!--              <p>
                It is purposeful that AudioParams can be added (or removed)
                from an Audio Worker from either the main thread or the worker
                script; this enables immediate creation of worker-based nodes
                and their prototypes, but also enables packaging an entire
                worker including its AudioParam configuration into a single
                script. It is recommended that nodes be used only after the
                AudioWorkerNode's oninitialized has been called, in order to
                allow the worker script to configure the node.
              </p>-->
              <p>
                オーディオワーカーに対してメインスレッドまたはワーカースクリプトのどちらからでも AudioParam が追加(あるいは削除)できる事は意図的なものです。
                これは瞬時にワーカーベースのノードとそのプロトタイプの作成する事を可能にするだけでなく、
                 AudioParam の構成も単一のスクリプトに含んだワーカー全体のパッケージ化も可能にします。

                ワーカースクリプトがノードを構成できるように AudioWorkerNode の oninitialized が呼び出された後でのみノードが使用される事が推奨されます。
              </p>
<!--              <p>
                The <code>name</code> parameter is the name used for the
                read-only AudioParam added to the AudioWorkerNode, and the name
                used for the read-only <code>Float32Array</code> that will be
                present on the <code>parameters</code> object exposed on
                subsequent <a class="idlType" href="#idl-def-AudioProcessEvent"><code>AudioProcessEvent</code></a>s.
              </p>-->
              <p>
                <code>name</code> パラメータは
                AudioWorkerNode に追加されるリードオンリーの AudioParam の名前として、また以降の <a class="idlType" href="#idl-def-AudioProcessEvent"><code>AudioProcessEvent</code></a> でアクセスできる <code>parameters</code> オブジェクト上に現れるリードオンリーの <code>Float32Array</code> の名前として使用される。
              </p>
<!--              <p>
                The <dfn data-dfn-type="dfn" id="dfn-defaultValue">defaultValue</dfn> parameter is
                the default value for the <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>'s value
                attribute, as well as therefore the default value that will
                appear in the Float32Array in the worker script (if no other
                parameter changes or connections affect the value).
              </p>-->
              <p>
                <dfn data-dfn-type="dfn" id="dfn-defaultValue">defaultValue</dfn> パラメータは
<a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> の value 属性のデフォルト値であり、また
              (もし他のパラメータ変更あるいは接続の影響がなければ) ワーカースクリプトの Float32Array にデフォルト値として表れます
              </p>
            <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">name</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">defaultValue</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>戻り値: </em><code><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></code></div></dd><dt id="widl-AudioWorkerGlobalScope-removeParameter-void-DOMString-name"><code>removeParameter</code></dt>
<!--            <dd>
              <p>
                Removes a previously-added parameter named <code>name</code>
                from nodes processed by this factory. This will also remove the
                correspondingly-named read-only <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> from the
                <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a>, and will remove the
                correspondingly-named read-only Float32Array from the
                <a class="idlType" href="#idl-def-AudioProcessEvent"><code>AudioProcessEvent</code></a>'s <code>parameters</code>
                member on subsequent audio processing events. A NotFoundError
                exception <em title="MUST" class="rfc2119">MUST</em> be thrown if no parameter with that name exists
                on this node.
              </p>
              <p>
                The <code>name</code> parameter identifies the parameter to be
                removed.
              </p>
            <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">name</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div>
          </dd>-->
          <dd>
            <p>
              このファクトリで作成されたノードから以前に追加された <code>name</code> の名前を持つパラメータを削除します。
              またこれはこの名前を持つリードオンリーの <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> を <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a> から削除し、さらに以降のオーディオ処理イベントでこの名前を持つリードオンリーの Float32Array も <a class="idlType" href="#idl-def-AudioProcessEvent"><code>AudioProcessEvent</code></a> の <code>parameters</code> のメンバーから削除します。 このノードにその名前のパラメーターが存在しない場合、NotFoundError 例外を発生します(<em title="MUST" class="rfc2119">MUST</em>)。
            </p>
<!--            <p>
              The <code>name</code> parameter identifies the parameter to be
              removed.
            </p>-->
            <p>
              <code>name</code>は削除するパラメータを特定します。
            </p>
          <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">name</td><td class="prmType"><code>DOMString</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>戻り値: </em><code>void</code></div>
        </dd>
        </dl></section>
        </section>
        <section property="bibo:hasPart" resource="#the-audioworkernodeprocessor-interface" typeof="bibo:Chapter" id="the-audioworkernodeprocessor-interface">
          <h4 resource="#h-the-audioworkernodeprocessor-interface" id="h-the-audioworkernodeprocessor-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.6 </span>
            AudioWorkerNodeProcessor インターフェース <button onclick="OpenOriginal('h-the-audioworkernodeprocessor-interface')">原文</button>
          </span></h4>
<!--          <p>
            An object supporting this interface represents each individual node
            instantiated in an <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a>; it
            is designed to manage the data for an individual node. Shared
            context between multiple instances of audio nodes is accessible
            from the <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a>; this object represents the
            individual node and can be used for data storage or main-thread
            communication.
          </p>-->
          <p>
            このインターフェースをサポートするオブジェクトは <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> 内でインスタンス化された個別のノードを表します。
            これは個々のノードのデータを管理するために設計されています。

            複数のオーディオノードのインスタンス間で共有されるコンテキストは <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> からアクセス可能です。
            このオブジェクトは個々のノードを表し、データストレージまたはメインスレッドとの通信に使用できます。
          </p>
          <pre class="idl"><span class="idlInterface" id="idl-def-AudioWorkerNodeProcessor">interface <span class="idlInterfaceID">AudioWorkerNodeProcessor</span> : <span class="idlSuperclass">EventTarget</span> {
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-AudioWorkerNodeProcessor-postMessage-void-any-message-sequence-Transferable--transfer">postMessage</a></span> (<span class="idlParam"><span class="idlParamType">any</span> <span class="idlParamName">message</span></span>, <span class="idlParam">optional <span class="idlParamType">sequence&lt;Transferable&gt;</span> <span class="idlParamName">transfer</span></span>);</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-AudioWorkerNodeProcessor-onmessage">onmessage</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-14" typeof="bibo:Chapter" id="attributes-14"><h5 resource="#h-attributes-14" id="h-attributes-14"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.6.1 </span>属性 <button onclick="OpenOriginal('h-attributes-14')">原文</button></span></h5><dl class="attributes"><dt id="widl-AudioWorkerNodeProcessor-onmessage"><code>onmessage</code> <span class="idlAttrType">EventHandler</span>型</dt>
<!--  <dd>
              The onmessage handler is called whenever the AudioWorkerNode
              posts a node message back to the audio thread.
  </dd>-->
  <dd>
    onmessage ハンドラーは AudioWorkerNode がノードメッセージをオーディオスレッドに送り返す度に呼び出されます。
  </dd>
</dl></section><section property="bibo:hasPart" resource="#methods-10" typeof="bibo:Chapter" id="methods-10"><h5 resource="#h-methods-10" id="h-methods-10"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.6.2 </span>メソッド <button onclick="OpenOriginal('h-methods-10')">原文</button></span></h5><dl class="methods"><dt id="widl-AudioWorkerNodeProcessor-postMessage-void-any-message-sequence-Transferable--transfer"><code>postMessage</code></dt>
<!--  <dd>
              postMessage may be called to send a message to the
              AudioWorkerNode, via the algorithm defined by <a href="https://w3c.github.io/workers/#dom-worker-postmessage">the
              Worker specification</a>. Note that this is different from
              calling postMessage() on the AudioWorker itself, as that would
              dispatch to the AudioWorkerGlobalScope.
            <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">message</td><td class="prmType"><code>any</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">transfer</td><td class="prmType"><code>sequence&lt;Transferable&gt;</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div>
  </dd>-->
  <dd>
      postMesasge は <a href="https://w3c.github.io/workers/#dom-worker-postmessage">the
      Worker specification</a> で定義されるアルゴリズムを使って AudioWorkerNode にメッセージを送るために呼び出されます。
      これは AudioWorker 自身で PostMesage() を呼び出すのとは異なり、AudioWorkerGlobalScope にディスパッチされる事に注意してください。
            <table class="parameters"><tbody><tr><th>パラメータ</th><th>型</th><th>Null可</th><th>Optional</th><th>説明</th></tr><tr><td class="prmName">message</td><td class="prmType"><code>any</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">transfer</td><td class="prmType"><code>sequence&lt;Transferable&gt;</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>戻り値: </em><code>void</code></div>
  </dd>
</dl></section>
        </section>
        <section property="bibo:hasPart" resource="#audio-worker-examples" typeof="bibo:Chapter" id="audio-worker-examples" class="informative">
          <h4 resource="#h-audio-worker-examples" id="h-audio-worker-examples"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.7
            オーディオワーカーのサンプル  <button onclick="OpenOriginal('h-audio-worker-examples')">原文</button></span>
          </span></h4><p><em>このセクションは参考情報です</em></p>
          <section property="bibo:hasPart" resource="#a-bitcrusher-node" typeof="bibo:Chapter" id="a-bitcrusher-node">
            <h5 resource="#h-a-bitcrusher-node" id="h-a-bitcrusher-node"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.7.1 </span>
              ビットクラッシャーノード  <button onclick="OpenOriginal('h-a-bitcrusher-node')">原文</button></span>
            </span></h5>
<!--            <p>
              Bitcrushing is a mechanism by which the audio quality of an audio
              stream is reduced - both by quantizing the value (simulating
              lower bit-depth in integer-based audio), and by quantizing in
              time (simulating a lower digital sample rate). This example shows
              how to use AudioParams (in this case, treated as a-rate) inside
              an AudioWorker.
            </p>-->
            <p>
              ビットクラッシュはオーディオストリームの音質を下げる機構です -- (整数ベースオーディオの低ビット深度をシミュレートする)値のクオンタイズと(低サンプルレートをシミュレートする)時間方向のクオンタイズの両方を使用します。
              この例は AudioWorker 内での AudioParam (この例では a-rateとして処理します)の使い方を示します。
            </p>
            <h5 id="main-file-javascript">
              Main file javascript
            </h5>
            <pre style="" class="highlight prettyprint prettyprinted"><span class="kwd">var</span><span class="pln"> bitcrusherFactory </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
audioContext</span><span class="pun">.</span><span class="pln">createAudioWorker</span><span class="pun">(</span><span class="str">"bitcrusher_worker.js"</span><span class="pun">).</span><span class="kwd">then</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">factory</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">  </span><span class="com">// cache 'factory' in case you want to create more nodes!</span><span class="pln">
      bitcrusherFactory </span><span class="pun">=</span><span class="pln"> factory</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> bitcrusherNode </span><span class="pun">=</span><span class="pln"> factory</span><span class="pun">.</span><span class="pln">createNode</span><span class="pun">();</span><span class="pln">
      bitcrusherNode</span><span class="pun">.</span><span class="pln">bits</span><span class="pun">.</span><span class="pln">setValueAtTime</span><span class="pun">(</span><span class="lit">8</span><span class="pun">,</span><span class="lit">0</span><span class="pun">);</span><span class="pln">
      bitcrusherNode</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">output</span><span class="pun">);</span><span class="pln">
      input</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">bitcrusherNode</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">);</span></pre>
            <h5 id="bitcrusher_worker.js">
              bitcrusher_worker.js
            </h5>
            <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">            </span><span class="com">// Custom parameter - number of bits to crush down to - default 8</span><span class="pln">
</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">addParameter</span><span class="pun">(</span><span class="pln"> </span><span class="str">"bits"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">8</span><span class="pln"> </span><span class="pun">);</span><span class="pln">

</span><span class="com">// Custom parameter - frequency reduction, 0-1, default 0.5</span><span class="pln">
</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">addParameter</span><span class="pun">(</span><span class="pln"> </span><span class="str">"frequencyReduction"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0.5</span><span class="pln"> </span><span class="pun">);</span><span class="pln">

onnodecreate</span><span class="pun">=</span><span class="kwd">function</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  e</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">phaser </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
  e</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">lastDataValue </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

onaudioprocess</span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> channel</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln"> channel</span><span class="pun">&lt;</span><span class="pln">e</span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> channel</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> inputBuffer </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="pln">channel</span><span class="pun">];</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> outputBuffer </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">outputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="pln">channel</span><span class="pun">];</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> bufferLength </span><span class="pun">=</span><span class="pln"> inputBuffer</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> bitsArray </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">parameters</span><span class="pun">.</span><span class="pln">bits</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> frequencyReductionArray </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">parameters</span><span class="pun">.</span><span class="pln">frequencyReduction</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">bufferLength</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> bits </span><span class="pun">=</span><span class="pln"> bitsArray </span><span class="pun">?</span><span class="pln"> bitsArray</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">8</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> frequencyReduction </span><span class="pun">=</span><span class="pln"> frequencyReductionArray </span><span class="pun">?</span><span class="pln"> frequencyReductionArray</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">0.5</span><span class="pun">;</span><span class="pln">

      </span><span class="kwd">var</span><span class="pln"> step </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">pow</span><span class="pun">(</span><span class="lit">1</span><span class="pun">/</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> bits</span><span class="pun">);</span><span class="pln">
      e</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">phaser </span><span class="pun">+=</span><span class="pln"> frequencyReduction</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">phaser </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">1.0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
          e</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">phaser </span><span class="pun">-=</span><span class="pln"> </span><span class="lit">1.0</span><span class="pun">;</span><span class="pln">
          e</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">lastDataValue </span><span class="pun">=</span><span class="pln"> step </span><span class="pun">*</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">floor</span><span class="pun">(</span><span class="pln">inputBuffer</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> step </span><span class="pun">+</span><span class="pln"> </span><span class="lit">0.5</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      outputBuffer</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">lastDataValue</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">};</span></pre>
          </section>
          <section property="bibo:hasPart" resource="#todo-fix-up-this-example.-a-volume-meter-and-clip-detector" typeof="bibo:Chapter" id="todo-fix-up-this-example.-a-volume-meter-and-clip-detector">
            <h5 resource="#h-todo-fix-up-this-example.-a-volume-meter-and-clip-detector" id="h-todo-fix-up-this-example.-a-volume-meter-and-clip-detector"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.7.2 </span>
              TODO: このサンプルを直す事。ボリュームメーターとクリップデテクター  <button onclick="OpenOriginal('h-todo-fix-up-this-example.-a-volume-meter-and-clip-detector')">原文</button></span>
            </span></h5>
<!--            <p>
              Another common need is a clip-detecting volume meter. This
              example shows how to communicate basic parameters (that do not
              need AudioParam scheduling) across to a Worker, as well as
              communicating data back to the main thread. This node does not
              use any output.
            </p>-->
            <p>
              もう一つのよくある例はクリップ検出とボリュームメーターです。
              この例は Workerとの間で (AudioParam スケジューリングを必要としない) 基本的なパラメータの通信とメインスレッドに対してデータを送り返すやり方を示しています。このノードは出力を使用していません。
            </p>
            <h5 id="main-file-javascript-1">
              Main file javascript
            </h5>
            <pre style="" class="highlight prettyprint prettyprinted"><span class="kwd">function</span><span class="pln"> setupNodeMessaging</span><span class="pun">(</span><span class="pln">node</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// This handles communication back from the volume meter</span><span class="pln">
  node</span><span class="pun">.</span><span class="pln">onmessage </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">event</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">event</span><span class="pun">.</span><span class="pln">data instanceof </span><span class="typ">Object</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">event</span><span class="pun">.</span><span class="pln">data</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="str">"clip"</span><span class="pun">)</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">clip </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">data</span><span class="pun">.</span><span class="pln">clip</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">event</span><span class="pun">.</span><span class="pln">data</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="str">"volume"</span><span class="pun">)</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">volume </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">data</span><span class="pun">.</span><span class="pln">volume</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">// Set up some default configuration parameters</span><span class="pln">
  node</span><span class="pun">.</span><span class="pln">postMessage</span><span class="pun">(</span><span class="pln">
    </span><span class="pun">{</span><span class="pln"> </span><span class="str">"smoothing"</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0.9</span><span class="pun">,</span><span class="pln">   </span><span class="com">// Smoothing parameter</span><span class="pln">
      </span><span class="str">"clipLevel"</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0.9</span><span class="pun">,</span><span class="pln">   </span><span class="com">// Level to consider "clipping"</span><span class="pln">
      </span><span class="str">"clipLag"</span><span class="pun">:</span><span class="pln"> </span><span class="lit">750</span><span class="pun">,</span><span class="pln">     </span><span class="com">// How long to keep "clipping" lit up after clip (ms)</span><span class="pln">
      </span><span class="str">"updating"</span><span class="pun">:</span><span class="pln"> </span><span class="lit">100</span><span class="pln">      </span><span class="com">// How frequently to update volume and clip param (ms)</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">

  </span><span class="com">// Set up volume and clip attributes.  These will be updated by our onmessage.</span><span class="pln">
  node</span><span class="pun">.</span><span class="pln">volume </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
  node</span><span class="pun">.</span><span class="pln">clip </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">var</span><span class="pln"> vuNode </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">

audioContext</span><span class="pun">.</span><span class="pln">createAudioWorker</span><span class="pun">(</span><span class="str">"vu_meter_worker.js"</span><span class="pun">).</span><span class="kwd">then</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">factory</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">  </span><span class="com">// cache 'factory' in case you want to create more nodes!</span><span class="pln">
      vuFactory </span><span class="pun">=</span><span class="pln"> factory</span><span class="pun">;</span><span class="pln">
      vuNode </span><span class="pun">=</span><span class="pln"> factory</span><span class="pun">.</span><span class="pln">createNode</span><span class="pun">([</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> </span><span class="pun">[]);</span><span class="pln"> </span><span class="com">// we don't need an output, and let's force to mono</span><span class="pln">
      setupNodeMessaging</span><span class="pun">(</span><span class="pln">vuNode</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">);</span><span class="pln">

window</span><span class="pun">.</span><span class="pln">requestAnimationFrame</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">timestamp</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">vuNode</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// Draw a bar based on vuNode.volume and vuNode.clip</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
</span></pre>
            <h5 id="vu_meter_worker.js">
              vu_meter_worker.js
            </h5>
            <pre style="" class="highlight prettyprint prettyprinted"><span class="com">// Custom parameter - number of bits to crush down to - default 8</span><span class="pln">
</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">addParameter</span><span class="pun">(</span><span class="pln"> </span><span class="str">"bits"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">8</span><span class="pln"> </span><span class="pun">);</span><span class="pln">

</span><span class="com">// Custom parameter - frequency reduction, 0-1, default 0.5</span><span class="pln">
</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">addParameter</span><span class="pun">(</span><span class="pln"> </span><span class="str">"frequencyReduction"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0.5</span><span class="pln"> </span><span class="pun">);</span><span class="pln">

onnodecreate</span><span class="pun">=</span><span class="kwd">function</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  e</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">timeToNextUpdate </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.1</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> sampleRate</span><span class="pun">;</span><span class="pln">
  e</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">smoothing </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.5</span><span class="pun">;</span><span class="pln">
  e</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">clipLevel </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.95</span><span class="pun">;</span><span class="pln">
  e</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">clipLag </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
  e</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">updatingInterval </span><span class="pun">=</span><span class="pln"> </span><span class="lit">150</span><span class="pun">;</span><span class="pln">
  </span><span class="com">// This just handles setting attribute values</span><span class="pln">
  e</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">onmessage </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">event</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">event</span><span class="pun">.</span><span class="pln">data instanceof </span><span class="typ">Object</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">event</span><span class="pun">.</span><span class="pln">data</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="str">"smoothing"</span><span class="pun">)</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">smoothing </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">data</span><span class="pun">.</span><span class="pln">smoothing</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">event</span><span class="pun">.</span><span class="pln">data</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="str">"clipLevel"</span><span class="pun">)</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">clipLevel </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">data</span><span class="pun">.</span><span class="pln">clipLevel</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">event</span><span class="pun">.</span><span class="pln">data</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="str">"clipLag"</span><span class="pun">)</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">clipLag </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">data</span><span class="pun">.</span><span class="pln">clipLag </span><span class="pun">/</span><span class="pln"> </span><span class="lit">1000</span><span class="pun">;</span><span class="pln">  </span><span class="com">// convert to seconds</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">event</span><span class="pun">.</span><span class="pln">data</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="str">"updating"</span><span class="pun">)</span><span class="pln">    </span><span class="com">// convert to samples</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">updatingInterval </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">data</span><span class="pun">.</span><span class="pln">updating </span><span class="pun">*</span><span class="pln"> sampleRate </span><span class="pun">/</span><span class="pln"> </span><span class="lit">1000</span><span class="pln"> </span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

onaudioprocess </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> </span><span class="kwd">event</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> buf </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">];</span><span class="pln">  </span><span class="com">// Node forces mono</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> bufLength </span><span class="pun">=</span><span class="pln"> buf</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> sum </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> x</span><span class="pun">;</span><span class="pln">

  </span><span class="com">// Do a root-mean-square on the samples: sum up the squares...</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">bufLength</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    x </span><span class="pun">=</span><span class="pln"> buf</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Math</span><span class="pun">.</span><span class="pln">abs</span><span class="pun">(</span><span class="pln">x</span><span class="pun">)&gt;=</span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">clipLevel</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">clipping </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">unsentClip </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">  </span><span class="com">// Make sure, for every clip, we send a message.</span><span class="pln">
      </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">lastClip </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">playbackTime </span><span class="pun">+</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i</span><span class="pun">/</span><span class="pln">sampleRate</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    sum </span><span class="pun">+=</span><span class="pln"> x </span><span class="pun">*</span><span class="pln"> x</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">// ... then take the square root of the sum.</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> rms </span><span class="pun">=</span><span class="pln">  </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">sqrt</span><span class="pun">(</span><span class="pln">sum </span><span class="pun">/</span><span class="pln"> bufLength</span><span class="pun">);</span><span class="pln">

  </span><span class="com">// Now smooth this out with the smoothing factor applied</span><span class="pln">
  </span><span class="com">// to the previous sample - take the max here because we</span><span class="pln">
  </span><span class="com">// want "fast attack, slow release."</span><span class="pln">
  </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">volume </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">max</span><span class="pun">(</span><span class="pln">rms</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">volume</span><span class="pun">*</span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">smoothing</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">clipping </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">(!</span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">unsentClip</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">event</span><span class="pun">.</span><span class="pln">playbackTime </span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">lastClip </span><span class="pun">+</span><span class="pln"> clipLag</span><span class="pun">)))</span><span class="pln">
    </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">clipping </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">

  </span><span class="com">// How long has it been since our last update?</span><span class="pln">
  </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">timeToNextUpdate </span><span class="pun">-=</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="kwd">last</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">timeToNextUpdate</span><span class="pun">&lt;</span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">timeToNextUpdate </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">updatingInterval</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">postMessage</span><span class="pun">(</span><span class="pln">
      </span><span class="pun">{</span><span class="pln"> </span><span class="str">"volume"</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">volume</span><span class="pun">,</span><span class="pln">
        </span><span class="str">"clip"</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">clipping </span><span class="pun">});</span><span class="pln">
    </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">unsentClip </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">};</span></pre>
          </section>
          <section property="bibo:hasPart" resource="#reimplementing-channelmerger" typeof="bibo:Chapter" id="reimplementing-channelmerger">
            <h5 resource="#h-reimplementing-channelmerger" id="h-reimplementing-channelmerger"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.12.7.3 </span>
              ChannelMergerの再実装 <button onclick="OpenOriginal('h-reimplementing-channelmerger')">原文</button>
            </span></h5>
<!--            <p>
              This worker shows how to merge inputs into a single output
              channel.
            </p>-->
            <p>
              このワーカーは複数の入力を１つの出力チャンネルにまとめる例を示しています。
            </p>
            <h5 id="main-file-javascript-2">
              Main file javascript
            </h5>
            <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">            </span><span class="kwd">var</span><span class="pln"> mergerNode </span><span class="pun">=</span><span class="pln"> audioContext</span><span class="pun">.</span><span class="pln">createAudioWorker</span><span class="pun">(</span><span class="str">"merger_worker.js"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="lit">1</span><span class="pun">,</span><span class="lit">1</span><span class="pun">,</span><span class="lit">1</span><span class="pun">,</span><span class="lit">1</span><span class="pun">,</span><span class="lit">1</span><span class="pun">,</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> </span><span class="pun">[</span><span class="lit">6</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span></pre>
            <pre style="" class="highlight prettyprint prettyprinted"><span class="kwd">var</span><span class="pln"> mergerFactory </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">

audioContext</span><span class="pun">.</span><span class="pln">createAudioWorker</span><span class="pun">(</span><span class="str">"merger_worker.js"</span><span class="pun">).</span><span class="kwd">then</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">factory</span><span class="pun">)</span><span class="pln">
    </span><span class="pun">{</span><span class="pln">  </span><span class="com">// cache 'factory' in case you want to create more nodes!</span><span class="pln">
      mergerFactory </span><span class="pun">=</span><span class="pln"> factory</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> merger6channelNode </span><span class="pun">=</span><span class="pln"> factory</span><span class="pun">.</span><span class="pln">createNode</span><span class="pun">(</span><span class="pln"> </span><span class="pun">[</span><span class="lit">1</span><span class="pun">,</span><span class="lit">1</span><span class="pun">,</span><span class="lit">1</span><span class="pun">,</span><span class="lit">1</span><span class="pun">,</span><span class="lit">1</span><span class="pun">,</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> </span><span class="pun">[</span><span class="lit">6</span><span class="pun">]</span><span class="pln"> </span><span class="pun">);</span><span class="pln">
      </span><span class="com">// connect inputs and outputs here</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">);</span></pre>
            <h5 id="merger_worker.js">
              merger_worker.js
            </h5>
            <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">onaudioprocess</span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> input</span><span class="pun">=</span><span class="lit">0</span><span class="pun">;</span><span class="pln"> input</span><span class="pun">&lt;</span><span class="pln">e</span><span class="pun">,</span><span class="pln">node</span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> input</span><span class="pun">++)</span><span class="pln">
    e</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">outputs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="pln">input</span><span class="pun">].</span><span class="kwd">set</span><span class="pun">(</span><span class="pln">e</span><span class="pun">.</span><span class="pln">node</span><span class="pun">.</span><span class="pln">inputs</span><span class="pun">[</span><span class="pln">input</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]);</span><span class="pln">
</span><span class="pun">};</span></pre>
          </section>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#the-scriptprocessornode-interface---deprecated" typeof="bibo:Chapter" id="the-scriptprocessornode-interface---deprecated" class="informative">
        <h3 resource="#h-the-scriptprocessornode-interface---deprecated" id="h-the-scriptprocessornode-interface---deprecated"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.13 </span>
          The ScriptProcessorNode Interface - DEPRECATED
        </span></h3><p><em>This section is non-normative.</em></p>
        <p>
          This interface is an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> which can
          generate, process, or analyse audio directly using JavaScript. This
          node type is deprecated, to be replaced by the
          <a class="idlType" href="#idl-def-AudioWorkerNode"><code>AudioWorkerNode</code></a>; this text is only here for informative
          purposes until implementations remove this node type.
        </p>
        <pre>    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCount = numberOfInputChannels;
    channelCountMode = "explicit";
    channelInterpretation = "speakers";
</pre>
        <p>
          The <code>channelCountMode</code> cannot be changed from "explicit"
          and the <code>channelCount</code> cannot be changed. An attempt to
          change either of these <em title="MUST" class="rfc2119">MUST</em> throw an InvalidStateError exception.
        </p>
        <p>
          The <a class="idlType" href="#idl-def-ScriptProcessorNode"><code>ScriptProcessorNode</code></a> is constructed with a
          <dfn id="dfn-buffersize" data-dfn-type="dfn">bufferSize</dfn> which must be one of the following values: 256,
          512, 1024, 2048, 4096, 8192, 16384. This value controls how
          frequently the <!--a href="#audioprocess-spnode"--><a data-link-type="dfn" class="internalDFN" href="#audioprocess-worker">audioprocess</a> event
          is dispatched and how many sample-frames need to be processed each
          call. <!--a href="#audioprocess-spnode"--><a data-link-type="dfn" class="internalDFN" href="#audioprocess-worker"><code>audioprocess</code></a>
          events are only dispatched if the
          <a class="idlType" href="#idl-def-ScriptProcessorNode"><code>ScriptProcessorNode</code></a> has at least one input or one
          output connected. Lower numbers for <a href="#widl-ScriptProcessorNode-bufferSize">bufferSize</a> will result in
          a lower (better) <a href="#latency">latency</a>. Higher numbers will
          be necessary to avoid audio breakup and <a href="#audio-glitching">glitches</a>. This value will be picked by the
          implementation if the bufferSize argument to
          <code>createScriptProcessor</code> is not passed in, or is set to 0.
        </p>
        <p>
          <dfn id="dfn-numberofinputchannels" data-dfn-type="dfn">numberOfInputChannels</dfn> and
          <dfn id="dfn-numberofoutputchannels" data-dfn-type="dfn">numberOfOutputChannels</dfn> determine the number of input and
          output channels. It is invalid for both
          <code>numberOfInputChannels</code> and
          <code>numberOfOutputChannels</code> to be zero.
        </p>
        <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">    </span><span class="kwd">var</span><span class="pln"> node </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createScriptProcessor</span><span class="pun">(</span><span class="pln">bufferSize</span><span class="pun">,</span><span class="pln"> numberOfInputChannels</span><span class="pun">,</span><span class="pln"> numberOfOutputChannels</span><span class="pun">);</span></pre>
        <pre class="idl"><span class="idlInterface" id="idl-def-ScriptProcessorNode">interface <span class="idlInterfaceID">ScriptProcessorNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlAttribute">                    attribute <span class="idlAttrType">EventHandler</span> <span class="idlAttrName"><a href="#widl-ScriptProcessorNode-onaudioprocess">onaudioprocess</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">long</span>         <span class="idlAttrName"><a href="#widl-ScriptProcessorNode-bufferSize">bufferSize</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-15" typeof="bibo:Chapter" id="attributes-15"><h4 resource="#h-attributes-15" id="h-attributes-15"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.13.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-ScriptProcessorNode-bufferSize"><code>bufferSize</code> of type <span class="idlAttrType">long</span>, readonly       </dt><dd>
            The size of the buffer (in sample-frames) which needs to be
            processed each time <code>onaudioprocess</code> is called. Legal
            values are (256, 512, 1024, 2048, 4096, 8192, 16384).
          </dd><dt id="widl-ScriptProcessorNode-onaudioprocess"><code>onaudioprocess</code> of type <span class="idlAttrType">EventHandler</span></dt><dd>
            A property used to set the <code>EventHandler</code> (described in
            <cite><a href="https://html.spec.whatwg.org/multipage/webappapis.html#eventhandler">
            HTML</a></cite>[<cite><a href="#bib-HTML" class="bibref">HTML</a></cite>]) for the <!--a href=
            "#audioprocess-spnode"--><a data-link-type="dfn" class="internalDFN" href="#audioprocess-worker"><code>audioprocess</code></a> event that is
            dispatched to <a class="idlType" href="#idl-def-ScriptProcessorNode"><code>ScriptProcessorNode</code></a> node types.
            An event of type <a class="idlType" href="#idl-def-AudioProcessingEvent"><code>AudioProcessingEvent</code></a> will be
            dispatched to the event handler.
          </dd></dl></section>
      </section>
      <section property="bibo:hasPart" resource="#the-audioworkernodecreationevent-interface" typeof="bibo:Chapter" id="the-audioworkernodecreationevent-interface">
        <h3 resource="#h-the-audioworkernodecreationevent-interface" id="h-the-audioworkernodecreationevent-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.14 </span>
          The AudioWorkerNodeCreationEvent Interface
        </span></h3>
        <p>
          This is an <code>Event</code> object which is dispatched to
          <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> objects when a new node
          instance is created. This allows AudioWorkers to initialize any
          node-local data (e.g. allocating a delay or initializing local
          variables).
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-AudioWorkerNodeCreationEvent">interface <span class="idlInterfaceID">AudioWorkerNodeCreationEvent</span> : <span class="idlSuperclass">Event</span> {
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioWorkerNodeProcessor"><code>AudioWorkerNodeProcessor</code></a></span> <span class="idlAttrName"><a href="#widl-AudioWorkerNodeCreationEvent-node">node</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">Array</span>                    <span class="idlAttrName"><a href="#widl-AudioWorkerNodeCreationEvent-inputs">inputs</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">Array</span>                    <span class="idlAttrName"><a href="#widl-AudioWorkerNodeCreationEvent-outputs">outputs</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-16" typeof="bibo:Chapter" id="attributes-16"><h4 resource="#h-attributes-16" id="h-attributes-16"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.14.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-AudioWorkerNodeCreationEvent-inputs"><code>inputs</code> of type <span class="idlAttrType">Array</span>, readonly       </dt><dd>
            An array of channelCounts for the inputs.
          </dd><dt id="widl-AudioWorkerNodeCreationEvent-node"><code>node</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioWorkerNodeProcessor"><code>AudioWorkerNodeProcessor</code></a></span>, readonly       </dt><dd>
            The new node being created. Any node-local data storage (e.g., the
            buffer for a delay node) should be created on this object.
          </dd><dt id="widl-AudioWorkerNodeCreationEvent-outputs"><code>outputs</code> of type <span class="idlAttrType">Array</span>, readonly       </dt><dd>
            An array of channelCounts for the outputs.
          </dd></dl></section>
      </section>
      <section property="bibo:hasPart" resource="#the-audioprocessevent-interface" typeof="bibo:Chapter" id="the-audioprocessevent-interface">
        <h3 resource="#h-the-audioprocessevent-interface" id="h-the-audioprocessevent-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.15 </span>
          The AudioProcessEvent Interface
        </span></h3>
        <p>
          This is an <code>Event</code> object which is dispatched to
          <a class="idlType" href="#idl-def-AudioWorkerGlobalScope"><code>AudioWorkerGlobalScope</code></a> objects to perform
          processing.
        </p>
        <p>
          The event handler processes audio from the input (if any) by
          accessing the audio data from the <code>inputBuffers</code>
          attribute. The audio data which is the result of the processing (or
          the synthesized data if there are no inputs) is then placed into the
          <code>outputBuffers</code>.
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-AudioProcessEvent">interface <span class="idlInterfaceID">AudioProcessEvent</span> : <span class="idlSuperclass">Event</span> {
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">double</span>                   <span class="idlAttrName"><a href="#widl-AudioProcessEvent-playbackTime">playbackTime</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioWorkerNodeProcessor"><code>AudioWorkerNodeProcessor</code></a></span> <span class="idlAttrName"><a href="#widl-AudioProcessEvent-node">node</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">Float32Array[][]</span>         <span class="idlAttrName"><a href="#widl-AudioProcessEvent-inputs">inputs</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">Float32Array[][]</span>         <span class="idlAttrName"><a href="#widl-AudioProcessEvent-outputs">outputs</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">object</span>                   <span class="idlAttrName"><a href="#widl-AudioProcessEvent-parameters">parameters</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-17" typeof="bibo:Chapter" id="attributes-17"><h4 resource="#h-attributes-17" id="h-attributes-17"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.15.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-AudioProcessEvent-inputs"><code>inputs</code> of type array of array of <span class="idlAttrType">Float32Array</span>, readonly       </dt><dd>
            <p>
              A readonly Array of Arrays of Float32Arrays. The top-level Array
              is organized by input; each input may contain multiple channels;
              each channel contains a Float32Array of sample data. The initial
              size of the channel array will be determined by the number of
              channels specified for that input in the createAudioWorkerNode()
              method. However, an onprocess handler may alter this number of
              channels in the input dynamically, either by adding a
              Float32Array of blocksize length (128) or by reducing the Array
              (by reducing the Array.length or by using Array.pop() or
              Array.slice(). The event object, the Array and the Float32Arrays
              will be reused by the processing system, in order to minimize
              memory churn.
            </p>
            <p>
              Any reordering performed on the Array for an input will not
              reorganize the connections to the channels for subsequent events.
            </p>
          </dd><dt id="widl-AudioProcessEvent-node"><code>node</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioWorkerNodeProcessor"><code>AudioWorkerNodeProcessor</code></a></span>, readonly       </dt><dd>
            The node to which this processing event is being dispatched. Any
            node-local data storage (e.g., the buffer for a delay node) should
            be maintained on this object.
          </dd><dt id="widl-AudioProcessEvent-outputs"><code>outputs</code> of type array of array of <span class="idlAttrType">Float32Array</span>, readonly       </dt><dd>
            <p>
              A readonly Array of Arrays of Float32Arrays. The top-level Array
              is organized by output; each output may contain multiple
              channels; each channel contains a Float32Array of sample data.
              The initial size of the channel array will be determined by the
              number of channels specified for that output in the
              createAudioWorkerNode() method. However, an onprocess handler may
              alter this number of channels in the output dynamically, either
              by adding a Float32Array of blocksize length (128) or by reducing
              the Array (by reducing the Array.length or by using Array.pop()
              or Array.slice(). The event object, the Array and the
              Float32Arrays will be reused by the processing system, in order
              to minimize memory churn.
            </p>
            <p>
              Any reordering performed on the Array for an output will not
              reorganize the connections to the channels for subsequent events.
            </p>
          </dd><dt id="widl-AudioProcessEvent-parameters"><code>parameters</code> of type <span class="idlAttrType">object</span>, readonly       </dt><dd>
            This object attribute exposes a correspondingly-named read-only
            Float32Array for each parameter that has been added via
            addParameter. As this is dynamic, this cannot be captured in
            IDL. The length of this Float32Array will correspond to the length
            of the inputBuffer. The contents of this Float32Array will be the
            values to be used for the AudioParam at the corresponding points in
            time. It is expected that this Float32Array will be reused by the
            audio engine.
          </dd><dt id="widl-AudioProcessEvent-playbackTime"><code>playbackTime</code> of type <span class="idlAttrType">double</span>, readonly       </dt><dd>
            The starting time of the block of audio being processed in response
            to this event. By definition this will be equal to the value of
            <a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a>'s <a href="#widl-BaseAudioContext-currentTime">currentTime</a> attribute that
            was most recently observable in the control thread.
          </dd></dl></section>
      </section>
      <section property="bibo:hasPart" resource="#the-audioprocessingevent-interface---deprecated" typeof="bibo:Chapter" id="the-audioprocessingevent-interface---deprecated" class="informative">
        <h3 resource="#h-the-audioprocessingevent-interface---deprecated" id="h-the-audioprocessingevent-interface---deprecated"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.16 </span>
          The AudioProcessingEvent Interface - DEPRECATED
        </span></h3><p><em>This section is non-normative.</em></p>
        <p>
          This is an <code>Event</code> object which is dispatched to
          <a class="idlType" href="#idl-def-ScriptProcessorNode"><code>ScriptProcessorNode</code></a> nodes. It will be removed
          when the ScriptProcessorNode is removed, as the replacement
          <a class="idlType" href="#idl-def-AudioWorker"><code>AudioWorker</code></a> uses the <a class="idlType" href="#idl-def-AudioProcessEvent"><code>AudioProcessEvent</code></a>.
        </p>
        <p>
          The event handler processes audio from the input (if any) by
          accessing the audio data from the <code>inputBuffer</code> attribute.
          The audio data which is the result of the processing (or the
          synthesized data if there are no inputs) is then placed into the
          <code>outputBuffer</code>.
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-AudioProcessingEvent">interface <span class="idlInterfaceID">AudioProcessingEvent</span> : <span class="idlSuperclass">Event</span> {
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">double</span>      <span class="idlAttrName"><a href="#widl-AudioProcessingEvent-playbackTime">playbackTime</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a></span> <span class="idlAttrName"><a href="#widl-AudioProcessingEvent-inputBuffer">inputBuffer</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a></span> <span class="idlAttrName"><a href="#widl-AudioProcessingEvent-outputBuffer">outputBuffer</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-18" typeof="bibo:Chapter" id="attributes-18"><h4 resource="#h-attributes-18" id="h-attributes-18"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.16.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-AudioProcessingEvent-inputBuffer"><code>inputBuffer</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a></span>, readonly       </dt><dd>
            An AudioBuffer containing the input audio data. It will have a
            number of channels equal to the <code>numberOfInputChannels</code>
            parameter of the createScriptProcessor() method. This AudioBuffer
            is only valid while in the scope of the <code>onaudioprocess</code>
            function. Its values will be meaningless outside of this scope.
          </dd><dt id="widl-AudioProcessingEvent-outputBuffer"><code>outputBuffer</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a></span>, readonly       </dt><dd>
            An AudioBuffer where the output audio data should be written. It
            will have a number of channels equal to the
            <code>numberOfOutputChannels</code> parameter of the
            createScriptProcessor() method. Script code within the scope of the
            <code>onaudioprocess</code> function is expected to modify the
            <code>Float32Array</code> arrays representing channel data in this
            AudioBuffer. Any script modifications to this AudioBuffer outside
            of this scope will not produce any audible effects.
          </dd><dt id="widl-AudioProcessingEvent-playbackTime"><code>playbackTime</code> of type <span class="idlAttrType">double</span>, readonly       </dt><dd>
            The time when the audio will be played in the same time coordinate
            system as the <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s <a href="#widl-BaseAudioContext-currentTime">currentTime</a>.
          </dd></dl></section>
      </section>
      <section property="bibo:hasPart" resource="#the-pannernode-interface" typeof="bibo:Chapter" id="the-pannernode-interface">
        <h3 resource="#h-the-pannernode-interface" id="h-the-pannernode-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.17 </span>
          The PannerNode Interface
        </span></h3>
        <p>
          This interface represents a processing node which <a href="#Spatialization">positions / spatializes</a> an incoming audio
          stream in three-dimensional space. The spatialization is in relation
          to the <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s <a class="idlType" href="#idl-def-AudioListener"><code>AudioListener</code></a>
          (<code>listener</code> attribute).
        </p>
        <pre>    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCount = 2;
    channelCountMode = "clamped-max";
    channelInterpretation = "speakers";
</pre>
        <p>
          The input of this node is either mono (1 channel) or stereo (2
          channels) and cannot be increased. Connections from nodes with fewer
          or more channels will be <a href="#channel-up-mixing-and-down-mixing">up-mixed or down-mixed
          appropriately</a>, but a NotSupportedError <em title="MUST" class="rfc2119">MUST</em> be thrown if an
          attempt is made to set channelCount to a value greater than 2 or if
          channelCountMode is set to "max".
        </p>
        <p>
          The output of this node is hard-coded to stereo (2 channels) and
          cannot be configured.
        </p>
        <p>
          The <a class="idlType" href="#idl-def-PanningModelType"><code>PanningModelType</code></a> enum determines which
          spatialization algorithm will be used to position the audio in 3D
          space. The default is <code>"equalpower"</code>.
        </p>
        <pre class="idl"><span class="idlEnum" id="idl-def-PanningModelType">enum <span class="idlEnumID">PanningModelType</span> {
    "<a href="#idl-def-PanningModelType.equalpower" class="idlEnumItem">equalpower</a>",
    "<a href="#idl-def-PanningModelType.xHRTF" class="idlEnumItem">HRTF</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code id="idl-def-PanningModelType.equalpower">equalpower</code></td><td>
            A simple and efficient spatialization algorithm using equal-power
            panning.
          </td></tr><tr><td><code id="idl-def-PanningModelType.xHRTF">HRTF</code></td><td>
            A higher quality spatialization algorithm using a convolution with
            measured impulse responses from human subjects. This panning method
            renders stereo output.
          </td></tr></tbody></table>
        <p>
          The <a class="idlType" href="#idl-def-DistanceModelType"><code>DistanceModelType</code></a> enum determines which
          algorithm will be used to reduce the volume of an audio source as it
          moves away from the listener. The default is "inverse".
        </p>
        <p>
          In the description of each distance model below, let \(d\) be the
          distance between the listener and the panner; \(d_{ref}\) be the
          value of the <code>refDistance</code> attribute; \(d_{max}\) be the
          value of the <code>maxDistance</code> attribute; and \(f\) be the
          value of the <code>rolloffFactor</code> attribute.
        </p>
        <pre class="idl"><span class="idlEnum" id="idl-def-DistanceModelType">enum <span class="idlEnumID">DistanceModelType</span> {
    "<a href="#idl-def-DistanceModelType.linear" class="idlEnumItem">linear</a>",
    "<a href="#idl-def-DistanceModelType.inverse" class="idlEnumItem">inverse</a>",
    "<a href="#idl-def-DistanceModelType.exponential" class="idlEnumItem">exponential</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code id="idl-def-DistanceModelType.linear">linear</code></td><td>
            <p>
              A linear distance model which calculates <em>distanceGain</em>
              according to:
            </p>
            <pre>            $$
              1 - f\frac{\max(\min(d, d_{max}), d_{ref}) - d_{ref}}{d_{max} - d_{ref}}
            $$

</pre>
            <p>
              That is, \(d\) is clamped to the interval \([d_{ref},\,
              d_{max}]\).
            </p>
          </td></tr><tr><td><code id="idl-def-DistanceModelType.inverse">inverse</code></td><td>
            <p>
              An inverse distance model which calculates <em>distanceGain</em>
              according to:
            </p>
            <pre>              $$
                \frac{d_{ref}}{d_{ref} + f (\max(d, d_{ref}) - d_{ref})}
              $$

</pre>
            <p>
              That is, \(d\) is clamped to the interval \([d_{ref},\,
              \infty)\).
            </p>
          </td></tr><tr><td><code id="idl-def-DistanceModelType.exponential">exponential</code></td><td>
            <p>
              An exponential distance model which calculates
              <em>distanceGain</em> according to:
            </p>
            <pre>              $$
                \left(\frac{\max(d, d_{ref})}{d_{ref}}\right)^{-f}
              $$

</pre>
            <p>
              That is, \(d\) is clamped to the interval \([d_{ref},\,
              \infty)\).
            </p>
          </td></tr></tbody></table>
        <pre class="idl"><span class="idlInterface" id="idl-def-PannerNode">interface <span class="idlInterfaceID">PannerNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlAttribute">                    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-PanningModelType"><code>PanningModelType</code></a></span>  <span class="idlAttrName"><a href="#widl-PannerNode-panningModel">panningModel</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-PannerNode-setPosition-void-float-x-float-y-float-z">setPosition</a></span> (<span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">x</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">y</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">z</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-PannerNode-setOrientation-void-float-x-float-y-float-z">setOrientation</a></span> (<span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">x</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">y</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">z</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-PannerNode-setVelocity-void-float-x-float-y-float-z">setVelocity</a></span> (<span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">x</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">y</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">z</span></span>);</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-DistanceModelType"><code>DistanceModelType</code></a></span> <span class="idlAttrName"><a href="#widl-PannerNode-distanceModel">distanceModel</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">float</span>             <span class="idlAttrName"><a href="#widl-PannerNode-refDistance">refDistance</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">float</span>             <span class="idlAttrName"><a href="#widl-PannerNode-maxDistance">maxDistance</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">float</span>             <span class="idlAttrName"><a href="#widl-PannerNode-rolloffFactor">rolloffFactor</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">float</span>             <span class="idlAttrName"><a href="#widl-PannerNode-coneInnerAngle">coneInnerAngle</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">float</span>             <span class="idlAttrName"><a href="#widl-PannerNode-coneOuterAngle">coneOuterAngle</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">float</span>             <span class="idlAttrName"><a href="#widl-PannerNode-coneOuterGain">coneOuterGain</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-19" typeof="bibo:Chapter" id="attributes-19"><h4 resource="#h-attributes-19" id="h-attributes-19"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.17.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-PannerNode-coneInnerAngle"><code>coneInnerAngle</code> of type <span class="idlAttrType">float</span></dt><dd>
            A parameter for directional audio sources, this is an angle, in
            degrees, inside of which there will be no volume reduction. The
            default value is 360, and the value is used modulo 360.
          </dd><dt id="widl-PannerNode-coneOuterAngle"><code>coneOuterAngle</code> of type <span class="idlAttrType">float</span></dt><dd>
            A parameter for directional audio sources, this is an angle, in
            degrees, outside of which the volume will be reduced to a constant
            value of <code>coneOuterGain</code>. The default value is
            360 and the value is used modulo 360.
          </dd><dt id="widl-PannerNode-coneOuterGain"><code>coneOuterGain</code> of type <span class="idlAttrType">float</span></dt><dd>
            A parameter for directional audio sources, this is the gain outside
            of the <code>coneOuterAngle</code>. The default value is 0.
            It is a linear value (not dB) in the range [0, 1]. An
            InvalidStateError <em title="MUST" class="rfc2119">MUST</em> be thrown if the parameter is outside this
            range.
          </dd><dt id="widl-PannerNode-distanceModel"><code>distanceModel</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-DistanceModelType"><code>DistanceModelType</code></a></span></dt><dd>
            Specifies the distance model used by this
            <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a>. Defaults to
            <code>"inverse"</code>.
          </dd><dt id="widl-PannerNode-maxDistance"><code>maxDistance</code> of type <span class="idlAttrType">float</span></dt><dd>
            The maximum distance between source and listener, after which the
            volume will not be reduced any further. The default value is 10000.
          </dd><dt id="widl-PannerNode-panningModel"><code>panningModel</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-PanningModelType"><code>PanningModelType</code></a></span></dt><dd>
            Specifies the panning model used by this
            <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a>. Defaults to
            <code>"equalpower"</code>.
          </dd><dt id="widl-PannerNode-refDistance"><code>refDistance</code> of type <span class="idlAttrType">float</span></dt><dd>
            A reference distance for reducing volume as source move further
            from the listener. The default value is 1.
          </dd><dt id="widl-PannerNode-rolloffFactor"><code>rolloffFactor</code> of type <span class="idlAttrType">float</span></dt><dd>
            Describes how quickly the volume is reduced as source moves away
            from listener. The default value is 1.
          </dd></dl></section><section property="bibo:hasPart" resource="#methods-11" typeof="bibo:Chapter" id="methods-11"><h4 resource="#h-methods-11" id="h-methods-11"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.17.2 </span>Methods</span></h4><dl class="methods"><dt id="widl-PannerNode-setOrientation-void-float-x-float-y-float-z"><code>setOrientation</code></dt><dd>
            <p>
              Describes which direction the audio source is pointing in the 3D
              cartesian coordinate space. Depending on how directional the
              sound is (controlled by the <b>cone</b> attributes), a sound
              pointing away from the listener can be very quiet or completely
              silent.
            </p>
            <p>
              The <code>x, y, z</code> parameters represent a direction vector
              in 3D space.
            </p>
            <p>
              The default value is (1,0,0)
            </p>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">x</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">y</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">z</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-PannerNode-setPosition-void-float-x-float-y-float-z"><code>setPosition</code></dt><dd>
            <p>
              Sets the position of the audio source relative to the
              <code>listener</code> attribute. A 3D cartesian coordinate
              system is used.
            </p>
            <p>
              The <code>x, y, z</code> parameters represent the coordinates in
              3D space.
            </p>
            <p>
              The default value is (0,0,0)
            </p>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">x</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">y</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">z</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-PannerNode-setVelocity-void-float-x-float-y-float-z"><code>setVelocity</code></dt><dd>
            <p>
              Sets the velocity vector of the audio source. This vector
              controls both the direction of travel and the speed in 3D space.
              This velocity relative to the listener's velocity is used to
              determine how much doppler shift (pitch change) to apply. The
              units used for this vector is <em>meters / second</em> and is
              independent of the units used for position and orientation
              vectors.
            </p>
            <p>
              The <code>x, y, z</code> parameters describe a direction vector
              indicating direction of travel and intensity.
            </p>
            <p>
              The default value is (0,0,0)
            </p>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">x</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">y</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">z</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd></dl></section>
        <section property="bibo:hasPart" resource="#panner-channel-limitations" typeof="bibo:Chapter" class="informative">
          <h4 resource="#panner-channel-limitations" id="panner-channel-limitations"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.17.3 </span>
            Channel Limitations
          </span></h4><p><em>This section is non-normative.</em></p>
          <p>
            The set of <a href="#panner-channel-limitations">channel
            limitations</a> for <a class="idlType" href="#idl-def-StereoPannerNode"><code>StereoPannerNode</code></a> also apply
            to <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a>.
          </p>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#AudioListener" typeof="bibo:Chapter">
        <h3 resource="#AudioListener" id="AudioListener"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.18 </span>
          The AudioListener Interface
        </span></h3>
        <p>
          This interface is DEPRECATED, as it will be replaced by the
          <a class="idlType" href="#idl-def-SpatialListener"><code>SpatialListener</code></a>. This interface represents the
          position and orientation of the person listening to the audio scene.
          All <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a> objects spatialize in relation to
          the <a class="idlType" href="#idl-def-BaseAudioContext"><code>BaseAudioContext</code></a>'s <!--a href=
          "widl-AudioContext-listener"--><code>listener</code>. See <a href="#Spatialization">the Spatialization/Panning section</a> for more
          details about spatialization.
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-AudioListener">interface <span class="idlInterfaceID">AudioListener</span> {
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-AudioListener-setPosition-void-float-x-float-y-float-z">setPosition</a></span> (<span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">x</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">y</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">z</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-AudioListener-setOrientation-void-float-x-float-y-float-z-float-xUp-float-yUp-float-zUp">setOrientation</a></span> (<span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">x</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">y</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">z</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">xUp</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">yUp</span></span>, <span class="idlParam"><span class="idlParamType">float</span> <span class="idlParamName">zUp</span></span>);</span>
};</span></pre><section property="bibo:hasPart" resource="#methods-12" typeof="bibo:Chapter" id="methods-12"><h4 resource="#h-methods-12" id="h-methods-12"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.18.1 </span>Methods</span></h4><dl class="methods"><dt id="widl-AudioListener-setOrientation-void-float-x-float-y-float-z-float-xUp-float-yUp-float-zUp"><code>setOrientation</code></dt><dd>
            <p>
              Describes which direction the listener is pointing in the 3D
              cartesian coordinate space. Both a <b>front</b> vector and an
              <b>up</b> vector are provided. In simple human terms, the
              <b>front</b> vector represents which direction the person's nose
              is pointing. The <b>up</b> vector represents the direction the
              top of a person's head is pointing. These values are expected to
              be linearly independent (at right angles to each other). For
              normative requirements of how these values are to be interpreted,
              see the <a href="#Spatialization">spatialization section</a>.
            </p>
            <p>
              The <code>x, y, z</code> parameters represent a <b>front</b>
              direction vector in 3D space, with the default value being
              (0,0,-1).
            </p>
            <p>
              The <code>xUp, yUp, zUp</code> parameters represent an <b>up</b>
              direction vector in 3D space, with the default value being
              (0,1,0).
            </p>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">x</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">y</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">z</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">xUp</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">yUp</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">zUp</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-AudioListener-setPosition-void-float-x-float-y-float-z"><code>setPosition</code></dt><dd>
            <p>
              Sets the position of the listener in a 3D cartesian coordinate
              space. <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a> objects use this position
              relative to individual audio sources for spatialization.
            </p>
            <p>
              The <code>x, y, z</code> parameters represent the coordinates in
              3D space.
            </p>
            <p>
              The default value is (0,0,0)
            </p>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">x</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">y</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr><tr><td class="prmName">z</td><td class="prmType"><code>float</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd></dl></section>
      </section>
      <section property="bibo:hasPart" resource="#the-spatialpannernode-interface" typeof="bibo:Chapter" id="the-spatialpannernode-interface">
        <h3 resource="#h-the-spatialpannernode-interface" id="h-the-spatialpannernode-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.19 </span>
          The SpatialPannerNode Interface
        </span></h3>
        <p>
          This interface represents a processing node which <a href="#Spatialization">positions</a> an incoming audio stream in
          three-dimensional space. The spatialization is in relation to the
          <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s <a class="idlType" href="#idl-def-SpatialListener"><code>SpatialListener</code></a>
          (<code>listener</code> attribute).
        </p>
        <p>
          It should be explicitly noticed that the auditory effects of this
          spatialization may not work well unless the SpatialPanner is directly
          connected to the destination node; subsequent processing (after the
          SpatialPanner, before the destination) may disrupt the effects.
        </p>
        <pre>    numberOfInputs  : 1
    numberOfOutputs : 1
    channelCount = 2;
    channelCountMode = "clamped-max";
    channelInterpretation = "speakers";
</pre>
        <p>
          The input of this node is either mono (1 channel) or stereo (2
          channels) and cannot be increased. Connections from nodes with more
          channels will be <a href="#channel-up-mixing-and-down-mixing">up-mixed or down-mixed
          appropriately</a>, but a NotSupportedError <em title="MUST" class="rfc2119">MUST</em> be thrown if an
          attempt is made to set channelCount to a value greater than 2 or if
          channelCountMode is set to "max". The output of this node will be
          stereo (2 channels) and currently cannot be configured.
        </p>
        <p>
          The <a class="idlType" href="#idl-def-PanningModelType"><code>PanningModelType</code></a> enum determines which
          spatialization algorithm will be used to position the audio in 3D
          space. The default is <code>"equal-power"</code>.
        </p>
        <pre class="idl"><span class="idlEnum">enum <span class="idlEnumID">PanningModelType</span> {
    "<a href="#idl-def-PanningModelType.equalpower" class="idlEnumItem">equalpower</a>",
    "<a href="#idl-def-PanningModelType.xHRTF" class="idlEnumItem">HRTF</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code>equalpower</code></td><td>
            A simple and efficient spatialization algorithm using equal-power
            panning.
          </td></tr><tr><td><code>HRTF</code></td><td>
            A higher quality spatialization algorithm using a convolution with
            measured impulse responses from human subjects. This panning method
            renders stereo output.
          </td></tr></tbody></table>
        <p>
          The <a class="idlType" href="#idl-def-DistanceModelType"><code>DistanceModelType</code></a> enum determines which
          algorithm will be used to reduce the volume of an audio source as it
          moves away from the listener. The default is "inverse".
        </p>
        <pre class="idl"><span class="idlEnum">enum <span class="idlEnumID">DistanceModelType</span> {
    "<a href="#idl-def-DistanceModelType.linear" class="idlEnumItem">linear</a>",
    "<a href="#idl-def-DistanceModelType.inverse" class="idlEnumItem">inverse</a>",
    "<a href="#idl-def-DistanceModelType.exponential" class="idlEnumItem">exponential</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code>linear</code></td><td>
            A linear distance model which calculates <em>distanceGain</em>
            according to:
            <pre>            1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance)
</pre>
          </td></tr><tr><td><code>inverse</code></td><td>
            An inverse distance model which calculates <em>distanceGain</em>
            according to:
            <pre>            refDistance / (refDistance + rolloffFactor * (distance - refDistance))
</pre>
          </td></tr><tr><td><code>exponential</code></td><td>
            An exponential distance model which calculates
            <em>distanceGain</em> according to:
            <pre>pow(distance / refDistance, -rolloffFactor)
</pre>
          </td></tr></tbody></table>
        <pre class="idl"><span class="idlInterface" id="idl-def-SpatialPannerNode">interface <span class="idlInterfaceID">SpatialPannerNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlAttribute">                    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-PanningModelType"><code>PanningModelType</code></a></span>  <span class="idlAttrName"><a href="#widl-SpatialPannerNode-panningModel">panningModel</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>        <span class="idlAttrName"><a href="#widl-SpatialPannerNode-positionX">positionX</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>        <span class="idlAttrName"><a href="#widl-SpatialPannerNode-positionY">positionY</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>        <span class="idlAttrName"><a href="#widl-SpatialPannerNode-positionZ">positionZ</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>        <span class="idlAttrName"><a href="#widl-SpatialPannerNode-orientationX">orientationX</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>        <span class="idlAttrName"><a href="#widl-SpatialPannerNode-orientationY">orientationY</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>        <span class="idlAttrName"><a href="#widl-SpatialPannerNode-orientationZ">orientationZ</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-DistanceModelType"><code>DistanceModelType</code></a></span> <span class="idlAttrName"><a href="#widl-SpatialPannerNode-distanceModel">distanceModel</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">float</span>             <span class="idlAttrName"><a href="#widl-SpatialPannerNode-refDistance">refDistance</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">float</span>             <span class="idlAttrName"><a href="#widl-SpatialPannerNode-maxDistance">maxDistance</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">float</span>             <span class="idlAttrName"><a href="#widl-SpatialPannerNode-rolloffFactor">rolloffFactor</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">float</span>             <span class="idlAttrName"><a href="#widl-SpatialPannerNode-coneInnerAngle">coneInnerAngle</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">float</span>             <span class="idlAttrName"><a href="#widl-SpatialPannerNode-coneOuterAngle">coneOuterAngle</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">float</span>             <span class="idlAttrName"><a href="#widl-SpatialPannerNode-coneOuterGain">coneOuterGain</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-20" typeof="bibo:Chapter" id="attributes-20"><h4 resource="#h-attributes-20" id="h-attributes-20"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.19.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-SpatialPannerNode-coneInnerAngle"><code>coneInnerAngle</code> of type <span class="idlAttrType">float</span></dt><dd>
            A parameter for directional audio sources, this is an angle, in
            degrees, inside of which there will be no volume reduction. The
            default value is 360.
          </dd><dt id="widl-SpatialPannerNode-coneOuterAngle"><code>coneOuterAngle</code> of type <span class="idlAttrType">float</span></dt><dd>
            A parameter for directional audio sources, this is an angle, in
            degrees, outside of which the volume will be reduced to a constant
            value of <code>coneOuterGain</code>. The default value is
            360.
          </dd><dt id="widl-SpatialPannerNode-coneOuterGain"><code>coneOuterGain</code> of type <span class="idlAttrType">float</span></dt><dd>
            A parameter for directional audio sources, this is the amount of
            volume reduction outside of the <code>coneOuterAngle</code>.
            The default value is 0.
          </dd><dt id="widl-SpatialPannerNode-distanceModel"><code>distanceModel</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-DistanceModelType"><code>DistanceModelType</code></a></span></dt><dd>
            Specifies the distance model used by this
            <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a>. Defaults to
            <code>"inverse"</code>.
          </dd><dt id="widl-SpatialPannerNode-maxDistance"><code>maxDistance</code> of type <span class="idlAttrType">float</span></dt><dd>
            The maximum distance between source and listener, after which the
            volume will not be reduced any further. The default value is 10000.
          </dd><dt id="widl-SpatialPannerNode-orientationX"><code>orientationX</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            The <code>orientationX, orientationY, orientationZ</code>
            parameters represent a direction vector in 3D space.
          </dd><dt id="widl-SpatialPannerNode-orientationY"><code>orientationY</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            Describes the y component of the vector of the direction the audio
            source is pointing in 3D cartesian coordinate space. The default
            value is 0. This parameter is a-rate.
          </dd><dt id="widl-SpatialPannerNode-orientationZ"><code>orientationZ</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            Describes the Z component of the vector of the direction the audio
            source is pointing in 3D cartesian coordinate space. The default
            value is 0. This parameter is a-rate.
          </dd><dt id="widl-SpatialPannerNode-panningModel"><code>panningModel</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-PanningModelType"><code>PanningModelType</code></a></span></dt><dd>
            Specifies the panning model used by this
            <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a>. Defaults to
            <code>"equal-power"</code>.
          </dd><dt id="widl-SpatialPannerNode-positionX"><code>positionX</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            Sets the x coordinate position of the audio source in a 3D
            Cartesian system. The default value is 0. This parameter is a-rate.
          </dd><dt id="widl-SpatialPannerNode-positionY"><code>positionY</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            Sets the y coordinate position of the audio source in a 3D
            Cartesian system. The default value is 0. This parameter is a-rate.
          </dd><dt id="widl-SpatialPannerNode-positionZ"><code>positionZ</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            Sets the z coordinate position of the audio source in a 3D
            Cartesian system. The default value is 0. This parameter is a-rate.
          </dd><dt id="widl-SpatialPannerNode-refDistance"><code>refDistance</code> of type <span class="idlAttrType">float</span></dt><dd>
            A reference distance for reducing volume as source move further
            from the listener. The default value is 1.
          </dd><dt id="widl-SpatialPannerNode-rolloffFactor"><code>rolloffFactor</code> of type <span class="idlAttrType">float</span></dt><dd>
            Describes how quickly the volume is reduced as source moves away
            from listener. The default value is 1.
          </dd></dl></section>
      </section>
      <section property="bibo:hasPart" resource="#SpatialListener" typeof="bibo:Chapter">
        <h3 resource="#SpatialListener" id="SpatialListener"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.20 </span>
          The SpatialListener Interface
        </span></h3>
        <p>
          This interface represents the position and orientation of the person
          listening to the audio scene. All
          <a class="idlType" href="#idl-def-SpatialPannerNode"><code>SpatialPannerNode</code></a> objects spatialize in relation
          to the <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s <!--a href=
          "widl-AudioContext-spatialListener"--><code>spatialListener</code>.
          See <a href="#Spatialization">the Spatialization/Panning section</a>
          for more details about spatialization.
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-SpatialListener">interface <span class="idlInterfaceID">SpatialListener</span> {
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-SpatialListener-positionX">positionX</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-SpatialListener-positionY">positionY</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-SpatialListener-positionZ">positionZ</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-SpatialListener-forwardX">forwardX</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-SpatialListener-forwardY">forwardY</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-SpatialListener-forwardZ">forwardZ</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-SpatialListener-upX">upX</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-SpatialListener-upY">upY</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-SpatialListener-upZ">upZ</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-21" typeof="bibo:Chapter" id="attributes-21"><h4 resource="#h-attributes-21" id="h-attributes-21"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.20.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-SpatialListener-forwardX"><code>forwardX</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            The <code>forwardX, forwardY, forwardZ</code> parameters represent
            a direction vector in 3D space. Both a <code>forward</code> vector
            and an <code>up</code> vector are used to determine the orientation
            of the listener. In simple human terms, the <code>forward</code>
            vector represents which direction the person's nose is pointing.
            The <code>up</code> vector represents the direction the top of a
            person's head is pointing. These values are expected to be linearly
            independent (at right angles to each other), and unpredictable
            behavior may result if they are not. For normative requirements of
            how these values are to be interpreted, see the <a href="#Spatialization">spatialization section</a>.
          </dd><dt id="widl-SpatialListener-forwardY"><code>forwardY</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            Sets the y coordinate component of the forward direction the
            listener is pointing in 3D Cartesian coordinate space. The default
            value is 0. This parameter is a-rate.
          </dd><dt id="widl-SpatialListener-forwardZ"><code>forwardZ</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            Sets the z coordinate component of the forward direction the
            listener is pointing in 3D Cartesian coordinate space. The default
            value is 0. This parameter is a-rate.
          </dd><dt id="widl-SpatialListener-positionX"><code>positionX</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            Sets the x coordinate position of the audio listener in a 3D
            Cartesian coordinate space. <a class="idlType" href="#idl-def-SpatialPannerNode"><code>SpatialPannerNode</code></a>
            objects use this position relative to individual audio sources for
            spatialization. The default value is 0. This parameter is a-rate.
          </dd><dt id="widl-SpatialListener-positionY"><code>positionY</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            Sets the y coordinate position of the audio listener in a 3D
            Cartesian coordinate space. The default value is 0. This parameter
            is a-rate.
          </dd><dt id="widl-SpatialListener-positionZ"><code>positionZ</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            Sets the z coordinate position of the audio listener in a 3D
            Cartesian coordinate space. The default value is 0. This parameter
            is a-rate.
          </dd><dt id="widl-SpatialListener-upX"><code>upX</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            The <code>upX, upY, upZ</code> parameters represent a direction
            vector in 3D space, indicating the direction of "up" to the
            listener. For normative requirements of how these values are to be
            interpreted, see the <a href="#Spatialization">spatialization
            section</a>.
          </dd><dt id="widl-SpatialListener-upY"><code>upY</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            Sets the y coordinate component of the up direction the listener is
            pointing in 3D Cartesian coordinate space. The default value is 0.
            This parameter is a-rate.
          </dd><dt id="widl-SpatialListener-upZ"><code>upZ</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            Sets the z coordinate component of the up direction the listener is
            pointing in 3D Cartesian coordinate space. The default value is 0.
            This parameter is a-rate.
          </dd></dl></section>
      </section>
      <section property="bibo:hasPart" resource="#the-stereopannernode-interface" typeof="bibo:Chapter" id="the-stereopannernode-interface">
        <h3 resource="#h-the-stereopannernode-interface" id="h-the-stereopannernode-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.21 </span>
          StereoPannerNode インターフェース
        </span></h3>
        <p class="orig">
          This interface represents a processing node which positions an
          incoming audio stream in a stereo image using a low-cost <a href="#Spatialzation-equal-power-panning">equal-power panning algorithm</a>. This
          panning effect is common in positioning audio components in a stereo
          stream.
        </p>
        <p>
          入力されるオーディオストリームに対してローコストな<a href="#Spatialzation-equal-power-panning">イコールパワー・バンニング</a>アルゴリズムによりステレオでの定位処理を行うノードを表します。このバンニング効果はステレオストリームでの定位を行う方法として一般的なものです。
        </p>
        <pre>    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCount = 2;
    channelCountMode = "clamped-max";
    channelInterpretation = "speakers";
</pre>
<p class="orig">
  The input of this node is stereo (2 channels) and cannot be
  increased. Connections from nodes with fewer or more channels will be
  <a href="#channel-up-mixing-and-down-mixing">up-mixed or down-mixed
  appropriately</a> , but a NotSupportedError will be thrown if an
  attempt is made to set <code>channelCount</code> to a value great
  than 2 or if <code>channelCountMode</code> is set to
  <code>"max"</code>.
</p>
<p>
  このノードの入力はステレオ(2チャンネル)であり増やす事はできません。より少ない、あるいは多いチャンネル数のノードから接続された場合は適宜<a href="#channel-up-mixing-and-down-mixing">チャンネル・アップミックスまたはダウン・ミックス</a>されますが、もし<code>channelCount</code>を2より大きな値に設定しようとする、あるいは<code>channelCountMode</code>を<code>"max"</code>に設定しようとすると NotSupportedError 例外を発生します。
</p>
<p class="orig">
  The output of this node is hard-coded to stereo (2 channels) and
  cannot be configured.
</p>
<p>
  このノードの出力はステレオ(2チャンネル)にハードコードされており、構成を変える事はできません。
</p>
        <pre class="idl"><span class="idlInterface" id="idl-def-StereoPannerNode">interface <span class="idlInterfaceID">StereoPannerNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-StereoPannerNode-pan">pan</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-22" typeof="bibo:Chapter" id="attributes-22"><h4 resource="#h-attributes-22" id="h-attributes-22"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.21.1 </span>属性</span></h4><dl class="attributes"><dt id="widl-StereoPannerNode-pan"><code>pan</code> <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>型, readonly       </dt>
  <dd class="orig">
            The position of the input in the output's stereo image. -1
            represents full left, +1 represents full right. Its default value
            is 0, and its nominal range is from -1 to 1. This parameter is a
            <a data-link-type="dfn" class="internalDFN" href="#a-rate">a-rate</a>.
  </dd>
  <dd>
      出力されるステレオイメージ中での入力信号の位置を指定します。-1ならば完全な左、+1ならば完全な右になります。デフォルト値は0で、範囲は-1から+1となります。このパラメータは  <a data-link-type="dfn" class="internalDFN" href="#a-rate">a-rate</a>です。
  </dd>
        </dl></section>
        <section property="bibo:hasPart" resource="#channel-limitations" typeof="bibo:Chapter" id="channel-limitations" class="informative">
          <h4 resource="#h-channel-limitations" id="h-channel-limitations"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.21.2 </span>
            チャンネルの制限
          </span></h4><p><em>このセクションは参考情報です。</em></p>
          <p class="orig">
            Because its processing is constrained by the above definitions,
            <a class="idlType" href="#idl-def-StereoPannerNode"><code>StereoPannerNode</code></a> is limited to mixing no more
            than 2 channels of audio, and producing exactly 2 channels. It is
            possible to use a <a class="idlType" href="#idl-def-ChannelSplitterNode"><code>ChannelSplitterNode</code></a>,
            intermediate processing by a subgraph of
            <a class="idlType" href="#idl-def-GainNode"><code>GainNode</code></a>s and/or other nodes, and recombination
            via a <a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a> to realize arbitrary
            approaches to panning and mixing.
          </p>
          <p>
            処理について上記のような制約があるため、<a class="idlType" href="#idl-def-StereoPannerNode"><code>StereoPannerNode</code></a>の処理は2チャンネルまでのオーディオのミキシングと2チャンネルのオーディオの生成に限られています。
            (<span class="annotate">訳注:それ以上のチャンネル数を扱いたい場合</span>)
            <a class="idlType" href="#idl-def-ChannelSplitterNode"><code>ChannelSplitterNode</code></a>を使用し、<a class="idlType" href="#idl-def-GainNode"><code>GainNode</code></a>などによるサブグラフでの中間的な処理を行って<a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a>を通して再度結合するような処理によって任意のバンニング/ミキシングを実現する事は可能です。
          </p>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#ConvolverNode" typeof="bibo:Chapter">
        <h3 resource="#ConvolverNode" id="ConvolverNode"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.22 </span>
          The ConvolverNode Interface
        </span></h3>
        <p>
          This interface represents a processing node which applies a linear
          convolution effect given an impulse response.
        </p>
        <pre>    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCount = 2;
    channelCountMode = "clamped-max";
    channelInterpretation = "speakers";
</pre>
        <p>
          The input of this node is either mono (1 channel) or stereo (2
          channels) and cannot be increased. Connections from nodes with fewer
          or more channels will be <a href="#channel-up-mixing-and-down-mixing">up-mixed or down-mixed
          appropriately</a>, but a NotSupportedError <em title="MUST" class="rfc2119">MUST</em> be thrown if an
          attempt is made to set channelCount to a value great than 2 or if
          channelCountMode is set to "max".
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-ConvolverNode">interface <span class="idlInterfaceID">ConvolverNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlAttribute">                    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>?</span> <span class="idlAttrName"><a href="#widl-ConvolverNode-buffer">buffer</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">boolean</span>      <span class="idlAttrName"><a href="#widl-ConvolverNode-normalize">normalize</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-23" typeof="bibo:Chapter" id="attributes-23"><h4 resource="#h-attributes-23" id="h-attributes-23"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.22.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-ConvolverNode-buffer"><code>buffer</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a></span>, nullable</dt><dd>
            A mono, stereo, or 4-channel <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>
            containing the (possibly multi-channel) impulse response used by
            the <a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a>. The <code>AudioBuffer</code>
            must have 1, 2, or 4 channels or a NotSupportedError exception <em title="MUST" class="rfc2119">MUST</em>
            be thrown. This <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a> must be of the same
            sample-rate as the <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> or a
            NotSupportedError exception <em title="MUST" class="rfc2119">MUST</em> be thrown. At the time when this
            attribute is set, the <em>buffer</em> and the state of the
            <em>normalize</em> attribute will be used to configure the
            <a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a> with this impulse response having
            the given normalization. The initial value of this attribute is
            null.
          </dd><dt id="widl-ConvolverNode-normalize"><code>normalize</code> of type <span class="idlAttrType">boolean</span></dt><dd>
            <p>
              Controls whether the impulse response from the buffer will be
              scaled by an equal-power normalization when the
              <code>buffer</code> atttribute is set. Its default value is
              <code>true</code> in order to achieve a more uniform output level
              from the convolver when loaded with diverse impulse responses. If
              <code>normalize</code> is set to <code>false</code>, then the
              convolution will be rendered with no pre-processing/scaling of
              the impulse response. Changes to this value do not take effect
              until the next time the <em>buffer</em> attribute is set.
            </p>
            <p>
              If the <em>normalize</em> attribute is false when the
              <em>buffer</em> attribute is set then the
              <a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a> will perform a linear
              convolution given the exact impulse response contained within the
              <em>buffer</em>.
            </p>
            <p>
              Otherwise, if the <em>normalize</em> attribute is true when the
              <em>buffer</em> attribute is set then the
              <a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a> will first perform a scaled
              RMS-power analysis of the audio data contained within
              <em>buffer</em> to calculate a <em>normalizationScale</em> given
              this algorithm:
            </p>
            <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">
</span><span class="kwd">function</span><span class="pln"> calculateNormalizationScale</span><span class="pun">(</span><span class="pln">buffer</span><span class="pun">)</span><span class="pln">
</span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> </span><span class="typ">GainCalibration</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.00125</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> </span><span class="typ">GainCalibrationSampleRate</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">44100</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> </span><span class="typ">MinPower</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.000125</span><span class="pun">;</span><span class="pln">

    </span><span class="com">// Normalize by RMS power.</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> numberOfChannels </span><span class="pun">=</span><span class="pln"> buffer</span><span class="pun">.</span><span class="pln">numberOfChannels</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> length </span><span class="pun">=</span><span class="pln"> buffer</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">var</span><span class="pln"> power </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> numberOfChannels</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">var</span><span class="pln"> channelPower </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
        </span><span class="kwd">var</span><span class="pln"> channelData </span><span class="pun">=</span><span class="pln"> buffer</span><span class="pun">.</span><span class="pln">getChannelData</span><span class="pun">(</span><span class="pln">i</span><span class="pun">);</span><span class="pln">

        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j </span><span class="pun">&lt;</span><span class="pln"> length</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">var</span><span class="pln"> sample </span><span class="pun">=</span><span class="pln"> channelData</span><span class="pun">[</span><span class="pln">j</span><span class="pun">];</span><span class="pln">
            channelPower </span><span class="pun">+=</span><span class="pln"> sample </span><span class="pun">*</span><span class="pln"> sample</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">

        power </span><span class="pun">+=</span><span class="pln"> channelPower</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    power </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">sqrt</span><span class="pun">(</span><span class="pln">power </span><span class="pun">/</span><span class="pln"> </span><span class="pun">(</span><span class="pln">numberOfChannels </span><span class="pun">*</span><span class="pln"> length</span><span class="pun">));</span><span class="pln">

    </span><span class="com">// Protect against accidental overload.</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">isFinite</span><span class="pun">(</span><span class="pln">power</span><span class="pun">)</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> isNaN</span><span class="pun">(</span><span class="pln">power</span><span class="pun">)</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> power </span><span class="pun">&lt;</span><span class="pln"> </span><span class="typ">MinPower</span><span class="pun">)</span><span class="pln">
        power </span><span class="pun">=</span><span class="pln"> </span><span class="typ">MinPower</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">var</span><span class="pln"> scale </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> power</span><span class="pun">;</span><span class="pln">

    </span><span class="com">// Calibrate to make perceived volume same as unprocessed.</span><span class="pln">
    scale </span><span class="pun">*=</span><span class="pln"> </span><span class="typ">GainCalibration</span><span class="pun">;</span><span class="pln">

    </span><span class="com">// Scale depends on sample-rate.</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">buffer</span><span class="pun">.</span><span class="pln">sampleRate</span><span class="pun">)</span><span class="pln">
        scale </span><span class="pun">*=</span><span class="pln"> </span><span class="typ">GainCalibrationSampleRate</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> buffer</span><span class="pun">.</span><span class="pln">sampleRate</span><span class="pun">;</span><span class="pln">

    </span><span class="com">// True-stereo compensation.</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">numberOfChannels </span><span class="pun">==</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln">
        scale </span><span class="pun">*=</span><span class="pln"> </span><span class="lit">0.5</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> scale</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
      </span></pre>
            <p>
              During processing, the ConvolverNode will then take this
              calculated <em>normalizationScale</em> value and multiply it by
              the result of the linear convolution resulting from processing
              the input with the impulse response (represented by the
              <em>buffer</em>) to produce the final output. Or any
              mathematically equivalent operation may be used, such as
              pre-multiplying the input by <em>normalizationScale</em>, or
              pre-multiplying a version of the impulse-response by
              <em>normalizationScale</em>.
            </p>
          </dd></dl></section>
        <section property="bibo:hasPart" resource="#Convolution-channel-configurations" typeof="bibo:Chapter">
          <h4 resource="#Convolution-channel-configurations" id="Convolution-channel-configurations"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.22.2 </span>
            Channel Configurations for Input, Impulse Response and Output
          </span></h4>
          <p>
            Implementations <em title="MUST" class="rfc2119">MUST</em> support the following allowable configurations
            of impulse response channels in a <a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a>
            to achieve various reverb effects with 1 or 2 channels of input.
          </p>
          <p>
            The first image in the diagram illustrates the general case, where
            the source has N input channels, the impulse response has K
            channels, and the playback system has M output channels. Because
            <a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a> is limited to 1 or 2 channels of
            input, not every case can be handled.
          </p>
          <p>
            Single channel convolution operates on a mono audio input, using a
            mono impulse response, and generating a mono output. The remaining
            images in the diagram illustrate the supported cases for mono and
            stereo playback where N and M are 1 or 2 and K is 1, 2, or 4.
            Developers desiring more complex and arbitrary matrixing can use a
            <a class="idlType" href="#idl-def-ChannelSplitterNode"><code>ChannelSplitterNode</code></a>, multiple single-channel
            <a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a>s and a
            <a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a>.
          </p>
          <figure id="fig-a-graphical-representation-of-supported-input-and-output-channel-count-possibilities-when-using-a-convolvernode.x">
            <img alt="reverb matrixing" src="images/reverb-matrixing.png">
            <figcaption>Fig. <span class="figno">5</span> <span class="fig-title">
              A graphical representation of supported input and output channel
              count possibilities when using a
              <a class="idlType" href="#idl-def-ConvolverNode"><code>ConvolverNode</code></a>.
            </span></figcaption>
          </figure>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#the-analysernode-interface" typeof="bibo:Chapter" id="the-analysernode-interface">
        <h3 resource="#h-the-analysernode-interface" id="h-the-analysernode-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.23 </span>
          The AnalyserNode Interface
        </span></h3>
        <p>
          This interface represents a node which is able to provide real-time
          frequency and time-domain analysis information. The audio stream will
          be passed un-processed from input to output.
        </p>
        <pre>    numberOfInputs  : 1
    numberOfOutputs : 1    <em>Note that this output may be left unconnected.</em>

    channelCount = 1;
    channelCountMode = "max";
    channelInterpretation = "speakers";
</pre>
        <pre class="idl"><span class="idlInterface" id="idl-def-AnalyserNode">interface <span class="idlInterfaceID">AnalyserNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-AnalyserNode-getFloatFrequencyData-void-Float32Array-array">getFloatFrequencyData</a></span> (<span class="idlParam"><span class="idlParamType">Float32Array</span> <span class="idlParamName">array</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-AnalyserNode-getByteFrequencyData-void-Uint8Array-array">getByteFrequencyData</a></span> (<span class="idlParam"><span class="idlParamType">Uint8Array</span> <span class="idlParamName">array</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-AnalyserNode-getFloatTimeDomainData-void-Float32Array-array">getFloatTimeDomainData</a></span> (<span class="idlParam"><span class="idlParamType">Float32Array</span> <span class="idlParamName">array</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-AnalyserNode-getByteTimeDomainData-void-Uint8Array-array">getByteTimeDomainData</a></span> (<span class="idlParam"><span class="idlParamType">Uint8Array</span> <span class="idlParamName">array</span></span>);</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">unsigned long</span> <span class="idlAttrName"><a href="#widl-AnalyserNode-fftSize">fftSize</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">unsigned long</span> <span class="idlAttrName"><a href="#widl-AnalyserNode-frequencyBinCount">frequencyBinCount</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">float</span>         <span class="idlAttrName"><a href="#widl-AnalyserNode-minDecibels">minDecibels</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">float</span>         <span class="idlAttrName"><a href="#widl-AnalyserNode-maxDecibels">maxDecibels</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">float</span>         <span class="idlAttrName"><a href="#widl-AnalyserNode-smoothingTimeConstant">smoothingTimeConstant</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-24" typeof="bibo:Chapter" id="attributes-24"><h4 resource="#h-attributes-24" id="h-attributes-24"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.23.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-AnalyserNode-fftSize"><code>fftSize</code> of type <span class="idlAttrType">unsigned long</span></dt><dd>
            The size of the FFT used for frequency-domain analysis. This must
            be a power of two in the range 32 to 32768, otherwise an
            IndexSizeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown. The default value is 2048.
            Note that large FFT sizes can be costly to compute.
          </dd><dt id="widl-AnalyserNode-frequencyBinCount"><code>frequencyBinCount</code> of type <span class="idlAttrType">unsigned long</span>, readonly       </dt><dd>
            Half the FFT size.
          </dd><dt id="widl-AnalyserNode-maxDecibels"><code>maxDecibels</code> of type <span class="idlAttrType">float</span></dt><dd>
            <dfn data-dfn-type="dfn" id="maxDecibels">maxDecibels</dfn> is the maximum power value
            in the scaling range for the FFT analysis data for conversion to
            unsigned byte values. The default value is -30. If the value of
            this attribute is set to a value less than or equal to
            <code><a data-link-type="dfn" class="internalDFN" href="#minDecibels">minDecibels</a></code>, an IndexSizeError exception <em title="MUST" class="rfc2119">MUST</em>
            be thrown.
          </dd><dt id="widl-AnalyserNode-minDecibels"><code>minDecibels</code> of type <span class="idlAttrType">float</span></dt><dd>
            <dfn data-dfn-type="dfn" id="minDecibels">minDecibels</dfn> is the minimum power value
            in the scaling range for the FFT analysis data for conversion to
            unsigned byte values. The default value is -100. If the value of
            this attribute is set to a value more than or equal to
            <code><a data-link-type="dfn" class="internalDFN" href="#maxDecibels">maxDecibels</a></code>, an IndexSizeError exception <em title="MUST" class="rfc2119">MUST</em>
            be thrown.
          </dd><dt id="widl-AnalyserNode-smoothingTimeConstant"><code>smoothingTimeConstant</code> of type <span class="idlAttrType">float</span></dt><dd>
            A value from 0 -&gt; 1 where 0 represents no time averaging with
            the last analysis frame. The default value is 0.8. If the value of
            this attribute is set to a value less than 0 or more than 1, an
            IndexSizeError exception <em title="MUST" class="rfc2119">MUST</em> be thrown.
          </dd></dl></section><section property="bibo:hasPart" resource="#methods-13" typeof="bibo:Chapter" id="methods-13"><h4 resource="#h-methods-13" id="h-methods-13"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.23.2 </span>Methods</span></h4><dl class="methods"><dt id="widl-AnalyserNode-getByteFrequencyData-void-Uint8Array-array"><code>getByteFrequencyData</code></dt><dd>
            <p>
              Copies the <a data-link-type="dfn" class="internalDFN" href="#current-frequency-data">current frequency data</a> into the passed unsigned
              byte array. If the array has fewer elements than the
              <code>frequencyBinCount</code>, the excess elements will
              be dropped. If the array has more elements than the
              <code>frequencyBinCount</code>, the excess elements will
              be ignored.
            </p>
            <p>
              The values stored in the unsigned byte array are computed in the
              following way. Let \(Y[k]\) be the <a data-link-type="dfn" class="internalDFN" href="#current-frequency-data">current frequency data</a>
              as described in <a href="#fft-windowing-and-smoothing-over-time">FFT windowing and
              smoothing</a>. Then the byte value, \(b[k]\), is
            </p>
            <pre>                  $$
                    b[k] = \frac{255}{\mbox{dB}_{max} - \mbox{dB}_{min}}
                     \left(Y[k] - \mbox{dB}_{min}\right)
                  $$

</pre>
            <p>
              where \(\mbox{dB}_{min}\) is <code><a data-link-type="dfn" class="internalDFN" href="#minDecibels">minDecibels</a></code> and
              \(\mbox{dB}_{max}\) is <code><a data-link-type="dfn" class="internalDFN" href="#maxDecibels">maxDecibels</a></code>. If
              \(b[k]\) lies outside the range of 0 to 255, \(b[k]\) is clipped
              to lie in that range.
            </p>

          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">array</td><td class="prmType"><code>Uint8Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                This parameter is where the frequency-domain analysis data will
                be copied.
              </td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-AnalyserNode-getByteTimeDomainData-void-Uint8Array-array"><code>getByteTimeDomainData</code></dt><dd>
            <p>
              Copies the current down-mixed time-domain (waveform) data into
              the passed unsigned byte array. If the array has fewer elements
              than the value of <code>fftSize</code>, the excess
              elements will be dropped. If the array has more elements than
              <code>fftSize</code>, the excess elements will be ignored.
            </p>
            <p>
              The values stored in the unsigned byte array are computed in the
              following way. Let \(x[k]\) be the time-domain data. Then the
              byte value, \(b[k]\), is
            </p>
            <pre>              $$
                b[k] = 128(1 + x[k]).
              $$

</pre>
            <p>
              If \(b[k]\) lies outside the range 0 to 255, \(b[k]\) is clipped
              to lie in that range.
            </p>

          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">array</td><td class="prmType"><code>Uint8Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                This parameter is where the time-domain sample data will be
                copied.
              </td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-AnalyserNode-getFloatFrequencyData-void-Float32Array-array"><code>getFloatFrequencyData</code></dt><dd>
            <p>
              Copies the <a data-link-type="dfn" class="internalDFN" href="#current-frequency-data">current frequency data</a> into the passed
              floating-point array. If the array has fewer elements than the
              <code>frequencyBinCount</code>, the excess elements will
              be dropped. If the array has more elements than the
              <code>frequencyBinCount</code>, the excess elements will
              be ignored.
            </p>
            <p>
              The frequency data are in dB units.
            </p>

          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">array</td><td class="prmType"><code>Float32Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                This parameter is where the frequency-domain analysis data will
                be copied.
              </td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-AnalyserNode-getFloatTimeDomainData-void-Float32Array-array"><code>getFloatTimeDomainData</code></dt><dd>
            <p>
              Copies the current down-mixed time-domain (waveform) data into
              the passed floating-point array. If the array has fewer elements
              than the value of <code>fftSize</code>, the excess
              elements will be dropped. If the array has more elements than
              <code>fftSize</code>, the excess elements will be ignored.
            </p>

          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">array</td><td class="prmType"><code>Float32Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                This parameter is where the time-domain sample data will be
                copied.
              </td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd></dl></section>
        <section property="bibo:hasPart" resource="#fft-windowing-and-smoothing-over-time" typeof="bibo:Chapter" id="fft-windowing-and-smoothing-over-time">
          <h4 resource="#h-fft-windowing-and-smoothing-over-time" id="h-fft-windowing-and-smoothing-over-time"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.23.3 </span>
            FFT Windowing and smoothing over time
          </span></h4>When the <dfn data-dfn-type="dfn" id="current-frequency-data">current frequency
          data</dfn> are computed, the following operations are to be
          performed:
          <ol>
            <li>Down-mix all channels of the time domain input data to mono.
            </li>
            <li>
              <a href="#blackman-window">Apply a Blackman window</a> to the
              time domain input data
            </li>
            <li>
              <a href="#fourier-transform">Apply a Fourier tranform</a> to the
              windowed time domain input data to get imaginary and real
              frequency data
            </li>
            <li>
              <a href="#smoothing-over-time">Smooth over time</a> the frequency
              domain data
            </li>
            <li>
              <a href="#conversion-to-db">Conversion to dB</a>.
            </li>
          </ol>
          <p>
            In the following, let \(N\) be the value of the
            <code>.fftSize</code> attribute of this <code>AnalyserNode</code>.
          </p>
          <p>
            <dfn data-dfn-type="dfn" id="blackman-window">Applying a Blackman window</dfn> consists
            in the following operation on the input time domain data. Let
            \(x[n]\) for \(n = 0, \ldots, N - 1\) be the time domain data. The
            Blackman window is defined by
          </p>
          <pre>          $$
          \begin{align*}
            \alpha &amp;= \mbox{0.16} \\ a_0 &amp;= \frac{1-\alpha}{2} \\
             a_1   &amp;= \frac{1}{2} \\
             a_2   &amp;= \frac{\alpha}{2} \\
             w[n] &amp;= a_0 - a_1 \cos\frac{2\pi n}{N} + a_2 \cos\frac{4\pi n}{N}, \mbox{ for } n = 0, \ldots, N - 1
           \end{align*}
           $$

</pre>
          <p>
            The windowed signal \(\hat{x}[n]\) is
          </p>
          <pre>            $$
              \hat{x}[n] = x[n] w[n], \mbox{ for } n = 0, \ldots, N - 1
            $$

</pre>
          <p>
            <dfn data-dfn-type="dfn" id="fourier-transform">Applying a Fourier tranform</dfn>
            consists of computing the Fourier transform in the following way.
            Let \(X[k]\) be the complex frequency domain data and
            \(\hat{x}[n]\) be the windowed time domain data computed above.
            Then
          </p>
          <pre>            $$
              X[k] = \sum_{n = 0}^{N - 1} \hat{x}[n] e^{\frac{-2\pi i k n}{N}}
            $$

</pre>
          <p>
            for \(k = 0, \dots, N/2-1\).
          </p>
          <p>
            <dfn data-dfn-type="dfn" id="smoothing-over-time">Smoothing over time</dfn> frequency
            data consists in the following operation:
          </p>
          <ul>
            <li>Let \(\hat{X}_{-1}[k]\) be the result of this operation on the
            <a data-link-type="dfn" class="internalDFN" href="#dfn-previous-block">previous block</a>. The <dfn id="dfn-previous-block" data-dfn-type="dfn">previous block</dfn> is defined as
            being the buffer computed by the previous <a href="#smoothing-over-time">smoothing over time</a> operation, or an
            array of \(N\) zeros if this is the first time we are <a href="#smoothing-over-time">smoothing over time</a>.
            </li>
            <li>Let \(\tau\) be the value of the <a href="#widl-AnalyserNode-smoothingTimeConstant"><code>smoothingTimeConstant</code></a>
            attribute for this <a class="idlType" href="#idl-def-AnalyserNode"><code>AnalyserNode</code></a>.
            </li>
            <li>Let \(X[k]\) be the result of <a href="#fourier-transform">applying a Fourier transform</a> of the
            current block.
            </li>
          </ul>
          <p>
            Then the smoothed value, \(\hat{X}[k]\), is computed by
          </p>
          <pre>            $$
              \hat{X}[k] = \tau\, \hat{X}_{-1}[k] + (1 - \tau)\, |X[k]|
            $$

</pre>
          <p>
            for \(k = 0, \ldots, N - 1\).
          </p>
          <p>
            <dfn data-dfn-type="dfn" id="conversion-to-db">Conversion to dB</dfn> consists of the
            following operation, where \(\hat{X}[k]\) is computed in <a href="#smoothing-over-time">smoothing over time</a>:
          </p>
          <pre>          $$
            Y[k] = 20\log_{10}\hat{X}[k]
          $$

</pre>
          <p>
            for \(k = 0, \ldots, N-1\).
          </p>
          <p>
            This array, \(Y[k]\), is copied to the output array for
            <code>getFloatFrequencyData</code>. For
            <code>getByteFrequencyData</code>, the \(Y[k]\) is clipped to lie
            between <code><a data-link-type="dfn" class="internalDFN" href="#minDecibels">minDecibels</a></code> and
            <code><a data-link-type="dfn" class="internalDFN" href="#maxDecibels">maxDecibels</a></code> and then scaled to fit in an
            unsigned byte such that <code><a data-link-type="dfn" class="internalDFN" href="#minDecibels">minDecibels</a></code> is
            represented by the value 0 and <code><a data-link-type="dfn" class="internalDFN" href="#maxDecibels">maxDecibels</a></code> is
            represented by the value 255.
          </p>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#the-channelsplitternode-interface" typeof="bibo:Chapter" id="the-channelsplitternode-interface">
        <h3 resource="#h-the-channelsplitternode-interface" id="h-the-channelsplitternode-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.24 </span>
          The ChannelSplitterNode Interface
        </span></h3>
        <p>
          The <code>ChannelSplitterNode</code> is for use in more advanced
          applications and would often be used in conjunction with
          <a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a>.
        </p>
        <pre>    numberOfInputs  : 1
    numberOfOutputs : Variable N (defaults to 6) // number of "active" (non-silent) outputs is determined by number of channels in the input

    channelCountMode = "max";
    channelInterpretation = "speakers";
</pre>
        <p>
          This interface represents an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> for
          accessing the individual channels of an audio stream in the routing
          graph. It has a single input, and a number of "active" outputs which
          equals the number of channels in the input audio stream. For example,
          if a stereo input is connected to an
          <a class="idlType" href="#idl-def-ChannelSplitterNode"><code>ChannelSplitterNode</code></a> then the number of active
          outputs will be two (one from the left channel and one from the
          right). There are always a total number of N outputs (determined by
          the <code>numberOfOutputs</code> parameter to the
          <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> method <a href="#widl-BaseAudioContext-createChannelSplitter-ChannelSplitterNode-unsigned-long-numberOfOutputs">
          <code>createChannelSplitter()</code></a>), The default number is 6 if
          this value is not provided. Any outputs which are not "active" will
          output silence and would typically not be connected to anything.
        </p>
        <h3 id="example-1">
          Example:
        </h3>
        <figure id="fig-a-diagram-of-a-channelsplitter">
          <img alt="channel splitter" src="images/channel-splitter.png">
          <figcaption>Fig. <span class="figno">6</span> <span class="fig-title">
            A diagram of a ChannelSplitter
          </span></figcaption>
        </figure>
        <p>
          Please note that in this example, the splitter does <b>not</b>
          interpret the channel identities (such as left, right, etc.), but
          simply splits out channels in the order that they are input.
        </p>
        <p>
          One application for <code>ChannelSplitterNode</code> is for doing
          "matrix mixing" where individual gain control of each channel is
          desired.
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-ChannelSplitterNode">interface <span class="idlInterfaceID">ChannelSplitterNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
};</span></pre>
      </section>
      <section property="bibo:hasPart" resource="#the-channelmergernode-interface" typeof="bibo:Chapter" id="the-channelmergernode-interface">
        <h3 resource="#h-the-channelmergernode-interface" id="h-the-channelmergernode-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.25 </span>
          The ChannelMergerNode Interface
        </span></h3>
        <p>
          The <a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a> is for use in more advanced
          applications and would often be used in conjunction with
          <a class="idlType" href="#idl-def-ChannelSplitterNode"><code>ChannelSplitterNode</code></a>.
        </p>
        <pre>  numberOfInputs  : Variable N (default to 6)
  numberOfOutputs : 1

  channelCount = 1;
  channelCountMode = "explicit";
  channelInterpretation = "speakers";
</pre>
        <p>
          This interface represents an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> for
          combining channels from multiple audio streams into a single audio
          stream. It has a variable number of inputs (defaulting to 6), but not
          all of them need be connected. There is a single output whose audio
          stream has a number of channels equal to the number of inputs.
        </p>
        <p>
          To merge multiple inputs into one stream, each input gets downmixed
          into one channel (mono) based on the specified mixing rule. An
          unconnected input still counts as <b>one silent channel</b> in the
          output. Changing input streams does <b>not</b> affect the order of
          output channels.
        </p>
        <p>
          For <a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a>, <code>channelCount</code>
          and <code>channelCountMode</code> properties cannot be changed.
          <code>InvalidState</code> error <em title="MUST" class="rfc2119">MUST</em> be thrown when they changed.
        </p>
        <h3 id="example-2">
          Example:
        </h3>
        <p>
          For example, if a default <a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a> has
          two connected stereo inputs, the first and second input will be
          downmixed to mono respectively before merging. The output will be a
          6-channel stream whose first two channels are be filled with the
          first two (downmixed) inputs and the rest of channels will be silent.
        </p>
        <p>
          Also the <a class="idlType" href="#idl-def-ChannelMergerNode"><code>ChannelMergerNode</code></a> can be used to arrange
          multiple audio streams in a certain order for the multi-channel
          speaker array such as 5.1 surround set up. The merger does not
          interpret the channel identities (such as left, right, etc.), but
          simply combines channels in the order that they are input.
        </p>
        <figure id="fig-a-diagram-of-channelmerger">
          <img alt="channel merger" src="images/channel-merger.png">
          <figcaption>Fig. <span class="figno">7</span> <span class="fig-title">
            A diagram of ChannelMerger
          </span></figcaption>
        </figure>
        <pre class="idl"><span class="idlInterface" id="idl-def-ChannelMergerNode">interface <span class="idlInterfaceID">ChannelMergerNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
};</span></pre>
      </section>
      <section property="bibo:hasPart" resource="#the-dynamicscompressornode-interface" typeof="bibo:Chapter" id="the-dynamicscompressornode-interface">
        <h3 resource="#h-the-dynamicscompressornode-interface" id="h-the-dynamicscompressornode-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.26 </span>
          The DynamicsCompressorNode Interface
        </span></h3>
        <p>
          <a class="idlType" href="#idl-def-DynamicsCompressorNode"><code>DynamicsCompressorNode</code></a> is an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> processor implementing a dynamics
          compression effect.
        </p>
        <p>
          Dynamics compression is very commonly used in musical production and
          game audio. It lowers the volume of the loudest parts of the signal
          and raises the volume of the softest parts. Overall, a louder,
          richer, and fuller sound can be achieved. It is especially important
          in games and musical applications where large numbers of individual
          sounds are played simultaneous to control the overall signal level
          and help avoid clipping (distorting) the audio output to the
          speakers.
        </p>
        <pre>    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCount = 2;
    channelCountMode = "explicit";
    channelInterpretation = "speakers";
</pre>
        <pre class="idl"><span class="idlInterface" id="idl-def-DynamicsCompressorNode">interface <span class="idlInterfaceID">DynamicsCompressorNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-DynamicsCompressorNode-threshold">threshold</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-DynamicsCompressorNode-knee">knee</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-DynamicsCompressorNode-ratio">ratio</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">float</span>      <span class="idlAttrName"><a href="#widl-DynamicsCompressorNode-reduction">reduction</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-DynamicsCompressorNode-attack">attack</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span> <span class="idlAttrName"><a href="#widl-DynamicsCompressorNode-release">release</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-25" typeof="bibo:Chapter" id="attributes-25"><h4 resource="#h-attributes-25" id="h-attributes-25"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.26.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-DynamicsCompressorNode-attack"><code>attack</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            The amount of time (in seconds) to reduce the gain by 10dB. Its
            default <code>value</code> is 0.003, with a nominal range of 0 to
            1.
          </dd><dt id="widl-DynamicsCompressorNode-knee"><code>knee</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            A decibel value representing the range above the threshold where
            the curve smoothly transitions to the "ratio" portion. Its default
            <code>value</code> is 30, with a nominal range of 0 to 40.
          </dd><dt id="widl-DynamicsCompressorNode-ratio"><code>ratio</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            The amount of dB change in input for a 1 dB change in output. Its
            default <code>value</code> is 12, with a nominal range of 1 to 20.
          </dd><dt id="widl-DynamicsCompressorNode-reduction"><code>reduction</code> of type <span class="idlAttrType">float</span>, readonly       </dt><dd>
            A read-only decibel value for metering purposes, representing the
            current amount of gain reduction that the compressor is applying to
            the signal. If fed no signal the value will be 0 (no gain
            reduction).
          </dd><dt id="widl-DynamicsCompressorNode-release"><code>release</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            The amount of time (in seconds) to increase the gain by 10dB. Its
            default <code>value</code> is 0.250, with a nominal range of 0 to
            1.
          </dd><dt id="widl-DynamicsCompressorNode-threshold"><code>threshold</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            The decibel value above which the compression will start taking
            effect. Its default <code>value</code> is -24, with a nominal range
            of -100 to 0.
          </dd></dl></section>
      </section>
      <section property="bibo:hasPart" resource="#the-biquadfilternode-interface" typeof="bibo:Chapter" id="the-biquadfilternode-interface">
        <h3 resource="#h-the-biquadfilternode-interface" id="h-the-biquadfilternode-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.27 </span>
          The BiquadFilterNode Interface
        </span></h3>
        <p>
          <a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a> is an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> processor implementing very common
          low-order filters.
        </p>
        <p>
          Low-order filters are the building blocks of basic tone controls
          (bass, mid, treble), graphic equalizers, and more advanced filters.
          Multiple <a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a> filters can be combined
          to form more complex filters. The filter parameters such as <a href="#widl-BiquadFilterNode-frequency"><code>frequency</code></a> can be
          changed over time for filter sweeps, etc. Each
          <a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a> can be configured as one of a
          number of common filter types as shown in the IDL below. The default
          filter type is <code>"lowpass"</code>.
        </p>
        <p>
          Both <a href="#widl-BiquadFilterNode-frequency"><code>frequency</code></a> and
          <a href="#widl-BiquadFilterNode-detune"><code>detune</code></a> are
          <a data-link-type="dfn" class="internalDFN" href="#a-rate">a-rate</a> parameters and are used together to determine a
          <dfn data-dfn-type="dfn" id="computedFreq-biquad">computedFrequency</dfn> value:
        </p>
        <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">  computedFrequency</span><span class="pun">(</span><span class="pln">t</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> frequency</span><span class="pun">(</span><span class="pln">t</span><span class="pun">)</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> pow</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> detune</span><span class="pun">(</span><span class="pln">t</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">1200</span><span class="pun">)</span></pre>
        <pre>    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCountMode = "max";
    channelInterpretation = "speakers";
</pre>
        <p>
          The number of channels of the output always equals the number of
          channels of the input.
        </p>
        <pre class="idl"><span class="idlEnum" id="idl-def-BiquadFilterType">enum <span class="idlEnumID">BiquadFilterType</span> {
    "<a href="#idl-def-BiquadFilterType.lowpass" class="idlEnumItem">lowpass</a>",
    "<a href="#idl-def-BiquadFilterType.highpass" class="idlEnumItem">highpass</a>",
    "<a href="#idl-def-BiquadFilterType.bandpass" class="idlEnumItem">bandpass</a>",
    "<a href="#idl-def-BiquadFilterType.lowshelf" class="idlEnumItem">lowshelf</a>",
    "<a href="#idl-def-BiquadFilterType.highshelf" class="idlEnumItem">highshelf</a>",
    "<a href="#idl-def-BiquadFilterType.peaking" class="idlEnumItem">peaking</a>",
    "<a href="#idl-def-BiquadFilterType.notch" class="idlEnumItem">notch</a>",
    "<a href="#idl-def-BiquadFilterType.allpass" class="idlEnumItem">allpass</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code id="idl-def-BiquadFilterType.lowpass">lowpass</code></td><td>
            <p>
              A <a href="https://en.wikipedia.org/wiki/Low-pass_filter">lowpass
              filter</a> allows frequencies below the cutoff frequency to pass
              through and attenuates frequencies above the cutoff. It
              implements a standard second-order resonant lowpass filter with
              12dB/octave rolloff.
            </p>
            <blockquote>
              <dl>
                <dt>
                  frequency
                </dt>
                <dd>
                  The cutoff frequency
                </dd>
                <dt>
                  Q
                </dt>
                <dd>
                  Controls how peaked the response will be at the cutoff
                  frequency. A large value makes the response more peaked.
                  Please note that for this filter type, this value is not a
                  traditional Q, but is a resonance value in decibels.
                </dd>
                <dt>
                  gain
                </dt>
                <dd>
                  Not used in this filter type
                </dd>
              </dl>
            </blockquote>
          </td></tr><tr><td><code id="idl-def-BiquadFilterType.highpass">highpass</code></td><td>
            <p>
              A <a href="https://en.wikipedia.org/wiki/High-pass_filter">highpass
              filter</a> is the opposite of a lowpass filter. Frequencies above
              the cutoff frequency are passed through, but frequencies below
              the cutoff are attenuated. It implements a standard second-order
              resonant highpass filter with 12dB/octave rolloff.
            </p>
            <blockquote>
              <dl>
                <dt>
                  frequency
                </dt>
                <dd>
                  The cutoff frequency below which the frequencies are
                  attenuated
                </dd>
                <dt>
                  Q
                </dt>
                <dd>
                  Controls how peaked the response will be at the cutoff
                  frequency. A large value makes the response more peaked.
                  Please note that for this filter type, this value is not a
                  traditional Q, but is a resonance value in decibels.
                </dd>
                <dt>
                  gain
                </dt>
                <dd>
                  Not used in this filter type
                </dd>
              </dl>
            </blockquote>
          </td></tr><tr><td><code id="idl-def-BiquadFilterType.bandpass">bandpass</code></td><td>
            <p>
              A <a href="https://en.wikipedia.org/wiki/Band-pass_filter">bandpass
              filter</a> allows a range of frequencies to pass through and
              attenuates the frequencies below and above this frequency range.
              It implements a second-order bandpass filter.
            </p>
            <blockquote>
              <dl>
                <dt>
                  frequency
                </dt>
                <dd>
                  The center of the frequency band
                </dd>
                <dt>
                  <a href="https://en.wikipedia.org/wiki/Q_factor">Q</a>
                </dt>
                <dd>
                  Controls the width of the band. The width becomes narrower as
                  the Q value increases.
                </dd>
                <dt>
                  gain
                </dt>
                <dd>
                  Not used in this filter type
                </dd>
              </dl>
            </blockquote>
          </td></tr><tr><td><code id="idl-def-BiquadFilterType.lowshelf">lowshelf</code></td><td>
            <p>
              The lowshelf filter allows all frequencies through, but adds a
              boost (or attenuation) to the lower frequencies. It implements a
              second-order lowshelf filter.
            </p>
            <blockquote>
              <dl>
                <dt>
                  frequency
                </dt>
                <dd>
                  The upper limit of the frequences where the boost (or
                  attenuation) is applied.
                </dd>
                <dt>
                  <a href="https://en.wikipedia.org/wiki/Q_factor">Q</a>
                </dt>
                <dd>
                  Not used in this filter type.
                </dd>
                <dt>
                  gain
                </dt>
                <dd>
                  The boost, in dB, to be applied. If the value is negative,
                  the frequencies are attenuated.
                </dd>
              </dl>
            </blockquote>
          </td></tr><tr><td><code id="idl-def-BiquadFilterType.highshelf">highshelf</code></td><td>
            <p>
              The highshelf filter is the opposite of the lowshelf filter and
              allows all frequencies through, but adds a boost to the higher
              frequencies. It implements a second-order highshelf filter
            </p>
            <blockquote>
              <dl>
                <dt>
                  frequency
                </dt>
                <dd>
                  The lower limit of the frequences where the boost (or
                  attenuation) is applied.
                </dd>
                <dt>
                  <a href="https://en.wikipedia.org/wiki/Q_factor">Q</a>
                </dt>
                <dd>
                  Not used in this filter type.
                </dd>
                <dt>
                  gain
                </dt>
                <dd>
                  The boost, in dB, to be applied. If the value is negative,
                  the frequencies are attenuated.
                </dd>
              </dl>
            </blockquote>
          </td></tr><tr><td><code id="idl-def-BiquadFilterType.peaking">peaking</code></td><td>
            <p>
              The peaking filter allows all frequencies through, but adds a
              boost (or attenuation) to a range of frequencies.
            </p>
            <blockquote>
              <dl>
                <dt>
                  frequency
                </dt>
                <dd>
                  The center frequency of where the boost is applied.
                </dd>
                <dt>
                  <a href="https://en.wikipedia.org/wiki/Q_factor">Q</a>
                </dt>
                <dd>
                  Controls the width of the band of frequencies that are
                  boosted. A large value implies a narrow width.
                </dd>
                <dt>
                  gain
                </dt>
                <dd>
                  The boost, in dB, to be applied. If the value is negative,
                  the frequencies are attenuated.
                </dd>
              </dl>
            </blockquote>
          </td></tr><tr><td><code id="idl-def-BiquadFilterType.notch">notch</code></td><td>
            <p>
              The notch filter (also known as a <a href="https://en.wikipedia.org/wiki/Band-stop_filter">band-stop or
              band-rejection filter</a>) is the opposite of a bandpass filter.
              It allows all frequencies through, except for a set of
              frequencies.
            </p>
            <blockquote>
              <dl>
                <dt>
                  frequency
                </dt>
                <dd>
                  The center frequency of where the notch is applied.
                </dd>
                <dt>
                  <a href="https://en.wikipedia.org/wiki/Q_factor">Q</a>
                </dt>
                <dd>
                  Controls the width of the band of frequencies that are
                  attenuated. A large value implies a narrow width.
                </dd>
                <dt>
                  gain
                </dt>
                <dd>
                  Not used in this filter type.
                </dd>
              </dl>
            </blockquote>
          </td></tr><tr><td><code id="idl-def-BiquadFilterType.allpass">allpass</code></td><td>
            <p>
              An <a href="https://en.wikipedia.org/wiki/All-pass_filter#Digital_Implementation">
              allpass filter</a> allows all frequencies through, but changes
              the phase relationship between the various frequencies. It
              implements a second-order allpass filter
            </p>
            <blockquote>
              <dl>
                <dt>
                  frequency
                </dt>
                <dd>
                  The frequency where the center of the phase transition
                  occurs. Viewed another way, this is the frequency with
                  maximal <a href="https://en.wikipedia.org/wiki/Group_delay">group delay</a>.
                </dd>
                <dt>
                  <a href="https://en.wikipedia.org/wiki/Q_factor">Q</a>
                </dt>
                <dd>
                  Controls how sharp the phase transition is at the center
                  frequency. A larger value implies a sharper transition and a
                  larger group delay.
                </dd>
                <dt>
                  gain
                </dt>
                <dd>
                  Not used in this filter type.
                </dd>
              </dl>
            </blockquote>
          </td></tr></tbody></table>
        <p>
          All attributes of the <a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a> are
          <a data-link-type="dfn" class="internalDFN" href="#a-rate">a-rate</a> <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>.
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-BiquadFilterNode">interface <span class="idlInterfaceID">BiquadFilterNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlAttribute">                    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-BiquadFilterType"><code>BiquadFilterType</code></a></span> <span class="idlAttrName"><a href="#widl-BiquadFilterNode-type">type</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>       <span class="idlAttrName"><a href="#widl-BiquadFilterNode-frequency">frequency</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>       <span class="idlAttrName"><a href="#widl-BiquadFilterNode-detune">detune</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>       <span class="idlAttrName"><a href="#widl-BiquadFilterNode-Q">Q</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>       <span class="idlAttrName"><a href="#widl-BiquadFilterNode-gain">gain</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-BiquadFilterNode-getFrequencyResponse-void-Float32Array-frequencyHz-Float32Array-magResponse-Float32Array-phaseResponse">getFrequencyResponse</a></span> (<span class="idlParam"><span class="idlParamType">Float32Array</span> <span class="idlParamName">frequencyHz</span></span>, <span class="idlParam"><span class="idlParamType">Float32Array</span> <span class="idlParamName">magResponse</span></span>, <span class="idlParam"><span class="idlParamType">Float32Array</span> <span class="idlParamName">phaseResponse</span></span>);</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-26" typeof="bibo:Chapter" id="attributes-26"><h4 resource="#h-attributes-26" id="h-attributes-26"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.27.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-BiquadFilterNode-Q"><code>Q</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            The <a href="https://en.wikipedia.org/wiki/Q_factor">Q</a> factor
            has a default value of 1, with a nominal range of 0.0001 to 1000.
          </dd><dt id="widl-BiquadFilterNode-detune"><code>detune</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            A detune value, in cents, for the frequency. Its default value is
            0.
          </dd><dt id="widl-BiquadFilterNode-frequency"><code>frequency</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            The frequency at which the <a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a>
            will operate, in Hz. Its default value is 350Hz, and its nominal
            range is from 10Hz to half the Nyquist frequency.
          </dd><dt id="widl-BiquadFilterNode-gain"><code>gain</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            The gain has a default value of 0, with a nominal range of -40 to
            40.
          </dd><dt id="widl-BiquadFilterNode-type"><code>type</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-BiquadFilterType"><code>BiquadFilterType</code></a></span></dt><dd>
            The type of this <a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a>. The exact
            meaning of the other parameters depend on the value of the
            <code>type</code> attribute.
          </dd></dl></section><section property="bibo:hasPart" resource="#methods-14" typeof="bibo:Chapter" id="methods-14"><h4 resource="#h-methods-14" id="h-methods-14"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.27.2 </span>Methods</span></h4><dl class="methods"><dt id="widl-BiquadFilterNode-getFrequencyResponse-void-Float32Array-frequencyHz-Float32Array-magResponse-Float32Array-phaseResponse"><code>getFrequencyResponse</code></dt><dd>
            <p>
              Given the current filter parameter settings, calculates the
              frequency response for the specified frequencies. The three
              parameters <em title="MUST" class="rfc2119">MUST</em> be <code>Float32Array</code>s of the same length,
              or an <code>InvalidAccessError</code> <em title="MUST" class="rfc2119">MUST</em> be thrown.
            </p>
            <p>
              The frequency response returned <em title="MUST" class="rfc2119">MUST</em> be computed with the
              <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> sampled for the current processing
              block.
            </p>

          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">frequencyHz</td><td class="prmType"><code>Float32Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                <p>
                  This parameter specifies an array of frequencies at which the
                  response values will be calculated.
                </p>
              </td></tr><tr><td class="prmName">magResponse</td><td class="prmType"><code>Float32Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                <p>
                  This parameter specifies an output array receiving the linear
                  magnitude response values.
                </p>
                <p>
                  If a value in the <code>frequencyHz</code> parameter is not
                  within [0; sampleRate/2], where <code>sampleRate</code> is
                  the value of the <a href="#widl-BaseAudioContext-sampleRate"><code>sampleRate</code></a>
                  property of the <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>, the corresponding value
                  at the same index of the <code>magResponse</code> array <em title="MUST" class="rfc2119">MUST</em>
                  be <code>NaN</code>.
                </p>
              </td></tr><tr><td class="prmName">phaseResponse</td><td class="prmType"><code>Float32Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                <p>
                  This parameter specifies an output array receiving the phase
                  response values in radians.
                </p>
                <p>
                  If a value in the <code>frequencyHz</code> parameter is not
                  within [0; sampleRate/2], where <code>sampleRate</code> is
                  the value of the <a href="#widl-BaseAudioContext-sampleRate"><code>sampleRate</code></a>
                  property of the <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>, the corresponding value
                  at the same index of the <code>phaseResponse</code> array
                  <em title="MUST" class="rfc2119">MUST</em> be <code>NaN</code>.
                </p>
              </td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd></dl></section>
        <section property="bibo:hasPart" resource="#filters-characteristics" typeof="bibo:Chapter" id="filters-characteristics">
          <h4 resource="#h-filters-characteristics" id="h-filters-characteristics"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.27.3 </span>
            Filters characteristics
          </span></h4>
          <p>
            There are multiple ways of implementing the type of filters
            available through the <a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a> each
            having very different characteristics. The formulas in this section
            describe the filters that a <a data-link-type="dfn" class="internalDFN" href="#dfn-conforming-implementation">conforming implementation</a> <em title="MUST" class="rfc2119">MUST</em>
            implement, as they determine the characteristics of the different
            filter types. They are inspired by formulas found in the <a href="http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt">Audio EQ
            Cookbook</a>.
          </p>
          <p>
            The transfer function for the filters implemented by the
            <a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a> is:
          </p>
          <pre>  $$
  H(z) = \frac{\frac{b_0}{a_0} + \frac{b_1}{a_0}z^{-1} + \frac{b_2}{a_0}z^{-2}}
              {1+\frac{a_1}{a_0}z^{-1}+\frac{a_2}{a_0}z^{-2}}
  $$

</pre>
          <p>
            The initial filter state is 0.
          </p>The coefficients in the transfer function above are different for
          each node type. The following intermediate variable are necessary for
          their computation, based on the <a data-link-type="dfn" class="internalDFN" href="#dfn-computedvalue">computedValue</a> of the
          <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>s of the
          <a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a>.
          <ul>
            <li>Let \(F_s\) be the value of the <a href="#widl-BaseAudioContext-sampleRate"><code>sampleRate</code></a>
            attribute for this <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>.
            </li>
            <li>Let \(f_0\) be the value of the
            <a data-link-type="dfn" class="internalDFN" href="#computedFreq-biquad"><code>computedFrequency</code></a>.
            </li>
            <li>Let \(G\) be the value of the <a href="#widl-BiquadFilterNode-gain"><code>gain</code></a>
            <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>.
            </li>
            <li>Let \(Q\) be the value of the <a href="#widl-BiquadFilterNode-Q"><code>Q</code></a>
            <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>.
            </li>
            <li>Finally let
            <!-- Should \alpha_S be simplified since S is always 1?-->
              <pre>$$
\begin{align*}
  A        &amp;= 10^{\frac{G}{40}} \\
  \omega_0 &amp;= 2\pi\frac{f_0}{F_s} \\
  \alpha_Q &amp;= \frac{\sin\omega_0}{2Q} \\
  \alpha_B &amp;= \frac{\sin\omega_0}{2} \sqrt{\frac{4-\sqrt{16-\frac{16}{G^2}}}{2}} \\
  S        &amp;= 1 \\
  \alpha_S &amp;= \frac{\sin\omega_0}{2}\sqrt{\left(A+\frac{1}{A}\right)\left(\frac{1}{S}-1\right)+2}
\end{align*}
$$

</pre>
            </li>
          </ul>The six coefficients (\(b_0, b_1, b_2, a_0, a_1, a_2\)) for each
          filter type, are:
          <dl>
            <dt>
              <code>lowpass</code>
            </dt>
            <dd>
              <pre>                $$
                  \begin{align*}
                    b_0 &amp;= \frac{1 - \cos\omega_0}{2} \\
                    b_1 &amp;= 1 - \cos\omega_0 \\
                    b_2 &amp;= \frac{1 - \cos\omega_0}{2} \\
                    a_0 &amp;= 1 + \alpha_B \\
                    a_1 &amp;= -2 \cos\omega_0 \\
                    a_2 &amp;= 1 - \alpha_B
                  \end{align*}
                $$

</pre>
            </dd>
            <dt>
              <code>highpass</code>
            </dt>
            <dd>
              <pre>                  $$
                    \begin{align*}
                      b_0 &amp;= \frac{1 + \cos\omega_0}{2} \\
                      b_1 &amp;= -(1 + \cos\omega_0) \\
                      b_2 &amp;= \frac{1 + \cos\omega_0}{2} \\
                      a_0 &amp;= 1 + \alpha_B \\
                      a_1 &amp;= -2 \cos\omega_0 \\
                      a_2 &amp;= 1 - \alpha_B
                    \end{align*}
                  $$

</pre>
            </dd>
            <dt>
              <code>bandpass</code>
            </dt>
            <dd>
              <pre>              $$
                \begin{align*}
                  b_0 &amp;= \alpha_Q \\
                  b_1 &amp;= 0 \\
                  b_2 &amp;= -\alpha_Q \\
                  a_0 &amp;= 1 + \alpha_Q \\
                  a_1 &amp;= -2 \cos\omega_0 \\
                  a_2 &amp;= 1 - \alpha_Q
                \end{align*}
              $$

</pre>
            </dd>
            <dt>
              <code>notch</code>
            </dt>
            <dd>
              <pre>                $$
                  \begin{align*}
                    b_0 &amp;= 1 \\
                    b_1 &amp;= -2\cos\omega_0 \\
                    b_2 &amp;= 1 \\
                    a_0 &amp;= 1 + \alpha_Q \\
                    a_1 &amp;= -2 \cos\omega_0 \\
                    a_2 &amp;= 1 - \alpha_Q
                  \end{align*}
                $$

</pre>
            </dd>
            <dt>
              <code>allpass</code>
            </dt>
            <dd>
              <pre>                $$
                  \begin{align*}
                    b_0 &amp;= 1 - \alpha_Q \\
                    b_1 &amp;= -2\cos\omega_0 \\
                    b_2 &amp;= 1 + \alpha_Q \\
                    a_0 &amp;= 1 + \alpha_Q \\
                    a_1 &amp;= -2 \cos\omega_0 \\
                    a_2 &amp;= 1 - \alpha_Q
                  \end{align*}
                $$

</pre>
            </dd>
            <dt>
              <code>peaking</code>
            </dt>
            <dd>
              <pre>                $$
                  \begin{align*}
                    b_0 &amp;= 1 + \alpha_Q\, A \\
                    b_1 &amp;= -2\cos\omega_0 \\
                    b_2 &amp;= 1 - \alpha_Q\,A \\
                    a_0 &amp;= 1 + \frac{\alpha_Q}{A} \\
                    a_1 &amp;= -2 \cos\omega_0 \\
                    a_2 &amp;= 1 - \frac{\alpha_Q}{A}
                  \end{align*}
                $$

</pre>
            </dd>
            <dt>
              <code>lowshelf</code>
            </dt>
            <dd>
              <pre>                $$
                  \begin{align*}
                    b_0 &amp;= A \left[ (A+1) - (A-1) \cos\omega_0 + 2 \alpha_S \sqrt{A})\right] \\
                    b_1 &amp;= 2 A \left[ (A-1) - (A+1) \cos\omega_0 )\right] \\
                    b_2 &amp;= A \left[ (A+1) - (A-1) \cos\omega_0 - 2 \alpha_S \sqrt{A}) \right] \\
                    a_0 &amp;= (A+1) + (A-1) \cos\omega_0 + 2 \alpha_S \sqrt{A} \\
                    a_1 &amp;= -2 \left[ (A-1) + (A+1) \cos\omega_0\right] \\
                    a_2 &amp;= (A+1) + (A-1) \cos\omega_0 - 2 \alpha_S \sqrt{A})
                  \end{align*}
                $$

</pre>
            </dd>
            <dt>
              <code>highshelf</code>
            </dt>
            <dd>
              <pre>                $$
                  \begin{align*}
                    b_0 &amp;= A\left[ (A+1) + (A-1)\cos\omega_0 + 2\alpha_S\sqrt{A} )\right] \\
                    b_1 &amp;= -2A\left[ (A-1) + (A+1)\cos\omega_0 )\right] \\
                    b_2 &amp;= A\left[ (A+1) + (A-1)\cos\omega_0 - 2\alpha_S\sqrt{A} )\right] \\
                    a_0 &amp;= (A+1) - (A-1)\cos\omega_0 + 2\alpha_S\sqrt{A} \\
                    a_1 &amp;= 2\left[ (A-1) - (A+1)\cos\omega_0\right] \\
                    a_2 &amp;= (A+1) - (A-1)\cos\omega_0 - 2\alpha_S\sqrt{A}
                  \end{align*}
                $$

</pre>
            </dd>
          </dl>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#the-iirfilternode-interface" typeof="bibo:Chapter" id="the-iirfilternode-interface">
        <h3 resource="#h-the-iirfilternode-interface" id="h-the-iirfilternode-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.28 </span>
          The IIRFilterNode Interface
        </span></h3>
        <p>
          <a class="idlType" href="#idl-def-IIRFilterNode"><code>IIRFilterNode</code></a> is an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>
          processor implementing a general IIR Filter. In general, it is best
          to use <a class="idlType" href="#idl-def-BiquadFilterNode"><code>BiquadFilterNode</code></a>'s to implement
          higher-order filters for the following reasons:
        </p>
        <ul>
          <li>Generally less sensitive to numeric issues
          </li>
          <li>Filter parameters can be automated
          </li>
          <li>Can be used to create all even-ordered IIR filters
          </li>
        </ul>
        <p>
          However, odd-ordered filters cannot be created, so if such filters
          are needed or automation is not needed, then IIR filters may be
          appropriate.
        </p>
        <p>
          Once created, the coefficients of the IIR filter cannot be changed.
        </p>
        <pre>    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCountMode = "max";
    channelInterpretation = "speakers";
</pre>
        <p>
          The number of channels of the output always equals the number of
          channels of the input.
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-IIRFilterNode">interface <span class="idlInterfaceID">IIRFilterNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-IIRFilterNode-getFrequencyResponse-void-Float32Array-frequencyHz-Float32Array-magResponse-Float32Array-phaseResponse">getFrequencyResponse</a></span> (<span class="idlParam"><span class="idlParamType">Float32Array</span> <span class="idlParamName">frequencyHz</span></span>, <span class="idlParam"><span class="idlParamType">Float32Array</span> <span class="idlParamName">magResponse</span></span>, <span class="idlParam"><span class="idlParamType">Float32Array</span> <span class="idlParamName">phaseResponse</span></span>);</span>
};</span></pre><section property="bibo:hasPart" resource="#methods-15" typeof="bibo:Chapter" id="methods-15"><h4 resource="#h-methods-15" id="h-methods-15"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.28.1 </span>Methods</span></h4><dl class="methods"><dt id="widl-IIRFilterNode-getFrequencyResponse-void-Float32Array-frequencyHz-Float32Array-magResponse-Float32Array-phaseResponse"><code>getFrequencyResponse</code></dt><dd>
            <p>
              Given the current filter parameter settings, calculates the
              frequency response for the specified frequencies.
            </p>

          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">frequencyHz</td><td class="prmType"><code>Float32Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                This parameter specifies an array of frequencies at which the
                response values will be calculated.
              </td></tr><tr><td class="prmName">magResponse</td><td class="prmType"><code>Float32Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                This parameter specifies an output array receiving the linear
                magnitude response values. If this array is shorter than
                <code>frequencyHz</code> a NotSupportedError <em title="MUST" class="rfc2119">MUST</em> be signaled.
              </td></tr><tr><td class="prmName">phaseResponse</td><td class="prmType"><code>Float32Array</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc">
                This parameter specifies an output array receiving the phase
                response values in radians. If this array is shorter than
                <code>frequencyHz</code> a NotSupportedError <em title="MUST" class="rfc2119">MUST</em> be signaled.
              </td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd></dl></section>
        <section property="bibo:hasPart" resource="#filter-definition" typeof="bibo:Chapter" id="filter-definition">
          <h4 resource="#h-filter-definition" id="h-filter-definition"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.28.2 </span>
            Filter Definition
          </span></h4>
          <p>
            Let \(b_m\) be the <code>feedforward</code> coefficients and
            \(a_n\) be the <code>feedback</code> coefficients specified by
            <!--a href=
            "#widl-BaseAudioContext-createIIRFilter-IIRFilterNode-Float32Array-feedforward-Float32Array-feedback"-->
            <code>createIIRFilter</code>. Then the transfer function of the
            general IIR filter is given by
          </p>
          <pre>            $$
              H(z) = \frac{\sum_{m=0}^{M} b_m z^{-m}}{\sum_{n=0}^{N} a_n z^{-n}}
            $$

</pre>
          <p>
            where \(M + 1\) is the length of the \(b\) array and \(N + 1\) is
            the length of the \(a\) array. The coefficient \(a_0\) cannot be 0.
            At least one of \(b_m\) must be non-zero.
          </p>
          <p>
            Equivalently, the time-domain equation is:
          </p>
          <pre>            $$
              \sum_{k=0}^{N} a_k y(n-k) = \sum_{k=0}^{M} b_k x(n-k)
            $$

</pre>
          <p>
            The initial filter state is the all-zeroes state.
          </p>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#WaveShaperNode" typeof="bibo:Chapter">
        <h3 resource="#WaveShaperNode" id="WaveShaperNode"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.29 </span>
          The WaveShaperNode Interface
        </span></h3>
        <p>
          <a class="idlType" href="#idl-def-WaveShaperNode"><code>WaveShaperNode</code></a> is an
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> processor implementing non-linear
          distortion effects.
        </p>
        <p>
          Non-linear waveshaping distortion is commonly used for both subtle
          non-linear warming, or more obvious distortion effects. Arbitrary
          non-linear shaping curves may be specified.
        </p>
        <pre>    numberOfInputs  : 1
    numberOfOutputs : 1

    channelCountMode = "max";
    channelInterpretation = "speakers";
</pre>
        <p>
          The number of channels of the output always equals the number of
          channels of the input.
        </p>
        <table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code id="idl-def-OverSampleType.none">none</code></td><td>
            Don't oversample
          </td></tr><tr><td><code id="idl-def-OverSampleType.x2x">2x</code></td><td>
            Oversample two times
          </td></tr><tr><td><code id="idl-def-OverSampleType.x4x">4x</code></td><td>
            Oversample four times
          </td></tr></tbody></table>
        <pre class="idl"><span class="idlInterface" id="idl-def-WaveShaperNode"><span class="idlEnum" id="idl-def-OverSampleType">enum <span class="idlEnumID">OverSampleType</span> {
    "<a href="#idl-def-OverSampleType.none" class="idlEnumItem">none</a>",
    "<a href="#idl-def-OverSampleType.x2x" class="idlEnumItem">2x</a>",
    "<a href="#idl-def-OverSampleType.x4x" class="idlEnumItem">4x</a>"
};</span><br><br>interface <span class="idlInterfaceID">WaveShaperNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlAttribute">                    attribute <span class="idlAttrType">Float32Array?</span>  <span class="idlAttrName"><a href="#widl-WaveShaperNode-curve">curve</a></span>;</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-OverSampleType"><code>OverSampleType</code></a></span> <span class="idlAttrName"><a href="#widl-WaveShaperNode-oversample">oversample</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-27" typeof="bibo:Chapter" id="attributes-27"><h4 resource="#h-attributes-27" id="h-attributes-27"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.29.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-WaveShaperNode-curve"><code>curve</code> of type <span class="idlAttrType">Float32Array</span>, nullable</dt><dd>
            <p>
              The shaping curve used for the waveshaping effect. The input
              signal is nominally within the range [-1; 1]. Each input sample
              within this range will index into the shaping curve, with a
              signal level of zero corresponding to the center value of the
              curve array if there are an odd number of entries, or
              interpolated between the two centermost values if there are an
              even number of entries in the array. Any sample value less than
              -1 will correspond to the first value in the curve array. Any
              sample value greater than +1 will correspond to the last value in
              the curve array.
            </p>
            <p>
              The implementation must perform linear interpolation between
              adjacent points in the curve. Initially the curve attribute is
              null, which means that the WaveShaperNode will pass its input to
              its output without modification.
            </p>
            <p>
              Values of the curve are spread with equal spacing in the [-1; 1]
              range. This means that a <code>curve</code> with a even
              number of value will not have a value for a signal at zero, and a
              <code>curve</code> with an odd number of value will have a
              value for a signal at zero.
            </p>
            <p>
              A <code>InvalidStateError</code> <em title="MUST" class="rfc2119">MUST</em> be thrown if this attribute
              is set with a <code>Float32Array</code> that has a
              <code>length</code> less than 2.
            </p>
            <p>
              When this attribute is set, an internal copy of the curve is
              created by the <a class="idlType" href="#idl-def-WaveShaperNode"><code>WaveShaperNode</code></a>. Subsequent
              modifications of the contents of the array used to set the
              attribute therefore have no effect: the attribute must be set
              again in order to change the curve.
            </p>
          </dd><dt id="widl-WaveShaperNode-oversample"><code>oversample</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-OverSampleType"><code>OverSampleType</code></a></span></dt><dd>
            <p>
              Specifies what type of oversampling (if any) should be used when
              applying the shaping curve. The default value is "none", meaning
              the curve will be applied directly to the input samples. A value
              of "2x" or "4x" can improve the quality of the processing by
              avoiding some aliasing, with the "4x" value yielding the highest
              quality. For some applications, it's better to use no
              oversampling in order to get a very precise shaping curve.
            </p>
            <p>
              A value of "2x" or "4x" means that the following steps must be
              performed:
            </p>
            <ol>
              <li>Up-sample the input samples to 2x or 4x the sample-rate of
              the <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>. Thus for each processing
              block of 128 samples, generate 256 (for 2x) or 512 (for 4x)
              samples.
              </li>
              <li>Apply the shaping curve.
              </li>
              <li>Down-sample the result back to the sample-rate of the
              <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>. Thus taking the 256 (or 512)
              processed samples, generating 128 as the final result.
              </li>
            </ol>
            <p>
              The exact up-sampling and down-sampling filters are not
              specified, and can be tuned for sound quality (low aliasing,
              etc.), low latency, and performance.
            </p>
          </dd></dl></section>
      </section>
      <section property="bibo:hasPart" resource="#the-oscillatornode-interface" typeof="bibo:Chapter" id="the-oscillatornode-interface">
        <h3 resource="#h-the-oscillatornode-interface" id="h-the-oscillatornode-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.30 </span>
          The OscillatorNode Interface
        </span></h3>
        <p>
          <a class="idlType" href="#idl-def-OscillatorNode"><code>OscillatorNode</code></a> represents an audio source
          generating a periodic waveform. It can be set to a few commonly used
          waveforms. Additionally, it can be set to an arbitrary periodic
          waveform through the use of a <a class="idlType" href="#idl-def-PeriodicWave"><code>PeriodicWave</code></a>
          object.
        </p>
        <p>
          Oscillators are common foundational building blocks in audio
          synthesis. An OscillatorNode will start emitting sound at the time
          specified by the <code>start()</code> method.
        </p>
        <p>
          Mathematically speaking, a <em>continuous-time</em> periodic waveform
          can have very high (or infinitely high) frequency information when
          considered in the frequency domain. When this waveform is sampled as
          a discrete-time digital audio signal at a particular sample-rate,
          then care must be taken to discard (filter out) the high-frequency
          information higher than the <em>Nyquist</em> frequency (half the
          sample-rate) before converting the waveform to a digital form. If
          this is not done, then <em>aliasing</em> of higher frequencies (than
          the Nyquist frequency) will fold back as mirror images into
          frequencies lower than the Nyquist frequency. In many cases this will
          cause audibly objectionable artifacts. This is a basic and well
          understood principle of audio DSP.
        </p>
        <p>
          There are several practical approaches that an implementation may
          take to avoid this aliasing. Regardless of approach, the
          <em>idealized</em> discrete-time digital audio signal is well defined
          mathematically. The trade-off for the implementation is a matter of
          implementation cost (in terms of CPU usage) versus fidelity to
          achieving this ideal.
        </p>
        <p>
          It is expected that an implementation will take some care in
          achieving this ideal, but it is reasonable to consider lower-quality,
          less-costly approaches on lower-end hardware.
        </p>
        <p>
          Both .frequency and .detune are <a data-link-type="dfn" class="internalDFN" href="#a-rate">a-rate</a> parameters and are used
          together to determine a <em>computedFrequency</em> value:
        </p>
        <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">  computedFrequency</span><span class="pun">(</span><span class="pln">t</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> frequency</span><span class="pun">(</span><span class="pln">t</span><span class="pun">)</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> pow</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> detune</span><span class="pun">(</span><span class="pln">t</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">1200</span><span class="pun">)</span></pre>
        <p>
          The OscillatorNode's instantaneous phase at each time is the time
          integral of <em>computedFrequency</em>.
        </p>
        <pre>  numberOfInputs  : 0
  numberOfOutputs : 1 (mono output)
</pre>
        <pre class="idl"><span class="idlEnum" id="idl-def-OscillatorType">enum <span class="idlEnumID">OscillatorType</span> {
    "<a href="#idl-def-OscillatorType.sine" class="idlEnumItem">sine</a>",
    "<a href="#idl-def-OscillatorType.square" class="idlEnumItem">square</a>",
    "<a href="#idl-def-OscillatorType.sawtooth" class="idlEnumItem">sawtooth</a>",
    "<a href="#idl-def-OscillatorType.triangle" class="idlEnumItem">triangle</a>",
    "<a href="#idl-def-OscillatorType.custom" class="idlEnumItem">custom</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code id="idl-def-OscillatorType.sine">sine</code></td><td>
            A sine wave
          </td></tr><tr><td><code id="idl-def-OscillatorType.square">square</code></td><td>
            A square wave of duty period 0.5
          </td></tr><tr><td><code id="idl-def-OscillatorType.sawtooth">sawtooth</code></td><td>
            A sawtooth wave
          </td></tr><tr><td><code id="idl-def-OscillatorType.triangle">triangle</code></td><td>
            A triangle wave
          </td></tr><tr><td><code id="idl-def-OscillatorType.custom">custom</code></td><td>
            A custom periodic wave
          </td></tr></tbody></table>
        <pre class="idl"><span class="idlInterface" id="idl-def-OscillatorNode">interface <span class="idlInterfaceID">OscillatorNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlAttribute">                    attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-OscillatorType"><code>OscillatorType</code></a></span> <span class="idlAttrName"><a href="#widl-OscillatorNode-type">type</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>     <span class="idlAttrName"><a href="#widl-OscillatorNode-frequency">frequency</a></span>;</span>
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>     <span class="idlAttrName"><a href="#widl-OscillatorNode-detune">detune</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-OscillatorNode-start-void-double-when">start</a></span> (<span class="idlParam">optional <span class="idlParamType">double</span> <span class="idlParamName">when</span> = <span class="idlDefaultValue">0</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-OscillatorNode-stop-void-double-when">stop</a></span> (<span class="idlParam">optional <span class="idlParamType">double</span> <span class="idlParamName">when</span> = <span class="idlDefaultValue">0</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType">void</span> <span class="idlMethName"><a href="#widl-OscillatorNode-setPeriodicWave-void-PeriodicWave-periodicWave">setPeriodicWave</a></span> (<span class="idlParam"><span class="idlParamType"><a class="idlType" href="#idl-def-PeriodicWave"><code>PeriodicWave</code></a></span> <span class="idlParamName">periodicWave</span></span>);</span>
<span class="idlAttribute">                    attribute <span class="idlAttrType">EventHandler</span>   <span class="idlAttrName"><a href="#widl-OscillatorNode-onended">onended</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-28" typeof="bibo:Chapter" id="attributes-28"><h4 resource="#h-attributes-28" id="h-attributes-28"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.30.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-OscillatorNode-detune"><code>detune</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            A detuning value (in Cents) which will offset the
            <code>frequency</code> by the given amount. Its default
            <code>value</code> is 0. This parameter is <a data-link-type="dfn" class="internalDFN" href="#a-rate">a-rate</a>.
          </dd><dt id="widl-OscillatorNode-frequency"><code>frequency</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a></span>, readonly       </dt><dd>
            The frequency (in Hertz) of the periodic waveform. Its default
            <code>value</code> is 440. This parameter is <a data-link-type="dfn" class="internalDFN" href="#a-rate">a-rate</a>.
          </dd><dt id="widl-OscillatorNode-onended"><code>onended</code> of type <span class="idlAttrType">EventHandler</span></dt><dd>
            A property used to set the <code>EventHandler</code> (described in
            <cite><a href="https://html.spec.whatwg.org/multipage/webappapis.html#eventhandler">
            HTML</a></cite>[<cite><a href="#bib-HTML" class="bibref">HTML</a></cite>]) for the ended event that is dispatched to
            <a class="idlType" href="#idl-def-OscillatorNode"><code>OscillatorNode</code></a> node types. When the
            <a class="idlType" href="#idl-def-OscillatorNode"><code>OscillatorNode</code></a> has finished playing (i.e. its
            stop time has been reached), an event of type <code>Event</code>
            (described in <cite><a href="https://html.spec.whatwg.org/multipage/infrastructure.html#event">HTML</a></cite>[<cite><a href="#bib-HTML" class="bibref">HTML</a></cite>])
            will be dispatched to the event handler.
          </dd><dt id="widl-OscillatorNode-type"><code>type</code> of type <span class="idlAttrType"><a class="idlType" href="#idl-def-OscillatorType"><code>OscillatorType</code></a></span></dt><dd>
            The shape of the periodic waveform. It may directly be set to any
            of the type constant values except for "custom". Doing so <em title="MUST" class="rfc2119">MUST</em>
            throw an InvalidStateError exception. The <a href="#widl-OscillatorNode-setPeriodicWave-void-PeriodicWave-periodicWave">
            <code>setPeriodicWave()</code></a> method can be used to set a
            custom waveform, which results in this attribute being set to
            "custom". The default value is "sine". When this attribute is set,
            the phase of the oscillator <em title="MUST" class="rfc2119">MUST</em> be conserved.
          </dd></dl></section><section property="bibo:hasPart" resource="#methods-16" typeof="bibo:Chapter" id="methods-16"><h4 resource="#h-methods-16" id="h-methods-16"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.30.2 </span>Methods</span></h4><dl class="methods"><dt id="widl-OscillatorNode-setPeriodicWave-void-PeriodicWave-periodicWave"><code>setPeriodicWave</code></dt><dd>
            Sets an arbitrary custom periodic waveform given a
            <a class="idlType" href="#idl-def-PeriodicWave"><code>PeriodicWave</code></a>.
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">periodicWave</td><td class="prmType"><code><a class="idlType" href="#idl-def-PeriodicWave"><code>PeriodicWave</code></a></code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptFalse"><span role="img" aria-label="False">✘</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-OscillatorNode-start-void-double-when"><code>start</code></dt><dd>
            Defined the same as the <code>when</code> parameter of the
            <a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a>
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">when</td><td class="prmType"><code>double = 0</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd><dt id="widl-OscillatorNode-stop-void-double-when"><code>stop</code></dt><dd>
            Defined as in <a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a>.
          <table class="parameters"><tbody><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">when</td><td class="prmType"><code>double = 0</code></td><td class="prmNullFalse"><span role="img" aria-label="False">✘</span></td><td class="prmOptTrue"><span role="img" aria-label="True">✔</span></td><td class="prmDesc"></td></tr></tbody></table><div><em>Return type: </em><code>void</code></div></dd></dl></section>
        <section property="bibo:hasPart" resource="#basic-waveform-phase" typeof="bibo:Chapter" id="basic-waveform-phase">
          <h4 resource="#h-basic-waveform-phase" id="h-basic-waveform-phase"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.30.3 </span>
            Basic Waveform Phase
          </span></h4>
          <p>
            The idealized mathematical waveforms for the various oscillator
            types are defined here. In summary, all waveforms are defined
            mathematically to be an odd function with a positive slope at time
            0. The actual waveforms produced by the oscillator may differ to
            prevent aliasing affects.
          </p>
          <dl>
            <dt>
              "sine"
            </dt>
            <dd>
              The waveform for sine oscillator is:
              <pre>                $$
                  x(t) = \sin t
                $$.

</pre>
            </dd>
            <dt>
              "square"
            </dt>
            <dd>
              The waveform for the square wave oscillator is:
              <pre>                $$
                  x(t) = \begin{cases}
                         1 &amp; \mbox{for } 0≤ t &lt; \pi \\
                         -1 &amp; \mbox{for } -\pi &lt; t &lt; 0.
                         \end{cases}
                $$

</pre>
            </dd>
            <dt>
              "sawtooth"
            </dt>
            <dd>
              The waveform for the sawtooth oscillator is the ramp:
              <pre>                $$
                  x(t) = \frac{t}{\pi} \mbox{ for } -\pi &lt; t ≤ \pi;
                $$

</pre>
            </dd>
            <dt>
              "triangle"
            </dt>
            <dd>
              The waveform for the triangle oscillator is:
              <pre>                $$
                  x(t) = \begin{cases}
                           \frac{2}{\pi} t &amp; \mbox{for } 0 ≤ t ≤ \frac{\pi}{2} \\
                           1-\frac{2}{\pi} (t-\frac{\pi}{2}) &amp; \mbox{for }
                           \frac{\pi}{2} &lt; t ≤ \pi.
                         \end{cases}
                $$

</pre>This is extended to all \(t\) by using the fact that the waveform is an
odd function with period \(2\pi\).
            </dd>
          </dl>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#the-periodicwave-interface" typeof="bibo:Chapter" id="the-periodicwave-interface">
        <h3 resource="#h-the-periodicwave-interface" id="h-the-periodicwave-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.31 </span>
          The PeriodicWave Interface
        </span></h3>
        <p>
          PeriodicWave represents an arbitrary periodic waveform to be used
          with an <a class="idlType" href="#idl-def-OscillatorNode"><code>OscillatorNode</code></a>. Please see <!--a href=
          "#widl-BaseAudioContext-createPeriodicWave-PeriodicWave-Float32Array-real-Float32Array-imag"-->
          createPeriodicWave() and <a href="#widl-OscillatorNode-setPeriodicWave-void-PeriodicWave-periodicWave">
          setPeriodicWave()</a> and for more details.
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-PeriodicWave">interface <span class="idlInterfaceID">PeriodicWave</span> {
};</span></pre>
        <section property="bibo:hasPart" resource="#periodicwaveconstraints" typeof="bibo:Chapter" id="periodicwaveconstraints">
          <h4 resource="#h-periodicwaveconstraints" id="h-periodicwaveconstraints"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.31.1 </span>
            PeriodicWaveConstraints
          </span></h4>The <code>PeriodicWaveConstraints</code> dictionary is used to
          specify how the waveform is normalized.
          <pre class="idl"><span class="idlDictionary" id="idl-def-PeriodicWaveConstraints">dictionary <span class="idlDictionaryID">PeriodicWaveConstraints</span> {
<span class="idlMember">             <span class="idlMemberType">boolean</span> <span class="idlMemberName"><a href="#widl-PeriodicWaveConstraints-disableNormalization">disableNormalization</a></span> = <span class="idlMemberValue">false</span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#dictionary-periodicwaveconstraints-members" typeof="bibo:Chapter" id="dictionary-periodicwaveconstraints-members"><h5 resource="#h-dictionary-periodicwaveconstraints-members" id="h-dictionary-periodicwaveconstraints-members"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.31.1.1 </span>Dictionary <a href="#idl-def-PeriodicWaveConstraints" class="idlType"><code>PeriodicWaveConstraints</code></a> Members</span></h5><dl class="dictionary-members"><dt id="widl-PeriodicWaveConstraints-disableNormalization"><code>disableNormalization</code> of type <span class="idlMemberType">boolean</span>, defaulting to <code>false</code></dt><dd>
              Controls whether the periodic wave is normalized or not. If
              <code>true</code>, the waveform is not normalized; otherwise, the
              waveform is normalized.
            </dd></dl></section>
        </section>
        <section property="bibo:hasPart" resource="#waveform-generation" typeof="bibo:Chapter" id="waveform-generation">
          <h4 resource="#h-waveform-generation" id="h-waveform-generation"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.31.2 </span>
            Waveform Generation
          </span></h4>
          <p>
            The <!--a href=
            "#widl-BaseAudioContext-createPeriodicWave-PeriodicWave-Float32Array-real-Float32Array-imag"-->
            createPeriodicWave() method takes two arrays to specify the
            Fourier coefficients of the PeriodicWave. Let \(a\) and \(b\)
            represent the real and imaginary arrays of length \(L\). Then the
            basic time-domain waveform, \(x(t)\), can be computed using:
          </p>
          <pre>            $$
              x(t) = \sum_{k=1}^{L-1} \left(a[k]\cos2\pi k t + b[k]\sin2\pi k t\right)
            $$

</pre>
          <p>
            This is the basic (unnormalized) waveform.
          </p>
        </section>
        <section property="bibo:hasPart" resource="#waveform-normalization" typeof="bibo:Chapter" id="waveform-normalization">
          <h4 resource="#h-waveform-normalization" id="h-waveform-normalization"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.31.3 </span>
            Waveform Normalization
          </span></h4>
          <p>
            By default, the waveform defined in the previous section is
            normalized so that the maximum value is 1. The normalization is
            done as follows.
          </p>
          <p>
            Let
          </p>
          <pre>          $$
            \tilde{x}(n) = \sum_{k=1}^{L-1} \left(a[k]\cos\frac{2\pi k n}{N} + b[k]\sin\frac{2\pi k n}{N}\right)
          $$

</pre>
          <p>
            where \(N\) is a power of two. (Note: \(\tilde{x}(n)\) can
            conveniently be computed using an inverse FFT.) The fixed
            normalization factor \(f\) is computed as follows:
          </p>
          <pre>            $$
              f = \max_{n = 0, \ldots, N - 1} |\tilde{x}(n)|
            $$

</pre>
          <p>
            Thus, the actual normalized waveform \(\hat{x}(n)\) is
          </p>
          <pre>            $$
              \hat{x}(n) = \frac{\tilde{x}(n)}{f}
            $$

</pre>
          <p>
            This fixed normalization factor must be applied to all generated
            waveforms.
          </p>
        </section>
        <section property="bibo:hasPart" resource="#oscillator-coefficients" typeof="bibo:Chapter" id="oscillator-coefficients">
          <h4 resource="#h-oscillator-coefficients" id="h-oscillator-coefficients"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.31.4 </span>
            Oscillator Coefficients
          </span></h4>
          <p>
            The builtin oscillator types are created using <a class="idlType" href="#idl-def-PeriodicWave"><code>PeriodicWave</code></a>
            objects. For completeness the coefficients for the PeriodicWave for
            each of the builtin oscillator types is given here. This is useful
            if a builtin type is desired but without the default normalization.
          </p>
          <p>
            In the following descriptions, let \(a\) be the array of real
            coefficients and \(b\) be the array of imaginary coefficients for
            <!--a href=
            "#widl-BaseAudioContext-createPeriodicWave-PeriodicWave-Float32Array-real-Float32Array-imag"-->
            <code>createPeriodicWave()</code>. In all cases \(a[n] = 0\)
            for all \(n\) because the waveforms are odd functions. Also, \(b[0]
            = 0\) in all cases. Hence, only \(b[n]\) for \(n \ge 1\) is
            specified below.
          </p>
          <dl>
            <dt>
              "sine"
            </dt>
            <dd>
              <pre>                  $$
                    b[n] = \begin{cases}
                             1 &amp; \mbox{for } n = 1 \\
                             0 &amp; \mbox{otherwise}
                           \end{cases}
                  $$

</pre>
            </dd>
            <dt>
              "square"
            </dt>
            <dd>
              <pre>                  $$
                    b[n] = \frac{2}{n\pi}\left[1 - (-1)^n\right]
                  $$

</pre>
            </dd>
            <dt>
              "sawtooth"
            </dt>
            <dd>
              <pre>                $$
                  b[n] = (-1)^{n+1} \dfrac{2}{n\pi}
                $$

</pre>
            </dd>
            <dt>
              "triangle"
            </dt>
            <dd>
              <pre>                  $$
                    b[n] = \frac{8\sin\dfrac{n\pi}{2}}{(\pi n)^2}
                  $$

</pre>
            </dd>
          </dl>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#MediaStreamAudioSourceNode" typeof="bibo:Chapter">
        <h3 resource="#MediaStreamAudioSourceNode" id="MediaStreamAudioSourceNode"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.32 </span>
          The MediaStreamAudioSourceNode Interface
        </span></h3>
        <p>
          This interface represents an audio source from a
          <code>MediaStream</code>. The first
          <code>AudioMediaStreamTrack</code> from the <code>MediaStream</code>
          will be used as a source of audio. Those interfaces are described in
          [<cite><a href="#bib-mediacapture-streams" class="bibref">mediacapture-streams</a></cite>].
        </p>
        <pre>    numberOfInputs  : 0
    numberOfOutputs : 1
</pre>
        <p>
          The number of channels of the output corresponds to the number of
          channels of the <code>AudioMediaStreamTrack</code>. If there is no
          valid audio track, then the number of channels output will be one
          silent channel.
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-MediaStreamAudioSourceNode">interface <span class="idlInterfaceID">MediaStreamAudioSourceNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
};</span></pre>
      </section>
      <section property="bibo:hasPart" resource="#the-mediastreamaudiodestinationnode-interface" typeof="bibo:Chapter" id="the-mediastreamaudiodestinationnode-interface">
        <h3 resource="#h-the-mediastreamaudiodestinationnode-interface" id="h-the-mediastreamaudiodestinationnode-interface"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.33 </span>
          The MediaStreamAudioDestinationNode Interface
        </span></h3>
        <p>
          This interface is an audio destination representing a
          <code>MediaStream</code> with a single
          <code>AudioMediaStreamTrack</code>. This MediaStream is created when
          the node is created and is accessible via the <dfn id="dfn-stream" data-dfn-type="dfn">stream</dfn>
          attribute. This stream can be used in a similar way as a
          <code>MediaStream</code> obtained via <code>getUserMedia()</code>,
          and can, for example, be sent to a remote peer using the
          <code>RTCPeerConnection</code> (described in [<cite><a href="#bib-webrtc" class="bibref">webrtc</a></cite>])
          <code>addStream()</code> method.
        </p>
        <pre>    numberOfInputs  : 1
    numberOfOutputs : 0

    channelCount = 2;
    channelCountMode = "explicit";
    channelInterpretation = "speakers";
</pre>
        <p>
          The number of channels of the input is by default 2 (stereo). Any
          connections to the input are up-mixed/down-mixed to the number of
          channels of the input.
        </p>
        <pre class="idl"><span class="idlInterface" id="idl-def-MediaStreamAudioDestinationNode">interface <span class="idlInterfaceID">MediaStreamAudioDestinationNode</span> : <span class="idlSuperclass"><a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a></span> {
<span class="idlAttribute">    readonly        attribute <span class="idlAttrType">MediaStream</span> <span class="idlAttrName"><a href="#widl-MediaStreamAudioDestinationNode-stream">stream</a></span>;</span>
};</span></pre><section property="bibo:hasPart" resource="#attributes-29" typeof="bibo:Chapter" id="attributes-29"><h4 resource="#h-attributes-29" id="h-attributes-29"><span property="xhv:role" resource="xhv:heading"><span class="secno">2.33.1 </span>Attributes</span></h4><dl class="attributes"><dt id="widl-MediaStreamAudioDestinationNode-stream"><code>stream</code> of type <span class="idlAttrType">MediaStream</span>, readonly       </dt><dd>
            A MediaStream containing a single AudioMediaStreamTrack with the
            same number of channels as the node itself.
          </dd></dl></section>
      </section>
    </section>
    <section property="bibo:hasPart" resource="#mixer-gain-structure" typeof="bibo:Chapter" id="mixer-gain-structure" class="informative">
      <!--OddPage--><h2 resource="#h-mixer-gain-structure" id="h-mixer-gain-structure"><span property="xhv:role" resource="xhv:heading"><span class="secno">3. </span>
        Mixer Gain Structure
      </span></h2><p><em>This section is non-normative.</em></p>
      <h2 id="background">
        Background
      </h2>
      <p>
        One of the most important considerations when dealing with audio
        processing graphs is how to adjust the gain (volume) at various points.
        For example, in a standard mixing board model, each input bus has
        pre-gain, post-gain, and send-gains. Submix and master out busses also
        have gain control. The gain control described here can be used to
        implement standard mixing boards as well as other architectures.
      </p>
      <section property="bibo:hasPart" resource="#SummingJunction" typeof="bibo:Chapter">
        <h3 resource="#SummingJunction" id="SummingJunction"><span property="xhv:role" resource="xhv:heading"><span class="secno">3.1 </span>
          Summing Inputs
        </span></h3>
        <p>
          The inputs to <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s have the ability to
          accept connections from multiple outputs. The input then acts as a
          unity gain summing junction with each output signal being added with
          the others:
        </p>
        <figure id="fig-a-graph-showing-source-1-and-source-2-output-summed-at-the-input-of-destination">
          <img alt="unity gain summing junction" src="images/unity-gain-summing-junction.png">
          <figcaption>Fig. <span class="figno">8</span> <span class="fig-title">
            A graph showing Source 1 and Source 2 output summed at the input of
            Destination
          </span></figcaption>
        </figure>
        <p>
          In cases where the channel layouts of the outputs do not match, a mix
          (usually up-mix) will occur according to the <a href="#channel-up-mixing-and-down-mixing">mixing rules</a>.
        </p>
        <p>
          No clipping is applied at the inputs or outputs of the
          <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> to allow a maximum of dynamic range
          within the audio graph.
        </p>
      </section>
      <section property="bibo:hasPart" resource="#gain-control" typeof="bibo:Chapter" id="gain-control">
        <h3 resource="#h-gain-control" id="h-gain-control"><span property="xhv:role" resource="xhv:heading"><span class="secno">3.2 </span>
          Gain Control
        </span></h3>
        <p>
          In many scenarios, it's important to be able to control the gain for
          each of the output signals. The <a class="idlType" href="#idl-def-GainNode"><code>GainNode</code></a> gives
          this control:
        </p>
        <figure id="fig-a-graph-featuring-volume-control-for-each-voice">
          <img alt="mixer architecture new" src="images/mixer-architecture-new.png">
          <figcaption>Fig. <span class="figno">9</span> <span class="fig-title">
            A graph featuring volume control for each voice
          </span></figcaption>
        </figure>
        <p>
          Using these two concepts of unity gain summing junctions and
          GainNodes, it's possible to construct simple or complex mixing
          scenarios.
        </p>
      </section>
      <section property="bibo:hasPart" resource="#Example-mixer-with-send-busses" typeof="bibo:Chapter">
        <h3 resource="#Example-mixer-with-send-busses" id="Example-mixer-with-send-busses"><span property="xhv:role" resource="xhv:heading"><span class="secno">3.3 </span>
          Example: Mixer with Send Busses
        </span></h3>
        <p>
          In a routing scenario involving multiple sends and submixes, explicit
          control is needed over the volume or "gain" of each connection to a
          mixer. Such routing topologies are very common and exist in even the
          simplest of electronic gear sitting around in a basic recording
          studio.
        </p>
        <p>
          Here's an example with two send mixers and a main mixer. Although
          possible, for simplicity's sake, pre-gain control and insert effects
          are not illustrated:
        </p>
        <figure id="fig-a-graph-showing-a-full-mixer-with-send-busses.x">
          <img alt="mixer gain structure" src="images/mixer-gain-structure.png">
          <figcaption>Fig. <span class="figno">10</span> <span class="fig-title">
            A graph showing a full mixer with send busses.
          </span></figcaption>
        </figure>
        <p>
          This diagram is using a shorthand notation where "send 1", "send 2",
          and "main bus" are actually inputs to <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s,
          but here are represented as summing busses, where the intersections
          g2_1, g3_1, etc. represent the "gain" or volume for the given source
          on the given mixer. In order to expose this gain, an
          <a class="idlType" href="#idl-def-GainNode"><code>GainNode</code></a> is used:
        </p>
        <p>
          Here's how the above diagram could be constructed in JavaScript:
        </p>
        <div class="example"><div class="example-title"><span>Example 8</span></div><pre style="" class="highlight example prettyprint prettyprinted"><span class="kwd">var</span><span class="pln"> context </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> compressor </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> reverb </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> delay </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> s1 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> s2 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">var</span><span class="pln"> source1 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> source2 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> g1_1 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> g2_1 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> g3_1 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> g1_2 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> g2_2 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> g3_2 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">

</span><span class="com">// Setup routing graph</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> setupRoutingGraph</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    context </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AudioContext</span><span class="pun">();</span><span class="pln">

    compressor </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createDynamicsCompressor</span><span class="pun">();</span><span class="pln">

    </span><span class="com">// Send1 effect</span><span class="pln">
    reverb </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createConvolver</span><span class="pun">();</span><span class="pln">
    </span><span class="com">// Convolver impulse response may be set here or later</span><span class="pln">

    </span><span class="com">// Send2 effect</span><span class="pln">
    delay </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createDelay</span><span class="pun">();</span><span class="pln">

    </span><span class="com">// Connect final compressor to final destination</span><span class="pln">
    compressor</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">context</span><span class="pun">.</span><span class="pln">destination</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// Connect sends 1 &amp; 2 through effects to main mixer</span><span class="pln">
    s1 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">
    reverb</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">s1</span><span class="pun">);</span><span class="pln">
    s1</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">compressor</span><span class="pun">);</span><span class="pln">

    s2 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">
    delay</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">s2</span><span class="pun">);</span><span class="pln">
    s2</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">compressor</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// Create a couple of sources</span><span class="pln">
    source1 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createBufferSource</span><span class="pun">();</span><span class="pln">
    source2 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createBufferSource</span><span class="pun">();</span><span class="pln">
    source1</span><span class="pun">.</span><span class="pln">buffer </span><span class="pun">=</span><span class="pln"> manTalkingBuffer</span><span class="pun">;</span><span class="pln">
    source2</span><span class="pun">.</span><span class="pln">buffer </span><span class="pun">=</span><span class="pln"> footstepsBuffer</span><span class="pun">;</span><span class="pln">

    </span><span class="com">// Connect source1</span><span class="pln">
    g1_1 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">
    g2_1 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">
    g3_1 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">
    source1</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">g1_1</span><span class="pun">);</span><span class="pln">
    source1</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">g2_1</span><span class="pun">);</span><span class="pln">
    source1</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">g3_1</span><span class="pun">);</span><span class="pln">
    g1_1</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">compressor</span><span class="pun">);</span><span class="pln">
    g2_1</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">reverb</span><span class="pun">);</span><span class="pln">
    g3_1</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">delay</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// Connect source2</span><span class="pln">
    g1_2 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">
    g2_2 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">
    g3_2 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">
    source2</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">g1_2</span><span class="pun">);</span><span class="pln">
    source2</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">g2_2</span><span class="pun">);</span><span class="pln">
    source2</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">g3_2</span><span class="pun">);</span><span class="pln">
    g1_2</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">compressor</span><span class="pun">);</span><span class="pln">
    g2_2</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">reverb</span><span class="pun">);</span><span class="pln">
    g3_2</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">delay</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// We now have explicit control over all the volumes g1_1, g2_1, ..., s1, s2</span><span class="pln">
    g2_1</span><span class="pun">.</span><span class="pln">gain</span><span class="pun">.</span><span class="pln">value </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.2</span><span class="pun">;</span><span class="pln">  </span><span class="com">// For example, set source1 reverb gain</span><span class="pln">

    </span><span class="com">// Because g2_1.gain is an "AudioParam",</span><span class="pln">
    </span><span class="com">// an automation curve could also be attached to it.</span><span class="pln">
    </span><span class="com">// A "mixing board" UI could be created in canvas or WebGL controlling these gains.</span><span class="pln">
</span><span class="pun">}</span></pre></div>
      </section>
    </section>
    <section property="bibo:hasPart" resource="#DynamicLifetime" typeof="bibo:Chapter">
      <!--OddPage--><h2 resource="#DynamicLifetime" id="DynamicLifetime"><span property="xhv:role" resource="xhv:heading"><span class="secno">4. </span>
        Dynamic Lifetime
      </span></h2>
      <section property="bibo:hasPart" resource="#background-1" typeof="bibo:Chapter" id="background-1">
        <h3 resource="#h-background-1" id="h-background-1"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.1 </span>
          Background
        </span></h3>
        <p class="norm">
          <em>This section is non-normative. Please see <a href="#lifetime-AudioContext">AudioContext lifetime</a> and <a href="#lifetime-AudioNode">AudioNode lifetime</a> for normative
          requirements.</em>
        </p>
        <p>
          In addition to allowing the creation of static routing
          configurations, it should also be possible to do custom effect
          routing on dynamically allocated voices which have a limited
          lifetime. For the purposes of this discussion, let's call these
          short-lived voices "notes". Many audio applications incorporate the
          ideas of notes, examples being drum machines, sequencers, and 3D
          games with many one-shot sounds being triggered according to game
          play.
        </p>
        <p>
          In a traditional software synthesizer, notes are dynamically
          allocated and released from a pool of available resources. The note
          is allocated when a MIDI note-on message is received. It is released
          when the note has finished playing either due to it having reached
          the end of its sample-data (if non-looping), it having reached a
          sustain phase of its envelope which is zero, or due to a MIDI
          note-off message putting it into the release phase of its envelope.
          In the MIDI note-off case, the note is not released immediately, but
          only when the release envelope phase has finished. At any given time,
          there can be a large number of notes playing but the set of notes is
          constantly changing as new notes are added into the routing graph,
          and old ones are released.
        </p>
        <p>
          The audio system automatically deals with tearing-down the part of
          the routing graph for individual "note" events. A "note" is
          represented by an <a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a>, which
          can be directly connected to other processing nodes. When the note
          has finished playing, the context will automatically release the
          reference to the <a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a>, which in
          turn will release references to any nodes it is connected to, and so
          on. The nodes will automatically get disconnected from the graph and
          will be deleted when they have no more references. Nodes in the graph
          which are long-lived and shared between dynamic voices can be managed
          explicitly. Although it sounds complicated, this all happens
          automatically with no extra JavaScript handling required.
        </p>
      </section>
      <section property="bibo:hasPart" resource="#example" typeof="bibo:Chapter" id="example">
        <h3 resource="#h-example" id="h-example"><span property="xhv:role" resource="xhv:heading"><span class="secno">4.2 </span>
          Example
        </span></h3>
        <figure id="fig-a-graph-featuring-a-subgraph-that-will-be-releases-early.x">
          <img alt="dynamic allocation" src="images/dynamic-allocation.png">
          <figcaption>Fig. <span class="figno">11</span> <span class="fig-title">
            A graph featuring a subgraph that will be releases early.
          </span></figcaption>
        </figure>
        <p>
          The low-pass filter, panner, and second gain nodes are directly
          connected from the one-shot sound. So when it has finished playing
          the context will automatically release them (everything within the
          dotted line). If there are no longer any JavaScript references to the
          one-shot sound and connected nodes, then they will be immediately
          removed from the graph and deleted. The streaming source, has a
          global reference and will remain connected until it is explicitly
          disconnected. Here's how it might look in JavaScript:
        </p>
        <div class="example"><div class="example-title"><span>Example 9</span></div><pre style="" class="example highlight prettyprint prettyprinted"><span class="kwd">var</span><span class="pln"> context </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> compressor </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> gainNode1 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> streamingAudioSource </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">

</span><span class="com">// Initial setup of the "long-lived" part of the routing graph</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> setupAudioContext</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    context </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AudioContext</span><span class="pun">();</span><span class="pln">

    compressor </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createDynamicsCompressor</span><span class="pun">();</span><span class="pln">
    gainNode1 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">

    </span><span class="com">// Create a streaming audio source.</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> audioElement </span><span class="pun">=</span><span class="pln"> document</span><span class="pun">.</span><span class="pln">getElementById</span><span class="pun">(</span><span class="str">'audioTagID'</span><span class="pun">);</span><span class="pln">
    streamingAudioSource </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createMediaElementSource</span><span class="pun">(</span><span class="pln">audioElement</span><span class="pun">);</span><span class="pln">
    streamingAudioSource</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">gainNode1</span><span class="pun">);</span><span class="pln">

    gainNode1</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">compressor</span><span class="pun">);</span><span class="pln">
    compressor</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">context</span><span class="pun">.</span><span class="pln">destination</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="com">// Later in response to some user action (typically mouse or key event)</span><span class="pln">
</span><span class="com">// a one-shot sound can be played.</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> playSound</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> oneShotSound </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createBufferSource</span><span class="pun">();</span><span class="pln">
    oneShotSound</span><span class="pun">.</span><span class="pln">buffer </span><span class="pun">=</span><span class="pln"> dogBarkingBuffer</span><span class="pun">;</span><span class="pln">

    </span><span class="com">// Create a filter, panner, and gain node.</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> lowpass </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createBiquadFilter</span><span class="pun">();</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> panner </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createPanner</span><span class="pun">();</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> gainNode2 </span><span class="pun">=</span><span class="pln"> context</span><span class="pun">.</span><span class="pln">createGain</span><span class="pun">();</span><span class="pln">

    </span><span class="com">// Make connections</span><span class="pln">
    oneShotSound</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">lowpass</span><span class="pun">);</span><span class="pln">
    lowpass</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">panner</span><span class="pun">);</span><span class="pln">
    panner</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">gainNode2</span><span class="pun">);</span><span class="pln">
    gainNode2</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">compressor</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// Play 0.75 seconds from now (to play immediately pass in 0)</span><span class="pln">
    oneShotSound</span><span class="pun">.</span><span class="pln">start</span><span class="pun">(</span><span class="pln">context</span><span class="pun">.</span><span class="pln">currentTime </span><span class="pun">+</span><span class="pln"> </span><span class="lit">0.75</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></pre></div>
      </section>
    </section>
    <section property="bibo:hasPart" resource="#channel-up-mixing-and-down-mixing" typeof="bibo:Chapter" id="channel-up-mixing-and-down-mixing">
      <!--OddPage--><h2 resource="#h-channel-up-mixing-and-down-mixing" id="h-channel-up-mixing-and-down-mixing"><span property="xhv:role" resource="xhv:heading"><span class="secno">5. </span>
        Channel up-mixing and down-mixing
      </span></h2>
      <p class="norm">
        This section is normative.
      </p>
      <p>
        <a class="sec-ref" href="#mixer-gain-structure"><span class="secno">3.</span> <span class="sec-title">
        Mixer Gain Structure
      </span></a> describes how an input to an
        <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> can be connected from one or more outputs
        of an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>. Each of these connections from an
        output represents a stream with a specific non-zero number of channels.
        An input has <em>mixing rules</em> for combining the channels from all
        of the connections to it. As a simple example, if an input is connected
        from a mono output and a stereo output, then the mono connection will
        usually be up-mixed to stereo and summed with the stereo connection.
        But, of course, it's important to define the exact <em>mixing
        rules</em> for every input to every <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>. The
        default mixing rules for all of the inputs have been chosen so that
        things "just work" without worrying too much about the details,
        especially in the very common case of mono and stereo streams. Of
        course, the rules can be changed for advanced use cases, especially
        multi-channel.
      </p>
      <p>
        To define some terms, <em>up-mixing</em> refers to the process of
        taking a stream with a smaller number of channels and converting it to
        a stream with a larger number of channels. <em>down-mixing</em> refers
        to the process of taking a stream with a larger number of channels and
        converting it to a stream with a smaller number of channels.
      </p>
      <p>
        An <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> input use three basic pieces of
        information to determine how to mix all the outputs connected to it. As
        part of this process it computes an internal value
        <dfn id="dfn-computednumberofchannels" data-dfn-type="dfn"><code>computedNumberOfChannels</code></dfn> representing the
        actual number of channels of the input at any given time:
      </p>
      <p>
        The <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> attributes involved in channel
        up-mixing and down-mixing rules are defined <a href="#the-audionode-interface">above</a>. The following is a more precise
        specification on what each of them mean.
      </p>
      <ul>
        <li>
          <a href="#widl-AudioNode-channelCount"><code>channelCount</code></a>
          is used to help compute <a data-link-type="dfn" class="internalDFN" href="#dfn-computednumberofchannels"><code><code>computedNumberOfChannels</code></code></a>.
        </li>
        <li>
          <a href="#widl-AudioNode-channelCountMode"><code>channelCountMode</code></a>
          determines how <a data-link-type="dfn" class="internalDFN" href="#dfn-computednumberofchannels"><code><code>computedNumberOfChannels</code></code></a> will be
          computed. Once this number is computed, all of the connections will
          be up or down-mixed to that many channels. For most nodes, the
          default value is <a href="#idl-def-ChannelCountMode.max"><code>"max"</code></a>.
          <ul>
            <li>
              <a href="#idl-def-ChannelCountMode.max"><code>"max"</code></a>:
              <a data-link-type="dfn" class="internalDFN" href="#dfn-computednumberofchannels"><code><code>computedNumberOfChannels</code></code></a> is computed as the
              maximum of the number of channels of all connections. In this
              mode <a href="#widl-AudioNode-channelCount"><code>channelCount</code></a> is
              ignored.
            </li>
            <li>
              <a href="#idl-def-ChannelCountMode.clamped-max"><code>"clamped-max"</code></a>:
              same as “max” up to a limit of the <a href="#widl-AudioNode-channelCount"><code>channelCount</code></a>
            </li>
            <li>
              <a href="#idl-def-ChannelCountMode.explicit"><code>"explicit"</code></a>:
              <a data-link-type="dfn" class="internalDFN" href="#dfn-computednumberofchannels"><code><code>computedNumberOfChannels</code></code></a> is the exact value
              as specified in <a href="#widl-AudioNode-channelCount"><code>channelCount</code></a>
            </li>
          </ul>
        </li>
        <li>
          <a href="#widl-AudioNode-channelInterpretation"><code>channelInterpretation</code></a>
          determines how the individual channels will be treated. For example,
          will they be treated as speakers having a specific layout, or will
          they be treated as simple discrete channels? This value influences
          exactly how the up and down mixing is performed. The default value is
          "speakers".
          <ul>
            <li>
              <a href="#idl-def-ChannelInterpretation.speakers"><code>“speakers”</code></a>:
              use <a href="#ChannelLayouts">up-down-mix equations for
              mono/stereo/quad/5.1</a>. In cases where the number of channels
              do not match any of these basic speaker layouts, revert to
              "discrete".
            </li>
            <li>
              <a href="#idl-def-ChannelInterpretation.discrete"><code>“discrete”</code></a>:
              up-mix by filling channels until they run out then zero out
              remaining channels. down-mix by filling as many channels as
              possible, then dropping remaining channels
            </li>
          </ul>
        </li>
      </ul>
      <p>
        For each input of an <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>, an implementation
        must:
      </p>
      <ol>
        <li>Compute <a data-link-type="dfn" class="internalDFN" href="#dfn-computednumberofchannels"><code><code>computedNumberOfChannels</code></code></a>.
        </li>
        <li>For each connection to the input:
          <ul>
            <li>up-mix or down-mix the connection to
            <a data-link-type="dfn" class="internalDFN" href="#dfn-computednumberofchannels"><code><code>computedNumberOfChannels</code></code></a> according to
              <a href="#widl-AudioNode-channelInterpretation"><code>channelInterpretation</code></a>.
            </li>
            <li>Mix it together with all of the other mixed streams (from other
            connections). This is a straight-forward mixing together of each of
            the corresponding channels from each connection.
            </li>
          </ul>
        </li>
      </ol>
      <section property="bibo:hasPart" resource="#ChannelLayouts" typeof="bibo:Chapter">
        <h3 resource="#ChannelLayouts" id="ChannelLayouts"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.1 </span>
          Speaker Channel Layouts
        </span></h3>
        <p>
          When <a href="#widl-AudioNode-channelInterpretation"><code>channelInterpretation</code></a>
          is <a href="#idl-def-ChannelInterpretation.speakers">"speakers"</a>
          then the up-mixing and down-mixing is defined for specific channel
          layouts.
        </p>
        <p>
          Mono (one channel), stereo (two channels), quad (four channels), and
          5.1 (six channels) <em title="MUST" class="rfc2119">MUST</em> be supported. Other channel layout may be
          supported in future version of this specification.
        </p>
      </section>
      <section property="bibo:hasPart" resource="#ChannelOrdering" typeof="bibo:Chapter">
        <h3 resource="#ChannelOrdering" id="ChannelOrdering"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.2 </span>
          Channel ordering
        </span></h3>
        <pre>    Mono
      0: M: mono

    Stereo
      0: L: left
      1: R: right

</pre>
        <pre>  Quad
      0: L:  left
      1: R:  right
      2: SL: surround left
      3: SR: surround right

    5.1
      0: L:   left
      1: R:   right
      2: C:   center
      3: LFE: subwoofer
      4: SL:  surround left
      5: SR:  surround right

</pre>
      </section>
      <section property="bibo:hasPart" resource="#UpMix-sub" typeof="bibo:Chapter">
        <h3 resource="#UpMix-sub" id="UpMix-sub"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.3 </span>
          Up Mixing speaker layouts
        </span></h3>
        <pre>Mono up-mix:

    1 -&gt; 2 : up-mix from mono to stereo
        output.L = input;
        output.R = input;

    1 -&gt; 4 : up-mix from mono to quad
        output.L = input;
        output.R = input;
        output.SL = 0;
        output.SR = 0;

    1 -&gt; 5.1 : up-mix from mono to 5.1
        output.L = 0;
        output.R = 0;
        output.C = input; // put in center channel
        output.LFE = 0;
        output.SL = 0;
        output.SR = 0;

Stereo up-mix:

    2 -&gt; 4 : up-mix from stereo to quad
        output.L = input.L;
        output.R = input.R;
        output.SL = 0;
        output.SR = 0;

    2 -&gt; 5.1 : up-mix from stereo to 5.1
        output.L = input.L;
        output.R = input.R;
        output.C = 0;
        output.LFE = 0;
        output.SL = 0;
        output.SR = 0;

Quad up-mix:

    4 -&gt; 5.1 : up-mix from quad to 5.1
        output.L = input.L;
        output.R = input.R;
        output.C = 0;
        output.LFE = 0;
        output.SL = input.SL;
        output.SR = input.SR;
</pre>
      </section>
      <section property="bibo:hasPart" resource="#down-mix" typeof="bibo:Chapter">
        <h3 resource="#down-mix" id="down-mix"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.4 </span>
          Down Mixing speaker layouts
        </span></h3>
        <p>
          A down-mix will be necessary, for example, if processing 5.1 source
          material, but playing back stereo.
        </p>
        <pre>  Mono down-mix:

      2 -&gt; 1 : stereo to mono
          output = 0.5 * (input.L + input.R);

      4 -&gt; 1 : quad to mono
          output = 0.25 * (input.L + input.R + input.SL + input.SR);

      5.1 -&gt; 1 : 5.1 to mono
          output = 0.7071 * (input.L + input.R) + input.C + 0.5 * (input.SL + input.SR)


  Stereo down-mix:

      4 -&gt; 2 : quad to stereo
          output.L = 0.5 * (input.L + input.SL);
          output.R = 0.5 * (input.R + input.SR);

      5.1 -&gt; 2 : 5.1 to stereo
          output.L = L + 0.7071 * (input.C + input.SL)
          output.R = R + 0.7071 * (input.C + input.SR)

  Quad down-mix:

      5.1 -&gt; 4 : 5.1 to quad
          output.L = L + 0.7071 * input.C
          output.R = R + 0.7071 * input.C
          output.SL = input.SL
          output.SR = input.SR


</pre>
      </section>
      <section property="bibo:hasPart" resource="#ChannelRules-section" typeof="bibo:Chapter" class="informative">
        <h3 resource="#ChannelRules-section" id="ChannelRules-section"><span property="xhv:role" resource="xhv:heading"><span class="secno">5.5 </span>
          Channel Rules Examples
        </span></h3><p><em>This section is non-normative.</em></p>
        <div class="example"><div class="example-title"><span>Example 10</span></div><pre style="" class="highlight example prettyprint prettyprinted"><span class="com">// Set gain node to explicit 2-channels (stereo).</span><span class="pln">
gain</span><span class="pun">.</span><span class="pln">channelCount </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln">
gain</span><span class="pun">.</span><span class="pln">channelCountMode </span><span class="pun">=</span><span class="pln"> </span><span class="str">"explicit"</span><span class="pun">;</span><span class="pln">
gain</span><span class="pun">.</span><span class="pln">channelInterpretation </span><span class="pun">=</span><span class="pln"> </span><span class="str">"speakers"</span><span class="pun">;</span><span class="pln">

</span><span class="com">// Set "hardware output" to 4-channels for DJ-app with two stereo output busses.</span><span class="pln">
context</span><span class="pun">.</span><span class="pln">destination</span><span class="pun">.</span><span class="pln">channelCount </span><span class="pun">=</span><span class="pln"> </span><span class="lit">4</span><span class="pun">;</span><span class="pln">
context</span><span class="pun">.</span><span class="pln">destination</span><span class="pun">.</span><span class="pln">channelCountMode </span><span class="pun">=</span><span class="pln"> </span><span class="str">"explicit"</span><span class="pun">;</span><span class="pln">
context</span><span class="pun">.</span><span class="pln">destination</span><span class="pun">.</span><span class="pln">channelInterpretation </span><span class="pun">=</span><span class="pln"> </span><span class="str">"discrete"</span><span class="pun">;</span><span class="pln">

</span><span class="com">// Set "hardware output" to 8-channels for custom multi-channel speaker array</span><span class="pln">
</span><span class="com">// with custom matrix mixing.</span><span class="pln">
context</span><span class="pun">.</span><span class="pln">destination</span><span class="pun">.</span><span class="pln">channelCount </span><span class="pun">=</span><span class="pln"> </span><span class="lit">8</span><span class="pun">;</span><span class="pln">
context</span><span class="pun">.</span><span class="pln">destination</span><span class="pun">.</span><span class="pln">channelCountMode </span><span class="pun">=</span><span class="pln"> </span><span class="str">"explicit"</span><span class="pun">;</span><span class="pln">
context</span><span class="pun">.</span><span class="pln">destination</span><span class="pun">.</span><span class="pln">channelInterpretation </span><span class="pun">=</span><span class="pln"> </span><span class="str">"discrete"</span><span class="pun">;</span><span class="pln">

</span><span class="com">// Set "hardware output" to 5.1 to play an HTMLAudioElement.</span><span class="pln">
context</span><span class="pun">.</span><span class="pln">destination</span><span class="pun">.</span><span class="pln">channelCount </span><span class="pun">=</span><span class="pln"> </span><span class="lit">6</span><span class="pun">;</span><span class="pln">
context</span><span class="pun">.</span><span class="pln">destination</span><span class="pun">.</span><span class="pln">channelCountMode </span><span class="pun">=</span><span class="pln"> </span><span class="str">"explicit"</span><span class="pun">;</span><span class="pln">
context</span><span class="pun">.</span><span class="pln">destination</span><span class="pun">.</span><span class="pln">channelInterpretation </span><span class="pun">=</span><span class="pln"> </span><span class="str">"speakers"</span><span class="pun">;</span><span class="pln">

</span><span class="com">// Explicitly down-mix to mono.</span><span class="pln">
gain</span><span class="pun">.</span><span class="pln">channelCount </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
gain</span><span class="pun">.</span><span class="pln">channelCountMode </span><span class="pun">=</span><span class="pln"> </span><span class="str">"explicit"</span><span class="pun">;</span><span class="pln">
gain</span><span class="pun">.</span><span class="pln">channelInterpretation </span><span class="pun">=</span><span class="pln"> </span><span class="str">"speakers"</span><span class="pun">;</span></pre></div>
      </section>
    </section>
    <section property="bibo:hasPart" resource="#audio-sample-values" typeof="bibo:Chapter">
      <!--OddPage--><h2 resource="#audio-sample-values" id="audio-sample-values"><span property="xhv:role" resource="xhv:heading"><span class="secno">6. </span>
        Audio Signal Values
      </span></h2>
      <p>
        The nominal range of all audio signals at a destination node of any
        audio graph is [-1, 1]. The audio rendition of signal values outside
        this range, or of the values <code>NaN</code>, positive infinity or
        negative infinity, is undefined by this specification.
      </p>
    </section>
    <section property="bibo:hasPart" resource="#Spatialization" typeof="bibo:Chapter">
      <!--OddPage--><h2 resource="#Spatialization" id="Spatialization"><span property="xhv:role" resource="xhv:heading"><span class="secno">7. </span>
        Spatialization / Panning
      </span></h2>
      <section property="bibo:hasPart" resource="#Spatialization-background" typeof="bibo:Chapter">
        <h3 resource="#Spatialization-background" id="Spatialization-background"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.1 </span>
          Background
        </span></h3>
        <p>
          A common feature requirement for modern 3D games is the ability to
          dynamically spatialize and move multiple audio sources in 3D space.
          Game audio engines such as OpenAL, FMOD, Creative's EAX, Microsoft's
          XACT Audio, etc. have this ability.
        </p>
        <p>
          Using an <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a>, an audio stream can be
          spatialized or positioned in space relative to an
          <a class="idlType" href="#idl-def-AudioListener"><code>AudioListener</code></a>. An
          <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a> will contain a single
          <a class="idlType" href="#idl-def-AudioListener"><code>AudioListener</code></a>. Both panners and listeners have a
          position in 3D space using a right-handed cartesian coordinate
          system. The units used in the coordinate system are not defined, and
          do not need to be because the effects calculated with these
          coordinates are independent/invariant of any particular units such as
          meters or feet. <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a> objects (representing
          the source stream) have an <em>orientation</em> vector representing
          in which direction the sound is projecting. Additionally, they have a
          <em>sound cone</em> representing how directional the sound is. For
          example, the sound could be omnidirectional, in which case it would
          be heard anywhere regardless of its orientation, or it can be more
          directional and heard only if it is facing the listener.
          <a class="idlType" href="#idl-def-AudioListener"><code>AudioListener</code></a> objects (representing a person's
          ears) have an <em>orientation</em> and <em>up</em> vector
          representing in which direction the person is facing. Because both
          the source stream and the listener can be moving, they both have a
          <em>velocity</em> vector representing both the speed and direction of
          movement. Taken together, these two velocities can be used to
          generate a doppler shift effect which changes the pitch.
        </p>
        <p>
          During rendering, the <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a> calculates an
          <em>azimuth</em> and <em>elevation</em>. These values are used
          internally by the implementation in order to render the
          spatialization effect. See the <a href="#Spatialization-panning-algorithm">Panning Algorithm</a> section for
          details of how these values are used.
        </p>
      </section>
      <section property="bibo:hasPart" resource="#azimuth-elevation" typeof="bibo:Chapter" id="azimuth-elevation">
        <h3 resource="#h-azimuth-elevation" id="h-azimuth-elevation"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.2 </span>
          Azimuth and Elevation
        </span></h3>
        <p>
          The following algorithm must be used to calculate the
          <em>azimuth</em> and <em>elevation</em>: for the
          <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a>
        </p>
        <pre style="" class="code highlight prettyprint prettyprinted"><span class="pln">  </span><span class="com">// Calculate the source-listener vector.</span><span class="pln">
  vec3 sourceListener </span><span class="pun">=</span><span class="pln"> source</span><span class="pun">.</span><span class="pln">position </span><span class="pun">-</span><span class="pln"> listener</span><span class="pun">.</span><span class="pln">position</span><span class="pun">;</span><span class="pln">

  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">sourceListener</span><span class="pun">.</span><span class="pln">isZero</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="com">// Handle degenerate case if source and listener are at the same point.</span><span class="pln">
      azimuth </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
      elevation </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  sourceListener</span><span class="pun">.</span><span class="pln">normalize</span><span class="pun">();</span><span class="pln">

  </span><span class="com">// Align axes.</span><span class="pln">
  vec3 listenerFront </span><span class="pun">=</span><span class="pln"> listener</span><span class="pun">.</span><span class="pln">orientation</span><span class="pun">;</span><span class="pln">
  vec3 listenerUp </span><span class="pun">=</span><span class="pln"> listener</span><span class="pun">.</span><span class="pln">up</span><span class="pun">;</span><span class="pln">
  vec3 listenerRight </span><span class="pun">=</span><span class="pln"> listenerFront</span><span class="pun">.</span><span class="pln">cross</span><span class="pun">(</span><span class="pln">listenerUp</span><span class="pun">);</span><span class="pln">
  listenerRight</span><span class="pun">.</span><span class="pln">normalize</span><span class="pun">();</span><span class="pln">

  vec3 listenerFrontNorm </span><span class="pun">=</span><span class="pln"> listenerFront</span><span class="pun">;</span><span class="pln">
  listenerFrontNorm</span><span class="pun">.</span><span class="pln">normalize</span><span class="pun">();</span><span class="pln">

  vec3 up </span><span class="pun">=</span><span class="pln"> listenerRight</span><span class="pun">.</span><span class="pln">cross</span><span class="pun">(</span><span class="pln">listenerFrontNorm</span><span class="pun">);</span><span class="pln">

  </span><span class="kwd">float</span><span class="pln"> upProjection </span><span class="pun">=</span><span class="pln"> sourceListener</span><span class="pun">.</span><span class="pln">dot</span><span class="pun">(</span><span class="pln">up</span><span class="pun">);</span><span class="pln">

  vec3 projectedSource </span><span class="pun">=</span><span class="pln"> sourceListener </span><span class="pun">-</span><span class="pln"> upProjection </span><span class="pun">*</span><span class="pln"> up</span><span class="pun">;</span><span class="pln">
  projectedSource</span><span class="pun">.</span><span class="pln">normalize</span><span class="pun">();</span><span class="pln">

  azimuth </span><span class="pun">=</span><span class="pln"> </span><span class="lit">180</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> acos</span><span class="pun">(</span><span class="pln">projectedSource</span><span class="pun">.</span><span class="pln">dot</span><span class="pun">(</span><span class="pln">listenerRight</span><span class="pun">))</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> PI</span><span class="pun">;</span><span class="pln">

  </span><span class="com">// Source in front or behind the listener.</span><span class="pln">
  </span><span class="kwd">float</span><span class="pln"> frontBack </span><span class="pun">=</span><span class="pln"> projectedSource</span><span class="pun">.</span><span class="pln">dot</span><span class="pun">(</span><span class="pln">listenerFrontNorm</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">frontBack </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln">
      azimuth </span><span class="pun">=</span><span class="pln"> </span><span class="lit">360</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> azimuth</span><span class="pun">;</span><span class="pln">

  </span><span class="com">// Make azimuth relative to "front" and not "right" listener vector.</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">((</span><span class="pln">azimuth </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">azimuth </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">270</span><span class="pun">))</span><span class="pln">
      azimuth </span><span class="pun">=</span><span class="pln"> </span><span class="lit">90</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> azimuth</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">else</span><span class="pln">
      azimuth </span><span class="pun">=</span><span class="pln"> </span><span class="lit">450</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> azimuth</span><span class="pun">;</span><span class="pln">

  elevation </span><span class="pun">=</span><span class="pln"> </span><span class="lit">90</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">180</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> acos</span><span class="pun">(</span><span class="pln">sourceListener</span><span class="pun">.</span><span class="pln">dot</span><span class="pun">(</span><span class="pln">up</span><span class="pun">))</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> PI</span><span class="pun">;</span><span class="pln">

  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">elevation </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">90</span><span class="pun">)</span><span class="pln">
      elevation </span><span class="pun">=</span><span class="pln"> </span><span class="lit">180</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> elevation</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">elevation </span><span class="pun">&lt;</span><span class="pln"> </span><span class="pun">-</span><span class="lit">90</span><span class="pun">)</span><span class="pln">
      elevation </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">180</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> elevation</span><span class="pun">;</span><span class="pln">
  </span></pre>
      </section>
      <section property="bibo:hasPart" resource="#Spatialization-panning-algorithm" typeof="bibo:Chapter">
        <h3 resource="#Spatialization-panning-algorithm" id="Spatialization-panning-algorithm"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.3 </span>
          Panning Algorithm
        </span></h3>
        <p>
          <em>Mono-to-stereo</em> and <em>stereo-to-stereo</em> panning must be
          supported. <em>Mono-to-stereo</em> processing is used when all
          connections to the input are mono. Otherwise
          <em>stereo-to-stereo</em> processing is used.
        </p>
        <section property="bibo:hasPart" resource="#Spatialzation-equal-power-panning" typeof="bibo:Chapter">
          <h4 resource="#Spatialzation-equal-power-panning" id="Spatialzation-equal-power-panning"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.3.1 </span>
            Equal-power panning
          </span></h4>
          <p>
            This is a simple and relatively inexpensive algorithm which
            provides basic, but reasonable results. It is used for the
            <a class="idlType" href="#idl-def-StereoPannerNode"><code>StereoPannerNode</code></a>, and for the
            <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a> when the <a href="#widl-PannerNode-panningModel"><code>panningModel</code></a>
            attribute is set to <code>"equalpower"</code>, in which case the
            the <em>elevation</em> value is ignored.
          </p>
          <p>
            For a <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a>, the following algorithm <em title="MUST" class="rfc2119">MUST</em>
            be implemented.
          </p>
          <ol>
            <li>
              <p>
                Let <em>azimuth</em> be the value computed in the <a href="#azimuth-elevation">azimuth and elevation</a> section.
              </p>
            </li>
            <li>
              <p>
                The <em>azimuth</em> value is first contained to be within the
                range [-90, 90] according to:
              </p>
              <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">  </span><span class="com">// First, clamp azimuth to allowed range of [-180, 180].</span><span class="pln">
  azimuth </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(-</span><span class="lit">180</span><span class="pun">,</span><span class="pln"> azimuth</span><span class="pun">);</span><span class="pln">
  azimuth </span><span class="pun">=</span><span class="pln"> min</span><span class="pun">(</span><span class="lit">180</span><span class="pun">,</span><span class="pln"> azimuth</span><span class="pun">);</span><span class="pln">

  </span><span class="com">// Then wrap to range [-90, 90].</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">azimuth </span><span class="pun">&lt;</span><span class="pln"> </span><span class="pun">-</span><span class="lit">90</span><span class="pun">)</span><span class="pln">
    azimuth </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">180</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> azimuth</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">azimuth </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">90</span><span class="pun">)</span><span class="pln">
    azimuth </span><span class="pun">=</span><span class="pln"> </span><span class="lit">180</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> azimuth</span><span class="pun">;</span><span class="pln">
        </span></pre>
            </li>
            <li>
              <p>
                A normalized value <em>x</em> is calculated from
                <em>azimuth</em> for a mono input as:
              </p>
              <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">  x </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">azimuth </span><span class="pun">+</span><span class="pln"> </span><span class="lit">90</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">180</span><span class="pun">;</span><span class="pln">
        </span></pre>
              <p>
                Or for a stereo input as:
              </p>
              <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">azimuth </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="com">// -90 ~ 0</span><span class="pln">
    </span><span class="com">// Transform the azimuth value from [-90, 0] degrees into the range [-90, 90].</span><span class="pln">
    x </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">azimuth </span><span class="pun">+</span><span class="pln"> </span><span class="lit">90</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">90</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="com">// 0 ~ 90</span><span class="pln">
    </span><span class="com">// Transform the azimuth value from [0, 90] degrees into the range [-90, 90].</span><span class="pln">
    x </span><span class="pun">=</span><span class="pln"> azimuth </span><span class="pun">/</span><span class="pln"> </span><span class="lit">90</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
        </span></pre>
            </li>
          </ol>
          <p>
            For a <a class="idlType" href="#idl-def-StereoPannerNode"><code>StereoPannerNode</code></a>, the following algorithm
            <em title="MUST" class="rfc2119">MUST</em> be implemented.
          </p>
          <ol>
            <li>
              <p>
                Let <em>pan</em> be the <a data-link-type="dfn" class="internalDFN" href="#dfn-computedvalue">computedValue</a> of the
                <code>pan</code> <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a> of this
                <a class="idlType" href="#idl-def-StereoPannerNode"><code>StereoPannerNode</code></a>.
              </p>
            </li>
            <li>
              <p>
                Clamp <em>pan</em> to [-1, 1].
              </p>
              <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">pan </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(-</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> pan</span><span class="pun">);</span><span class="pln">
pan </span><span class="pun">=</span><span class="pln"> min</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> pan</span><span class="pun">);</span><span class="pln">
        </span></pre>
            </li>
            <li>
              <p>
                Calculate <em>x</em> by normalizing <em>pan</em> value to [0,
                1]. For mono input:
              </p>
              <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">x </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pan </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln">
        </span></pre>
              <p>
                For stereo input:
              </p>
              <pre style="" class="highlight prettyprint prettyprinted"><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pan </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln">
  x </span><span class="pun">=</span><span class="pln"> pan </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">else</span><span class="pln">
  x </span><span class="pun">=</span><span class="pln"> pan</span><span class="pun">;</span><span class="pln">
        </span></pre>
            </li>
          </ol>
          <p>
            Then following steps are used to achieve equal-power panning:
          </p>
          <ol>
            <li>
              <p>
                Left and right gain values are calculated as:
              </p>
              <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">gainL </span><span class="pun">=</span><span class="pln"> cos</span><span class="pun">(</span><span class="pln">x </span><span class="pun">*</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">PI </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pun">);</span><span class="pln">
gainR </span><span class="pun">=</span><span class="pln"> sin</span><span class="pun">(</span><span class="pln">x </span><span class="pun">*</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">PI </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pun">);</span><span class="pln">
        </span></pre>
            </li>
            <li>
              <p>
                For mono input, the stereo output is calculated as:
              </p>
              <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">outputL </span><span class="pun">=</span><span class="pln"> input </span><span class="pun">*</span><span class="pln"> gainL</span><span class="pun">;</span><span class="pln">
outputR </span><span class="pun">=</span><span class="pln"> input </span><span class="pun">*</span><span class="pln"> gainR</span><span class="pun">;</span><span class="pln">
        </span></pre>
              <p>
                Else for stereo input, the output is calculated as:
              </p>
              <pre style="" class="highlight prettyprint prettyprinted"><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pan </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// Pass through inputL to outputL and equal-power pan inputR as in mono case.</span><span class="pln">
  outputL </span><span class="pun">=</span><span class="pln"> inputL </span><span class="pun">+</span><span class="pln"> inputR </span><span class="pun">*</span><span class="pln"> gainL</span><span class="pun">;</span><span class="pln">
  outputR </span><span class="pun">=</span><span class="pln"> inputR </span><span class="pun">*</span><span class="pln"> gainR</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// Pass through inputR to outputR and equal-power pan inputR as in mono case.</span><span class="pln">
  outputL </span><span class="pun">=</span><span class="pln"> inputL </span><span class="pun">*</span><span class="pln"> gainL</span><span class="pun">;</span><span class="pln">
  outputR </span><span class="pun">=</span><span class="pln"> inputR </span><span class="pun">+</span><span class="pln"> inputL </span><span class="pun">*</span><span class="pln"> gainR</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
        </span></pre>
            </li>
          </ol>
        </section>
        <section property="bibo:hasPart" resource="#hrtf-panning-stereo-only" typeof="bibo:Chapter" id="hrtf-panning-stereo-only">
          <h4 resource="#h-hrtf-panning-stereo-only" id="h-hrtf-panning-stereo-only"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.3.2 </span>
            HRTF panning (stereo only)
          </span></h4>
          <p>
            This requires a set of <a href="https://en.wikipedia.org/wiki/Head-related_transfer_function">HRTF</a>
            (Head-related Transfer Function) impulse responses recorded at a
            variety of azimuths and elevations. The implementation requires a
            highly optimized convolution function. It is somewhat more costly
            than "equalpower", but provides more perceptually spatialized
            sound.
          </p>
          <figure id="fig-a-diagram-showing-the-process-of-panning-a-source-using-hrtf.x">
            <img alt="HRTF panner" src="images/HRTF_panner.png">
            <figcaption>Fig. <span class="figno">12</span> <span class="fig-title">
              A diagram showing the process of panning a source using HRTF.
            </span></figcaption>
          </figure>
        </section>
      </section>
      <section property="bibo:hasPart" resource="#Spatialization-distance-effects" typeof="bibo:Chapter">
        <h3 resource="#Spatialization-distance-effects" id="Spatialization-distance-effects"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.4 </span>
          Distance Effects
        </span></h3>
        <p>
          Sounds which are closer are louder, while sounds further away are
          quieter. Exactly <em>how</em> a sound's volume changes according to
          distance from the listener depends on the <em>distanceModel</em>
          attribute.
        </p>
        <p>
          During audio rendering, a <em>distance</em> value will be calculated
          based on the panner and listener positions according to:
        </p>
        <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">  </span><span class="kwd">function</span><span class="pln"> dotProduct</span><span class="pun">(</span><span class="pln">v1</span><span class="pun">,</span><span class="pln"> v2</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> d </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">min</span><span class="pun">(</span><span class="pln">v1</span><span class="pun">.</span><span class="pln">length</span><span class="pun">,</span><span class="pln"> v2</span><span class="pun">.</span><span class="pln">length</span><span class="pun">);</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
      d </span><span class="pun">+=</span><span class="pln"> v1</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> v2</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> d</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> panner</span><span class="pun">.</span><span class="pln">position </span><span class="pun">-</span><span class="pln"> listener</span><span class="pun">.</span><span class="pln">position</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> distance </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">sqrt</span><span class="pun">(</span><span class="pln">dotProduct</span><span class="pun">(</span><span class="pln">v</span><span class="pun">,</span><span class="pln"> v</span><span class="pun">));</span><span class="pln">
  </span></pre>
        <p>
          <em>distance</em> will then be used to calculate
          <em>distanceGain</em> which depends on the <em>distanceModel</em>
          attribute. See the <a href="#idl-def-DistanceModelType">distanceModel</a> section for details of
          how this is calculated for each distance model. The value computed by
          the <a href="#idl-def-DistanceModelType">distanceModel</a> equations
          are to be clamped to [0, 1].
        </p>
        <p>
          As part of its processing, the <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a>
          scales/multiplies the input audio signal by <em>distanceGain</em> to
          make distant sounds quieter and nearer ones louder.
        </p>
      </section>
      <section property="bibo:hasPart" resource="#Spatialization-sound-cones" typeof="bibo:Chapter">
        <h3 resource="#Spatialization-sound-cones" id="Spatialization-sound-cones"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.5 </span>
          Sound Cones
        </span></h3>
        <p>
          The listener and each sound source have an orientation vector
          describing which way they are facing. Each sound source's sound
          projection characteristics are described by an inner and outer "cone"
          describing the sound intensity as a function of the source/listener
          angle from the source's orientation vector. Thus, a sound source
          pointing directly at the listener will be louder than if it is
          pointed off-axis. Sound sources can also be omni-directional.
        </p>
        <p>
          The following algorithm must be used to calculate the gain
          contribution due to the cone effect, given the source (the
          <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a>) and the listener:
        </p>
        <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">  </span><span class="kwd">function</span><span class="pln"> dotProduct</span><span class="pun">(</span><span class="pln">v1</span><span class="pun">,</span><span class="pln"> v2</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> d </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">min</span><span class="pun">(</span><span class="pln">v1</span><span class="pun">.</span><span class="pln">length</span><span class="pun">,</span><span class="pln"> v2</span><span class="pun">.</span><span class="pln">length</span><span class="pun">);</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
      d </span><span class="pun">+=</span><span class="pln"> v1</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> v2</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> d</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">function</span><span class="pln"> diff</span><span class="pun">(</span><span class="pln">v1</span><span class="pun">,</span><span class="pln"> v2</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[];</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">min</span><span class="pun">(</span><span class="pln">v1</span><span class="pun">.</span><span class="pln">length</span><span class="pun">,</span><span class="pln"> v2</span><span class="pun">.</span><span class="pln">length</span><span class="pun">);</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
      v</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> v1</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> v2</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> v</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">dotProduct</span><span class="pun">(</span><span class="pln">source</span><span class="pun">.</span><span class="pln">orientation</span><span class="pun">,</span><span class="pln"> source</span><span class="pun">.</span><span class="pln">orientation</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> </span><span class="pun">((</span><span class="pln">source</span><span class="pun">.</span><span class="pln">coneInnerAngle </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">source</span><span class="pun">.</span><span class="pln">coneOuterAngle </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)))</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> </span><span class="com">// no cone specified - unity gain</span><span class="pln">

  </span><span class="com">// Normalized source-listener vector</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> sourceToListener </span><span class="pun">=</span><span class="pln"> diff</span><span class="pun">(</span><span class="pln">listener</span><span class="pun">.</span><span class="pln">position</span><span class="pun">,</span><span class="pln"> source</span><span class="pun">.</span><span class="pln">position</span><span class="pun">);</span><span class="pln">
  sourceToListener</span><span class="pun">.</span><span class="pln">normalize</span><span class="pun">();</span><span class="pln">

  </span><span class="kwd">var</span><span class="pln"> normalizedSourceOrientation </span><span class="pun">=</span><span class="pln"> source</span><span class="pun">.</span><span class="pln">orientation</span><span class="pun">;</span><span class="pln">
  normalizedSourceOrientation</span><span class="pun">.</span><span class="pln">normalize</span><span class="pun">();</span><span class="pln">

  </span><span class="com">// Angle between the source orientation vector and the source-listener vector</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> dotProduct </span><span class="pun">=</span><span class="pln"> dotProduct</span><span class="pun">(</span><span class="pln">sourceToListener</span><span class="pun">,</span><span class="pln"> normalizedSourceOrientation</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> angle </span><span class="pun">=</span><span class="pln"> </span><span class="lit">180</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">acos</span><span class="pun">(</span><span class="pln">dotProduct</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">PI</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> absAngle </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">abs</span><span class="pun">(</span><span class="pln">angle</span><span class="pun">);</span><span class="pln">

  </span><span class="com">// Divide by 2 here since API is entire angle (not half-angle)</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> absInnerAngle </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">abs</span><span class="pun">(</span><span class="pln">source</span><span class="pun">.</span><span class="pln">coneInnerAngle</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> absOuterAngle </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">abs</span><span class="pun">(</span><span class="pln">source</span><span class="pun">.</span><span class="pln">coneOuterAngle</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> gain </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">

  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">absAngle </span><span class="pun">&lt;=</span><span class="pln"> absInnerAngle</span><span class="pun">)</span><span class="pln">
      </span><span class="com">// No attenuation</span><span class="pln">
      gain </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">absAngle </span><span class="pun">&gt;=</span><span class="pln"> absOuterAngle</span><span class="pun">)</span><span class="pln">
      </span><span class="com">// Max attenuation</span><span class="pln">
      gain </span><span class="pun">=</span><span class="pln"> source</span><span class="pun">.</span><span class="pln">coneOuterGain</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="com">// Between inner and outer cones</span><span class="pln">
      </span><span class="com">// inner -&gt; outer, x goes from 0 -&gt; 1</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> x </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">absAngle </span><span class="pun">-</span><span class="pln"> absInnerAngle</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="pun">(</span><span class="pln">absOuterAngle </span><span class="pun">-</span><span class="pln"> absInnerAngle</span><span class="pun">);</span><span class="pln">
      gain </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> x</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> source</span><span class="pun">.</span><span class="pln">coneOuterGain </span><span class="pun">*</span><span class="pln"> x</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">return</span><span class="pln"> gain</span><span class="pun">;</span><span class="pln">
  </span></pre>
      </section>
      <section property="bibo:hasPart" resource="#Spatialization-doppler-shift" typeof="bibo:Chapter">
        <h3 resource="#Spatialization-doppler-shift" id="Spatialization-doppler-shift"><span property="xhv:role" resource="xhv:heading"><span class="secno">7.6 </span>
          Doppler Shift
        </span></h3>
        <ul>
          <li>Introduces a pitch shift which can realistically simulate moving
          sources.
          </li>
          <li>Depends on: source / listener velocity vectors, speed of sound,
          doppler factor.
          </li>
        </ul>
        <p>
          The following algorithm must be used to calculate the doppler shift
          value which is used as an additional playback rate scalar for all
          <a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a>s connecting directly or
          indirectly to the <a class="idlType" href="#idl-def-PannerNode"><code>PannerNode</code></a>:
        </p>
        <pre style="" class="highlight prettyprint prettyprinted"><span class="pln">  </span><span class="kwd">var</span><span class="pln"> dopplerShift </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> </span><span class="com">// Initialize to default value</span><span class="pln">
  </span><span class="kwd">var</span><span class="pln"> dopplerFactor </span><span class="pun">=</span><span class="pln"> listener</span><span class="pun">.</span><span class="pln">dopplerFactor</span><span class="pun">;</span><span class="pln">

  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">dopplerFactor </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">var</span><span class="pln"> speedOfSound </span><span class="pun">=</span><span class="pln"> listener</span><span class="pun">.</span><span class="pln">speedOfSound</span><span class="pun">;</span><span class="pln">

      </span><span class="com">// Don't bother if both source and listener have no velocity.</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">dotProduct</span><span class="pun">(</span><span class="pln">source</span><span class="pun">.</span><span class="pln">velocity</span><span class="pun">,</span><span class="pln"> source</span><span class="pun">.</span><span class="pln">velocity</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> dotProduct</span><span class="pun">(</span><span class="pln">listener</span><span class="pun">.</span><span class="pln">velocity</span><span class="pun">,</span><span class="pln"> listener</span><span class="pun">.</span><span class="pln">velocity</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
          </span><span class="com">// Calculate the source to listener vector.</span><span class="pln">
          </span><span class="kwd">var</span><span class="pln"> sourceToListener </span><span class="pun">=</span><span class="pln"> diff</span><span class="pun">(</span><span class="pln">source</span><span class="pun">.</span><span class="pln">position</span><span class="pun">,</span><span class="pln"> listener</span><span class="pun">.</span><span class="pln">position</span><span class="pun">);</span><span class="pln">

          </span><span class="kwd">var</span><span class="pln"> sourceListenerMagnitude </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">sqrt</span><span class="pun">(</span><span class="pln">dotProduct</span><span class="pun">(</span><span class="pln">sourceToListener</span><span class="pun">,</span><span class="pln"> sourceToListener</span><span class="pun">);</span><span class="pln">

          </span><span class="kwd">var</span><span class="pln"> listenerProjection </span><span class="pun">=</span><span class="pln"> dotProduct</span><span class="pun">(</span><span class="pln">sourceToListener</span><span class="pun">,</span><span class="pln"> listener</span><span class="pun">.</span><span class="pln">velocity</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> sourceListenerMagnitude</span><span class="pun">;</span><span class="pln">
          </span><span class="kwd">var</span><span class="pln"> sourceProjection </span><span class="pun">=</span><span class="pln"> dotProduct</span><span class="pun">(</span><span class="pln">sourceToListener</span><span class="pun">,</span><span class="pln"> source</span><span class="pun">.</span><span class="pln">velocity</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> sourceListenerMagnitude</span><span class="pun">;</span><span class="pln">

          listenerProjection </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="pln">listenerProjection</span><span class="pun">;</span><span class="pln">
          sourceProjection </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="pln">sourceProjection</span><span class="pun">;</span><span class="pln">

          </span><span class="kwd">var</span><span class="pln"> scaledSpeedOfSound </span><span class="pun">=</span><span class="pln"> speedOfSound </span><span class="pun">/</span><span class="pln"> dopplerFactor</span><span class="pun">;</span><span class="pln">
          listenerProjection </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">min</span><span class="pun">(</span><span class="pln">listenerProjection</span><span class="pun">,</span><span class="pln"> scaledSpeedOfSound</span><span class="pun">);</span><span class="pln">
          sourceProjection </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">min</span><span class="pun">(</span><span class="pln">sourceProjection</span><span class="pun">,</span><span class="pln"> scaledSpeedOfSound</span><span class="pun">);</span><span class="pln">

          dopplerShift </span><span class="pun">=</span><span class="pln"> </span><span class="pun">((</span><span class="pln">speedOfSound </span><span class="pun">-</span><span class="pln"> dopplerFactor </span><span class="pun">*</span><span class="pln"> listenerProjection</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="pun">(</span><span class="pln">speedOfSound </span><span class="pun">-</span><span class="pln"> dopplerFactor </span><span class="pun">*</span><span class="pln"> sourceProjection</span><span class="pun">));</span><span class="pln">
          fixNANs</span><span class="pun">(</span><span class="pln">dopplerShift</span><span class="pun">);</span><span class="pln"> </span><span class="com">// Avoid illegal values</span><span class="pln">

          </span><span class="com">// Limit the pitch shifting to 4 octaves up and 3 octaves down.</span><span class="pln">
          dopplerShift </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">min</span><span class="pun">(</span><span class="pln">dopplerShift</span><span class="pun">,</span><span class="pln"> </span><span class="lit">16</span><span class="pun">);</span><span class="pln">
          dopplerShift </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Math</span><span class="pun">.</span><span class="pln">max</span><span class="pun">(</span><span class="pln">dopplerShift</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0.125</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span></pre>
      </section>
    </section>
    <section property="bibo:hasPart" resource="#Performance" typeof="bibo:Chapter">
      <!--OddPage--><h2 resource="#Performance" id="Performance"><span property="xhv:role" resource="xhv:heading"><span class="secno">8. </span>
        Performance Considerations
      </span></h2>
      <section property="bibo:hasPart" resource="#latency" typeof="bibo:Chapter" id="latency" class="informative">
        <h3 resource="#h-latency" id="h-latency"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.1 </span>
          Latency
        </span></h3><p><em>This section is non-normative.</em></p>
        <figure id="fig-use-cases-in-which-the-latency-can-be-important">
          <img alt="latency" src="images/latency.png">
          <figcaption>Fig. <span class="figno">13</span> <span class="fig-title">
            Use cases in which the latency can be important
          </span></figcaption>
        </figure>
        <p>
          For web applications, the time delay between mouse and keyboard
          events (keydown, mousedown, etc.) and a sound being heard is
          important.
        </p>
        <p>
          This time delay is called latency and is caused by several factors
          (input device latency, internal buffering latency, DSP processing
          latency, output device latency, distance of user's ears from
          speakers, etc.), and is cumulative. The larger this latency is, the
          less satisfying the user's experience is going to be. In the extreme,
          it can make musical production or game-play impossible. At moderate
          levels it can affect timing and give the impression of sounds lagging
          behind or the game being non-responsive. For musical applications the
          timing problems affect rhythm. For gaming, the timing problems affect
          precision of gameplay. For interactive applications, it generally
          cheapens the users experience much in the same way that very low
          animation frame-rates do. Depending on the application, a reasonable
          latency can be from as low as 3-6 milliseconds to 25-50 milliseconds.
        </p>
        <p>
          Implementations will generally seek to minimize overall latency.
        </p>
        <p>
          Along with minimizing overall latency, implementations will generally
          seek to minimize the difference between an
          <a class="idlType" href="#idl-def-AudioContext"><code>AudioContext</code></a>'s <code>currentTime</code> and an
          <a class="idlType" href="#idl-def-AudioProcessingEvent"><code>AudioProcessingEvent</code></a>'s <code>playbackTime</code>.
          Deprecation of <a class="idlType" href="#idl-def-ScriptProcessorNode"><code>ScriptProcessorNode</code></a> will make this
          consideration less important over time.
        </p>
      </section>
      <section property="bibo:hasPart" resource="#audio-buffer-copying" typeof="bibo:Chapter" id="audio-buffer-copying">
        <h3 resource="#h-audio-buffer-copying" id="h-audio-buffer-copying"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.2 </span>
          Audio Buffer Copying
        </span></h3>
        <p>
          When an <a href="#acquire-the-content">acquire the content</a>
          operation is performed on an <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>, the entire operation
          can usually be implemented without copying channel data. In
          particular, the last step should be performed lazily at the next
          <a href="#widl-AudioBuffer-getChannelData-Float32Array-unsigned-long-channel">
          <code>getChannelData</code></a> call. That means a sequence of
          consecutive <a href="#acquire-the-content">acquire the contents</a>
          operations with no intervening <a href="#widl-AudioBuffer-getChannelData-Float32Array-unsigned-long-channel">
          <code>getChannelData</code></a> (e.g. multiple
          <a class="idlType" href="#idl-def-AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a>s playing the same
          <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>) can be implemented with no
          allocations or copying.
        </p>
        <p>
          Implementations can perform an additional optimization: if <a href="#widl-AudioBuffer-getChannelData-Float32Array-unsigned-long-channel">
          getChannelData</a> is called on an <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>, fresh
          <code>ArrayBuffer</code>s have not yet been allocated, but all
          invokers of previous <a href="#acquire-the-content">acquire the
          content</a> operations on an <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a> have stopped using
          the <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>'s data, the raw data buffers can be recycled
          for use with new <a class="idlType" href="#idl-def-AudioBuffer"><code>AudioBuffer</code></a>s, avoiding any reallocation or
          copying of the channel data.
        </p>
      </section>
      <section property="bibo:hasPart" resource="#audioparam-transitions" typeof="bibo:Chapter" id="audioparam-transitions" class="informative">
        <h3 resource="#h-audioparam-transitions" id="h-audioparam-transitions"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.3 </span>
          AudioParam Transitions
        </span></h3><p><em>This section is non-normative.</em></p>
        <p>
          While no automatic smoothing is done when directly setting the
          <a href="#widl-AudioParam-value"><code>value</code></a> attribute of
          an <a class="idlType" href="#idl-def-AudioParam"><code>AudioParam</code></a>, for certain parameters, smooth
          transition are preferable to directly setting the value.
        </p>
        <p>
          Using the <a href="#widl-AudioParam-setTargetAtTime-AudioParam-float-target-double-startTime-float-timeConstant">
          <code>setTargetAtTime</code></a> method with a low
          <code>timeConstant</code> allows authors to perform a smooth
          transition.
        </p>
      </section>
      <section property="bibo:hasPart" resource="#audio-glitching" typeof="bibo:Chapter" id="audio-glitching">
        <h3 resource="#h-audio-glitching" id="h-audio-glitching"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.4 </span>
          Audio Glitching
        </span></h3>
        <p>
          Audio glitches are caused by an interruption of the normal continuous
          audio stream, resulting in loud clicks and pops. It is considered to
          be a catastrophic failure of a multi-media system and must be
          avoided. It can be caused by problems with the threads responsible
          for delivering the audio stream to the hardware, such as scheduling
          latencies caused by threads not having the proper priority and
          time-constraints. It can also be caused by the audio DSP trying to do
          more work than is possible in real-time given the CPU's speed.
        </p>
      </section>
      <section property="bibo:hasPart" resource="#JavaScriptPerformance" typeof="bibo:Chapter">
        <h3 resource="#JavaScriptPerformance" id="JavaScriptPerformance"><span property="xhv:role" resource="xhv:heading"><span class="secno">8.5 </span>
          JavaScript Issues with Real-Time Processing and Synthesis:
        </span></h3>While processing audio in JavaScript, it is extremely challenging
        to get reliable, glitch-free audio while achieving a reasonably
        low-latency, especially under heavy processor load.
        <ul>
          <li>JavaScript is very much slower than heavily optimized C++ code
          and is not able to take advantage of SSE optimizations and
          multi-threading which is critical for getting good performance on
          today's processors. Optimized native code can be on the order of
          twenty times faster for processing FFTs as compared with JavaScript.
          It is not efficient enough for heavy-duty processing of audio such as
          convolution and 3D spatialization of large numbers of audio sources.
          </li>
          <li>setInterval() and XHR handling will steal time from the audio
          processing. In a reasonably complex game, some JavaScript resources
          will be needed for game physics and graphics. This creates challenges
          because audio rendering is deadline driven (to avoid glitches and get
          low enough latency).
          </li>
          <li>JavaScript does not run in a real-time processing thread and thus
          can be pre-empted by many other threads running on the system.
          </li>
          <li>Garbage Collection (and autorelease pools on Mac OS X) can cause
          unpredictable delay on a JavaScript thread.
          </li>
          <li>Multiple JavaScript contexts can be running on the main thread,
          stealing time from the context doing the processing.
          </li>
          <li>Other code (other than JavaScript) such as page rendering runs on
          the main thread.
          </li>
          <li>Locks can be taken and memory is allocated on the JavaScript
          thread. This can cause additional thread preemption.
          </li>
        </ul>The problems are even more difficult with today's generation of
        mobile devices which have processors with relatively poor performance
        and power consumption / battery-life issues.
      </section>
    </section>
    <section property="bibo:hasPart" resource="#SecurityConsiderations" typeof="bibo:Chapter" class="informative">
      <!--OddPage--><h2 resource="#SecurityConsiderations" id="SecurityConsiderations"><span property="xhv:role" resource="xhv:heading"><span class="secno">9. </span>
        Security Considerations
      </span></h2><p><em>This section is non-normative.</em></p>
    </section>
    <section property="bibo:hasPart" resource="#PrivacyConsiderations" typeof="bibo:Chapter" class="informative">
      <!--OddPage--><h2 resource="#PrivacyConsiderations" id="PrivacyConsiderations"><span property="xhv:role" resource="xhv:heading"><span class="secno">10. </span>
        Privacy Considerations
      </span></h2><p><em>This section is non-normative.</em></p>
      <p>
        When giving various information on available
        <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a>s, the Web Audio <abbr title="Application Programming Interface">API</abbr> potentially exposes
        information on characteristic features of the client (such as audio
        hardware sample-rate) to any page that makes use of the
        <a class="idlType" href="#idl-def-AudioNode"><code>AudioNode</code></a> interface. Additionally, timing
        information can be collected through the
        <a class="idlType" href="#idl-def-AnalyserNode"><code>AnalyserNode</code></a> or
        <a class="idlType" href="#idl-def-ScriptProcessorNode"><code>ScriptProcessorNode</code></a> interface. The information
        could subsequently be used to create a fingerprint of the client.
      </p>
      <p>
        Currently audio input is not specified in this document, but it will
        involve gaining access to the client machine's audio input or
        microphone. This will require asking the user for permission in an
        appropriate way, probably via the <a href="https://w3c.github.io/mediacapture-main/#dom-mediadevices-getusermedia">
        getUserMedia() <abbr title="Application Programming Interface">API</abbr></a>.
      </p>
    </section>
    <section property="bibo:hasPart" resource="#requirements" typeof="bibo:Chapter">
      <!--OddPage--><h2 resource="#requirements" id="requirements"><span property="xhv:role" resource="xhv:heading"><span class="secno">11. </span>
        Requirements and Use Cases
      </span></h2>
      <p>
        Please see [<cite><a href="#bib-webaudio-usecases" class="bibref">webaudio-usecases</a></cite>].
      </p>
    </section>
    <section property="bibo:hasPart" resource="#acknowledgements" typeof="bibo:Chapter" id="acknowledgements">
      <!--OddPage--><h2 resource="#h-acknowledgements" id="h-acknowledgements"><span property="xhv:role" resource="xhv:heading"><span class="secno">12. </span>
        Acknowledgements
      </span></h2>
      <p>
        This specification is the collective work of the <abbr title="World Wide Web Consortium">W3C</abbr> <a href="http://www.w3.org/2011/audio/">Audio Working Group</a>.
      </p>
      <p>
        Members of the Working Group are (at the time of writing, and by
        alphabetical order):<br>
        Adenot, Paul (Mozilla Foundation) - Specification Co-editor; Akhgari,
        Ehsan (Mozilla Foundation); Berkovitz, Joe (Hal Leonard/Noteflight) –
        WG Chair; Bossart, Pierre (Intel Corporation); Carlson, Eric (Apple,
        Inc.); Choi, Hongchan (Google, Inc.); Geelnard, Marcus (Opera
        Software); Goode, Adam (Google, Inc.); Gregan, Matthew (Mozilla
        Foundation); Hofmann, Bill (Dolby Laboratories); Jägenstedt, Philip
        (Opera Software); Kalliokoski, Jussi (Invited Expert); Lilley, Chris
        (<abbr title="World Wide Web Consortium">W3C</abbr> Staff); Lowis, Chris (Invited Expert. WG co-chair from December
        2012 to September 2013, affiliated with British Broadcasting
        Corporation); Mandyam, Giridhar (Qualcomm Innovation Center, Inc);
        Noble, Jer (Apple, Inc.); O'Callahan, Robert(Mozilla Foundation);
        Onumonu, Anthony (British Broadcasting Corporation); Paradis, Matthew
        (British Broadcasting Corporation); Raman, T.V. (Google, Inc.);
        Schepers, Doug (<abbr title="World Wide Web Consortium">W3C</abbr>/<abbr title="Massachusetts Institute of Technology">MIT</abbr>); Shires, Glen (Google, Inc.); Smith, Michael
        (<abbr title="World Wide Web Consortium">W3C</abbr>/Keio); Thereaux, Olivier (British Broadcasting Corporation); Toy,
        Raymond (Google, Inc.); Verdie, Jean-Charles (MStar Semiconductor,
        Inc.); Wilson, Chris (Google,Inc.) - Specification Co-editor; ZERGAOUI,
        Mohamed (INNOVIMAX)
      </p>
      <p>
        Former members of the Working Group and contributors to the
        specification include:<br>
        Caceres, Marcos (Invited Expert); Cardoso, Gabriel (INRIA); Chen, Bin
        (Baidu, Inc.); MacDonald, Alistair (<abbr title="World Wide Web Consortium">W3C</abbr> Invited Experts) — WG co-chair
        from March 2011 to July 2012; Michel, Thierry (<abbr title="World Wide Web Consortium">W3C</abbr>/<abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr>); Rogers,
        Chris (Google, Inc.) – Specification Editor until August 2013; Wei,
        James (Intel Corporation);
      </p>
    </section>
    <section property="bibo:hasPart" resource="#ChangeLog" typeof="bibo:Chapter">
      <!--OddPage--><h2 resource="#ChangeLog" id="ChangeLog"><span property="xhv:role" resource="xhv:heading"><span class="secno">13. </span>
        Web Audio <abbr title="Application Programming Interface">API</abbr> Change Log
      </span></h2>
      <p>
        See <a href="changelog.html">changelog.html</a>.
      </p>
    </section>


<section property="bibo:hasPart" resource="#references" typeof="bibo:Chapter" id="references" class="appendix"><!--OddPage--><h2 resource="#h-references" id="h-references"><span property="xhv:role" resource="xhv:heading"><span class="secno">A. </span>References</span></h2><section property="bibo:hasPart" resource="#normative-references" typeof="bibo:Chapter" id="normative-references"><h3 resource="#h-normative-references" id="h-normative-references"><span property="xhv:role" resource="xhv:heading"><span class="secno">A.1 </span>Normative references</span></h3><dl resource="" class="bibliography"><dt id="bib-DOM">[DOM]</dt><dd>Anne van Kesteren; Aryeh Gregor; Ms2ger; Alex Russell; Robin Berjon. <a property="dc:requires" href="http://www.w3.org/TR/dom/"><cite>W3C DOM4</cite></a>. 19 November 2015. W3C Recommendation. URL: <a property="dc:requires" href="http://www.w3.org/TR/dom/">http://www.w3.org/TR/dom/</a>
</dd><dt id="bib-HTML">[HTML]</dt><dd>Ian Hickson. <a property="dc:requires" href="https://html.spec.whatwg.org/multipage/"><cite>HTML Standard</cite></a>. Living Standard. URL: <a property="dc:requires" href="https://html.spec.whatwg.org/multipage/">https://html.spec.whatwg.org/multipage/</a>
</dd><dt id="bib-RFC2119">[RFC2119]</dt><dd>S. Bradner. <a property="dc:requires" href="https://tools.ietf.org/html/rfc2119"><cite>Key words for use in RFCs to Indicate Requirement Levels</cite></a>. March 1997. Best Current Practice. URL: <a property="dc:requires" href="https://tools.ietf.org/html/rfc2119">https://tools.ietf.org/html/rfc2119</a>
</dd><dt id="bib-TYPED-ARRAYS">[TYPED-ARRAYS]</dt><dd>David Herman; Kenneth Russell. <a property="dc:requires" href="https://www.khronos.org/registry/typedarray/specs/latest/"><cite>Typed Array Specification</cite></a>. 26 June 2013. Khronos Working Draft. URL: <a property="dc:requires" href="https://www.khronos.org/registry/typedarray/specs/latest/">https://www.khronos.org/registry/typedarray/specs/latest/</a>
</dd><dt id="bib-WEBIDL">[WEBIDL]</dt><dd>Cameron McCormack; Boris Zbarsky. <a property="dc:requires" href="http://www.w3.org/TR/WebIDL-1/"><cite>WebIDL Level 1</cite></a>. 4 August 2015. W3C Working Draft. URL: <a property="dc:requires" href="http://www.w3.org/TR/WebIDL-1/">http://www.w3.org/TR/WebIDL-1/</a>
</dd><dt id="bib-Workers">[Workers]</dt><dd>Ian Hickson. <a property="dc:requires" href="http://www.w3.org/TR/workers/"><cite>Web Workers</cite></a>. 24 September 2015. W3C Working Draft. URL: <a property="dc:requires" href="http://www.w3.org/TR/workers/">http://www.w3.org/TR/workers/</a>
</dd><dt id="bib-mediacapture-streams">[mediacapture-streams]</dt><dd>Daniel Burnett; Adam Bergkvist; Cullen Jennings; Anant Narayanan. <a property="dc:requires" href="http://www.w3.org/TR/mediacapture-streams/"><cite>Media Capture and Streams</cite></a>. 14 April 2015. W3C Last Call Working Draft. URL: <a property="dc:requires" href="http://www.w3.org/TR/mediacapture-streams/">http://www.w3.org/TR/mediacapture-streams/</a>
</dd><dt id="bib-webrtc">[webrtc]</dt><dd>Adam Bergkvist; Daniel Burnett; Cullen Jennings; Anant Narayanan. <a property="dc:requires" href="http://www.w3.org/TR/webrtc/"><cite>WebRTC 1.0: Real-time Communication Between Browsers</cite></a>. 10 February 2015. W3C Working Draft. URL: <a property="dc:requires" href="http://www.w3.org/TR/webrtc/">http://www.w3.org/TR/webrtc/</a>
</dd></dl></section><section property="bibo:hasPart" resource="#informative-references" typeof="bibo:Chapter" id="informative-references"><h3 resource="#h-informative-references" id="h-informative-references"><span property="xhv:role" resource="xhv:heading"><span class="secno">A.2 </span>Informative references</span></h3><dl resource="" class="bibliography"><dt id="bib-2dcontext">[2dcontext]</dt><dd>Rik Cabanier; Jatinder Mann; Jay Munro; Tom Wiltzius; Ian Hickson. <a property="dc:references" href="http://www.w3.org/TR/2dcontext/"><cite>HTML Canvas 2D Context</cite></a>. 19 November 2015. W3C Recommendation. URL: <a property="dc:references" href="http://www.w3.org/TR/2dcontext/">http://www.w3.org/TR/2dcontext/</a>
</dd><dt id="bib-WEBGL">[WEBGL]</dt><dd>Chris Marrin (Apple Inc.). <a property="dc:references" href="https://www.khronos.org/registry/webgl/specs/1.0/"><cite>WebGL Specification, Version 1.0</cite></a>. 10 February 2011. URL: <a property="dc:references" href="https://www.khronos.org/registry/webgl/specs/1.0/">https://www.khronos.org/registry/webgl/specs/1.0/</a>
</dd><dt id="bib-XHR">[XHR]</dt><dd>Anne van Kesteren. <a property="dc:references" href="https://xhr.spec.whatwg.org/"><cite>XMLHttpRequest Standard</cite></a>. Living Standard. URL: <a property="dc:references" href="https://xhr.spec.whatwg.org/">https://xhr.spec.whatwg.org/</a>
</dd><dt id="bib-mimesniff">[mimesniff]</dt><dd>Gordon P. Hemsley. <a property="dc:references" href="https://mimesniff.spec.whatwg.org/"><cite>MIME Sniffing Standard</cite></a>. Living Standard. URL: <a property="dc:references" href="https://mimesniff.spec.whatwg.org/">https://mimesniff.spec.whatwg.org/</a>
</dd><dt id="bib-webaudio-usecases">[webaudio-usecases]</dt><dd>Joe Berkovitz; Olivier Thereaux. <a property="dc:references" href="http://www.w3.org/TR/webaudio-usecases/"><cite>Web Audio Processing: Use Cases and Requirements</cite></a>. 29 January 2013. W3C Note. URL: <a property="dc:references" href="http://www.w3.org/TR/webaudio-usecases/">http://www.w3.org/TR/webaudio-usecases/</a>
</dd></dl></section></section></body></html>
